<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2020-12-22" />
  <title>`cbegin` on views</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center"><code class="sourceCode cpp">cbegin</code> on views</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>DxxxxR0</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2020-12-22</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      LEWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#how-we-got-to-here"><span class="toc-section-number">1</span> How we got to here<span></span></a>
<ul>
<li><a href="#prologue-terminology"><span class="toc-section-number">1.1</span> Prologue: Terminology<span></span></a></li>
<li><a href="#act-i-introduction-of-member-cbegin"><span class="toc-section-number">1.2</span> Act I: Introduction of member <code class="sourceCode cpp">cbegin</code><span></span></a></li>
<li><a href="#act-ii-rise-of-non-member-cbegin"><span class="toc-section-number">1.3</span> Act II: Rise of Non-member <code class="sourceCode cpp">cbegin</code><span></span></a></li>
<li><a href="#act-iii-climax-of-the-views"><span class="toc-section-number">1.4</span> Act III: Climax of the Views<span></span></a></li>
<li><a href="#intermezzo-examining-the-c20-status-quo"><span class="toc-section-number">1.5</span> Intermezzo: Examining the C++20 Status Quo<span></span></a></li>
<li><a href="#a-non-solution-member-cbegin"><span class="toc-section-number">1.6</span> A non-solution: member <code class="sourceCode cpp">cbegin<span class="op">()</span></code><span></span></a></li>
</ul></li>
<li><a href="#act-iv-stdconst_iterator"><span class="toc-section-number">2</span> Act IV: <code class="sourceCode cpp">std<span class="op">::</span>const_iterator</code><span></span></a>
<ul>
<li><a href="#a-reverse-digression"><span class="toc-section-number">2.1</span> A Reverse Digression<span></span></a></li>
<li><a href="#const-is-no-different"><span class="toc-section-number">2.2</span> Const Is No Different<span></span></a></li>
<li><a href="#implementing-a-stdconst_iteratorit"><span class="toc-section-number">2.3</span> Implementing a <code class="sourceCode cpp">std<span class="op">::</span>const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code><span></span></a></li>
<li><a href="#implementing-a-const_sentineli-s"><span class="toc-section-number">2.4</span> Implementing a <code class="sourceCode cpp">const_sentinel<span class="op">&lt;</span>I, S<span class="op">&gt;</span></code><span></span></a></li>
<li><a href="#better-algorithms-for-stdrangescbegin-and-stdrangesend"><span class="toc-section-number">2.5</span> Better algorithms for <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>end</code><span></span></a></li>
<li><a href="#a-viewsconst_"><span class="toc-section-number">2.6</span> A <code class="sourceCode cpp">views<span class="op">::</span>const_</code><span></span></a></li>
<li><a href="#what-about-stdcbegin-and-stdcend"><span class="toc-section-number">2.7</span> What about <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code>?<span></span></a></li>
</ul></li>
<li><a href="#act-v-a-concluding-proposal"><span class="toc-section-number">3</span> Act V: A Concluding Proposal<span></span></a></li>
<li><a href="#epilogue"><span class="toc-section-number">4</span> Epilogue<span></span></a></li>
<li><a href="#bibliography"><span class="toc-section-number">5</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="how-we-got-to-here"><span class="header-section-number">1</span> How we got to here<a href="#how-we-got-to-here" class="self-link"></a></h1>
<p>A tale in many parts acts.</p>
<h2 data-number="1.1" id="prologue-terminology"><span class="header-section-number">1.1</span> Prologue: Terminology<a href="#prologue-terminology" class="self-link"></a></h2>
<p>The term <code class="sourceCode cpp">const_iterator</code> can have two possible connotations. It can be used to refer to an iterator that is not writable (typically because <code class="sourceCode cpp"><span class="op">*</span>it</code> is a <code class="sourceCode cpp">T <span class="kw">const</span><span class="op">&amp;</span></code> for some object type <code class="sourceCode cpp">T</code>). Or it can be used to refer to specifically the named member type <code class="sourceCode cpp">C<span class="op">::</span>const_iterator</code>.</p>
<p>Because there doesn’t seem to be a good alternative term for the former, I’ll do my best to make clear which usage I mean. It’s nearly always the former.</p>
<h2 data-number="1.2" id="act-i-introduction-of-member-cbegin"><span class="header-section-number">1.2</span> Act I: Introduction of member <code class="sourceCode cpp">cbegin</code><a href="#act-i-introduction-of-member-cbegin" class="self-link"></a></h2>
<p>In 2004, C++0x had added <code class="sourceCode cpp"><span class="kw">auto</span></code> but not yet added the range-based for statement. So there was this problem: how do you write a for loop that is immutable? The goal of the paper was quite clear:</p>
<div class="quote">
<p>This paper proposes to improve user access to the <code class="sourceCode cpp"><span class="kw">const</span></code> versions of C++ container <code class="sourceCode cpp">iterator</code>s and <code class="sourceCode cpp">reverse_iterator</code>s.</p>
</div>
<p>and:</p>
<div class="quote">
<p>However, when a container traversal is intended for inspection only, it is a generally preferred practice to use a <code class="sourceCode cpp">const_iterator</code> in order to permit the compiler to diagnose <code class="sourceCode cpp"><span class="kw">const</span></code>-correctness violations</p>
</div>
<p>The solution proposed in <span class="citation" data-cites="N1674">[<a href="#ref-N1674" role="doc-biblioref">N1674</a>]</span> (and later adopted by way of <span class="citation" data-cites="N1913">[<a href="#ref-N1913" role="doc-biblioref">N1913</a>]</span>) was to add members <code class="sourceCode cpp">cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">cend<span class="op">()</span></code> (and <code class="sourceCode cpp">crbegin<span class="op">()</span></code> and <code class="sourceCode cpp">crend<span class="op">()</span></code>) to all the standard library containers, facilitating this code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> v<span class="op">.</span>cbegin<span class="op">()</span>,end<span class="op">=</span>v<span class="op">.</span>cend<span class="op">()</span>; it<span class="op">!=</span>end; <span class="op">++</span>it<span class="op">)</span>  <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="co">//use *it ...</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="op">}</span></span></code></pre></div>
<p><code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> was specified in all of these containers perform <code class="sourceCode cpp">as_const<span class="op">(</span>c<span class="op">).</span>begin<span class="op">()</span></code>. Although <code class="sourceCode cpp">std<span class="op">::</span>as_const</code> itself was not added until much later - it is a C++17 feature, first proposed in <span class="citation" data-cites="N4380">[<a href="#ref-N4380" role="doc-biblioref">N4380</a>]</span>.</p>
<h2 data-number="1.3" id="act-ii-rise-of-non-member-cbegin"><span class="header-section-number">1.3</span> Act II: Rise of Non-member <code class="sourceCode cpp">cbegin</code><a href="#act-ii-rise-of-non-member-cbegin" class="self-link"></a></h2>
<p>C++11 thus added the free functions <code class="sourceCode cpp">std<span class="op">::</span>begin</code> and <code class="sourceCode cpp">std<span class="op">::</span>end</code>, and member functions <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">c<span class="op">.</span>cend<span class="op">()</span></code>. But it did not yet have free functions to fetch <code class="sourceCode cpp">iterators</code> to <code class="sourceCode cpp"><span class="kw">const</span></code>: those were added in 2013 by way of <span class="citation" data-cites="LWG2128">[<a href="#ref-LWG2128" role="doc-biblioref">LWG2128</a>]</span>.</p>
<p>While, <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span></code> always calls <code class="sourceCode cpp">c<span class="op">.</span>begin<span class="op">()</span></code> (except for C arrays), <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> was not specified to call <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code>. Instead it, too, called <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span></code> (not even <code class="sourceCode cpp">c<span class="op">.</span>begin<span class="op">()</span></code>):</p>
<div class="quote">
<p>Implement <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code>/<code class="sourceCode cpp">cend<span class="op">()</span></code> by calling <code class="sourceCode cpp">std<span class="op">::</span>begin</code>/<code class="sourceCode cpp">end<span class="op">()</span></code>. This has numerous advantages:</p>
<ol type="1">
<li>It automatically works with arrays, which is the whole point of these non-member functions.</li>
<li>It works with C++98/03-era user containers, written before <code class="sourceCode cpp">cbegin</code>/<code class="sourceCode cpp">cend<span class="op">()</span></code> members were invented.</li>
<li>It works with <code class="sourceCode cpp">initializer_list</code>, which is extremely minimal and lacks <code class="sourceCode cpp">cbegin</code>/<code class="sourceCode cpp">cend<span class="op">()</span></code> members.</li>
<li>22.2.1 [container.requirements.general] guarantees that this is equivalent to calling <code class="sourceCode cpp">cbegin</code>/<code class="sourceCode cpp">cend<span class="op">()</span></code> members.</li>
</ol>
</div>
<p>There are two important goals here to highlight.</p>
<p>First, the goal is still to provide <code class="sourceCode cpp">const_iterator</code>s, not just call <code class="sourceCode cpp">begin<span class="op">()</span> <span class="kw">const</span></code>. The latter is an implementation strategy for the former.</p>
<p>Second, the goal is to avoid boilerplate. An implementation where <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> called <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> would require <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> to exist, which, as is clear from the list above, is not the for a lot of useful types.</p>
<p>As a result, <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> is basically specified to be <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>as_const<span class="op">(</span>c<span class="op">))</span></code> (although, again, predating <code class="sourceCode cpp">std<span class="op">::</span>as_const</code>) which is basically <code class="sourceCode cpp">as_const<span class="op">(</span>c<span class="op">).</span>begin<span class="op">()</span></code>.</p>
<p>The status quo at this point is that <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code>, <code class="sourceCode cpp">as_const<span class="op">(</span>c<span class="op">).</span>begin<span class="op">()</span></code>, and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> are all equivalent (where they are all valid) and all yield <code class="sourceCode cpp">const_iterator</code>s.</p>
<h2 data-number="1.4" id="act-iii-climax-of-the-views"><span class="header-section-number">1.4</span> Act III: Climax of the Views<a href="#act-iii-climax-of-the-views" class="self-link"></a></h2>
<p>Before 2018, the standard library had two non-owning range types: <code class="sourceCode cpp">std<span class="op">::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;</span></code> (since C++11) and <code class="sourceCode cpp">std<span class="op">::</span>string_view</code> (since C++17). Non-owning ranges are shallow-<code class="sourceCode cpp"><span class="kw">const</span></code>, but both of these types are <em>always</em>-<code class="sourceCode cpp"><span class="kw">const</span></code> so that distinction was insignificant.</p>
<p>That soon changed. 2018 opened with the addition of <code class="sourceCode cpp">std<span class="op">::</span>span</code> <span class="citation" data-cites="P0122R7">[<a href="#ref-P0122R7" role="doc-biblioref">P0122R7</a>]</span> and closed with the adoption of Ranges <span class="citation" data-cites="P0896R4">[<a href="#ref-P0896R4" role="doc-biblioref">P0896R4</a>]</span>, with a few more views added the subsequent year by way of <span class="citation" data-cites="P1035R7">[<a href="#ref-P1035R7" role="doc-biblioref">P1035R7</a>]</span>. Now, for the first time, the C++ standard library had non-owning ranges that were nevertheless mutable. Ranges itself was but a small part of the range-v3 library, so there is a promise of many more views to come.</p>
<p>These types really throw a wrench in the <code class="sourceCode cpp">cbegin</code> design: because now <code class="sourceCode cpp">begin<span class="op">()</span> <span class="kw">const</span></code> does not necessarily yield a <code class="sourceCode cpp">const_iterator</code> (i.e. a non-writable iterator), whereas this had previously always been the case.</p>
<p>It’s important to note that while it had previously always been the case <em>in the standard library</em>, that is not true for the broad C++ community. In particular, Boost.Range (which begat range-v3 which begat C++20 Ranges) has for a very long time had a type named <code class="sourceCode cpp">boost<span class="op">::</span>iterator_range<span class="op">&lt;</span>It<span class="op">&gt;</span></code> (the predecessor to<code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>subrange<span class="op">&lt;</span>It<span class="op">&gt;</span></code>). This is a view, although that term hadn’t existed yet, and so it had a <code class="sourceCode cpp">begin<span class="op">()</span> <span class="kw">const</span></code> member function that just returned an <code class="sourceCode cpp">It</code>. Which means that <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> on an <code class="sourceCode cpp">iterator_range<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;</span></code> gives you an <code class="sourceCode cpp"><span class="dt">int</span><span class="op">*</span></code> - a mutable iterator.</p>
<p>Where this discrepancy became most apparently visible was the specification of <code class="sourceCode cpp">std<span class="op">::</span>span</code> during the ballot resolution (by way of <span class="citation" data-cites="LWG3320">[<a href="#ref-LWG3320" role="doc-biblioref">LWG3320</a>]</span>). For the sake of simplicity, I am going to assume that the iterator types of <code class="sourceCode cpp">span<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp">span<span class="op">&lt;</span>T <span class="kw">const</span><span class="op">&gt;</span></code> are just <code class="sourceCode cpp">T<span class="op">*</span></code> and <code class="sourceCode cpp">T <span class="kw">const</span><span class="op">*</span></code>, respectively.</p>
<ul>
<li><code class="sourceCode cpp">span<span class="op">&lt;</span>T<span class="op">&gt;::</span>begin<span class="op">()</span> <span class="kw">const</span></code>, like all the other views, is shallow <code class="sourceCode cpp"><span class="kw">const</span></code>, and so returns <code class="sourceCode cpp">T<span class="op">*</span></code>.</li>
<li><code class="sourceCode cpp">span<span class="op">&lt;</span>T<span class="op">&gt;::</span>cbegin<span class="op">()</span> <span class="kw">const</span></code>, like the other standard library containers, was provided for convenient access to a <code class="sourceCode cpp">const_iterator</code>. This returned <code class="sourceCode cpp">T <span class="kw">const</span><span class="op">*</span></code>. Unlike the other standard library containers, this did not simply defer to <code class="sourceCode cpp">begin<span class="op">()</span> <span class="kw">const</span></code>.</li>
</ul>
<p>So far so good. But because <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>s<span class="op">)</span></code> is specified to do <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>as_const<span class="op">(</span>s<span class="op">))</span></code>, we end up having different behavior between <code class="sourceCode cpp">s<span class="op">.</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>s<span class="op">)</span></code>. This is the first (and, thus far, only) type in the standard library for which this is the case - and while <code class="sourceCode cpp">s<span class="op">.</span>cbegin<span class="op">()</span></code> would have yielded a <code class="sourceCode cpp">const_iterator</code>, <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>s<span class="op">)</span></code> does not.</p>
<p>As a result of NB comment resolution, to ship a coherent C++20, <code class="sourceCode cpp">span</code>’s <code class="sourceCode cpp">cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">cend<span class="op">()</span></code> members were removed, for consistency.</p>
<h2 data-number="1.5" id="intermezzo-examining-the-c20-status-quo"><span class="header-section-number">1.5</span> Intermezzo: Examining the C++20 Status Quo<a href="#intermezzo-examining-the-c20-status-quo" class="self-link"></a></h2>
<p>This leaves us in a state where:</p>
<ul>
<li><p>for all the standard library containers, <code class="sourceCode cpp">r<span class="op">.</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>r<span class="op">)</span></code> are equivalent, both meaning <code class="sourceCode cpp">as_const<span class="op">(</span>r<span class="op">).</span>begin<span class="op">()</span></code>, and both yielding a <code class="sourceCode cpp">const_iterator</code>. This is likely true for many containers defined outside of the standard library as well.</p></li>
<li><p>for most the standard library views, <code class="sourceCode cpp">r<span class="op">.</span>cbegin<span class="op">()</span></code> does not exist and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>r<span class="op">)</span></code> is a valid expression that could yield a mutable iterator (e.g. <code class="sourceCode cpp">std<span class="op">::</span>span<span class="op">&lt;</span>T<span class="op">&gt;</span></code>). There are three different kinds of exceptions:</p>
<ol type="1">
<li><code class="sourceCode cpp">std<span class="op">::</span>string_view<span class="op">::</span>cbegin<span class="op">()</span></code> exists and is a <code class="sourceCode cpp">const_iterator</code> (since it is <code class="sourceCode cpp"><span class="kw">const</span></code>-only). <code class="sourceCode cpp">std<span class="op">::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;::</span>cbegin<span class="op">()</span></code> does <em>not</em> exist, but <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>il<span class="op">)</span></code> also yields a <code class="sourceCode cpp">const_iterator</code>.</li>
<li><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>single_view<span class="op">&lt;</span>T<span class="op">&gt;</span></code> is an owning view and is actually thus deep <code class="sourceCode cpp"><span class="kw">const</span></code>. While it does not have a <code class="sourceCode cpp">cbegin<span class="op">()</span></code> member function, <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>v<span class="op">)</span></code> nevertheless yields a <code class="sourceCode cpp">const_iterator</code> (the proposed <code class="sourceCode cpp">views<span class="op">::</span>maybe</code> in <span class="citation" data-cites="P1255R6">[<a href="#ref-P1255R6" role="doc-biblioref">P1255R6</a>]</span> would also fit into this category).</li>
<li><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>filter_view<span class="op">&lt;</span>V, F<span class="op">&gt;</span></code> is not actually <code class="sourceCode cpp"><span class="kw">const</span></code>-iterable at all, so it is neither the case that <code class="sourceCode cpp">filt<span class="op">.</span>cbegin<span class="op">()</span></code> exists as a member function nor that <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>filt<span class="op">)</span></code> (nor <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin<span class="op">(</span>filt<span class="op">)</span></code>) is well-formed. Other future views may fit into this category as well (e.g. my proposed improvement to <code class="sourceCode cpp">views<span class="op">::</span>split</code> in <span class="citation" data-cites="P2210R0">[<a href="#ref-P2210R0" role="doc-biblioref">P2210R0</a>]</span>).</li>
</ol></li>
</ul>
<p>Put differently, the C++20 status quo is that <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> on an owning range always provides a <code class="sourceCode cpp">const_iterator</code> while <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> on a non-owning view could provide a mutable iterator or not compile at all.</p>
<p>The original desire of Walter’s paper from more than 15 years ago (which, in 2020 terms, may as well have happened at the last Jupiter/Saturn conjunction) still holds today:</p>
<div class="quote">
<p>However, when a container traversal is intended for inspection only, it is a generally preferred practice to use a <code class="sourceCode cpp">const_iterator</code> in order to permit the compiler to diagnose <code class="sourceCode cpp"><span class="kw">const</span></code>-correctness violations</p>
</div>
<p>How could we add <code class="sourceCode cpp"><span class="kw">const</span></code>-correctness to views?</p>
<h2 data-number="1.6" id="a-non-solution-member-cbegin"><span class="header-section-number">1.6</span> A non-solution: member <code class="sourceCode cpp">cbegin<span class="op">()</span></code><a href="#a-non-solution-member-cbegin" class="self-link"></a></h2>
<p>One approach we could take to provide reliable <code class="sourceCode cpp"><span class="kw">const</span></code>-traversal of unknown ranges is to push the problem onto the ranges:</p>
<ol type="1">
<li>We could say that <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> (and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> as well) first tries to call <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> if that exists and only if it doesn’t to fall-back to its present behavior of <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>as_const<span class="op">(</span>c<span class="op">))</span></code>.</li>
<li>We could then pair such a change with going through the standard library and ensuring that all views have a member <code class="sourceCode cpp">cbegin<span class="op">()</span> <span class="kw">const</span></code> that yields a <code class="sourceCode cpp">const_iterator</code>. Even the ones like <code class="sourceCode cpp">std<span class="op">::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;</span></code> that don’t currently have such a member?</li>
</ol>
<p>Such a design would ensure that for all standard library ranges, <code class="sourceCode cpp">r<span class="op">.</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>r<span class="op">)</span></code> are equivalent and yield a <code class="sourceCode cpp">const_iterator</code>. Except for <code class="sourceCode cpp">filter_view</code>, for which <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>filt<span class="op">)</span></code> would continue to not compile as it takes a <code class="sourceCode cpp">C <span class="kw">const</span><span class="op">&amp;</span></code>.</p>
<p>What does this do for all the views outside of the standard library? It does nothing. <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>v<span class="op">)</span></code> on such views would continue to yield a mutable iterator, as it does today with <code class="sourceCode cpp">boost<span class="op">::</span>iterator_range</code>. That, in of itself, makes this change somewhat unsatisfactory.</p>
<p>But what would it actually mean to add a member <code class="sourceCode cpp">cbegin<span class="op">()</span> <span class="kw">const</span></code> to every view type? What would such a member function do? What it <em>should</em> do is the exact same thing for every view — the same exact same thing that all views external to the standard library would have to do in order to opt in to <code class="sourceCode cpp"><span class="kw">const</span></code>-traversal-on-demand.</p>
<p>But if every type needs to do the asme thing, that’s an algorithm. The standard library should provide it once rather than having every view re-implement it. Or, more likely, have every view delegate to the algorithm and just have boilerplate member function implementations. A substantial amount of view implementations are already boilerplate, we do not need more.</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="act-iv-stdconst_iterator"><span class="header-section-number">2</span> Act IV: <code class="sourceCode cpp">std<span class="op">::</span>const_iterator</code><a href="#act-iv-stdconst_iterator" class="self-link"></a></h1>
<p>The problem we actually have is this: given an iterator, how do I create an iterator that is identical in all respects except for top-level mutability? This is, ultimately, the problem that from the very beginning <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;::</span>const_iterator</code> is intending to solve. It is a <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;::</span>iterator</code> in all respects (it’s random-access, its value type is <code class="sourceCode cpp">T</code>, it would have the same bounds coming from the same container) except that dereferencing such an iterator would give a <code class="sourceCode cpp">T <span class="kw">const</span><span class="op">&amp;</span></code> instead of a <code class="sourceCode cpp">T<span class="op">&amp;</span></code>.</p>
<h2 data-number="2.1" id="a-reverse-digression"><span class="header-section-number">2.1</span> A Reverse Digression<a href="#a-reverse-digression" class="self-link"></a></h2>
<p>We’re already used to the fact that some iterators are generic wrappers over other iterators. <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code> is already specified as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> Allocator <span class="op">=</span> allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="kw">class</span> vector <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="co">// types</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    </span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="kw">using</span> iterator               <span class="op">=</span> <em>implementation-defined</em>; <span class="co">// see [container.requirements]</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="kw">using</span> const_iterator         <span class="op">=</span> <em>implementation-defined</em>; <span class="co">// see [container.requirements]</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="kw">using</span> reverse_iterator       <span class="op">=</span> std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>iterator<span class="op">&gt;</span>;</span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="kw">using</span> const_reverse_iterator <span class="op">=</span> std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>const_iterator<span class="op">&gt;</span>;</span></code></pre></div>
<p>Nobody is especially surprised by the fact that every container isn’t manually implementing its own bespoke reverse iterators. <code class="sourceCode cpp">std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> does the job. Yet, <code class="sourceCode cpp">std<span class="op">::</span>rbegin<span class="op">(</span>c<span class="op">)</span></code> always calls <code class="sourceCode cpp">c<span class="op">.</span>rbegin<span class="op">()</span></code> (except for arrays). Even though we’ve had this perfectly generic solution for a long time, if you wanted your container to support reverse-iteration, you just had to write these boilerplate <code class="sourceCode cpp">rbegin<span class="op">()</span></code>/<code class="sourceCode cpp">rend<span class="op">()</span></code> member functions that wrapped your iterators.</p>
<p>Ranges improved this situation. <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>E<span class="op">)</span></code> is a much more complicated algorithm that takes many steps (see <span>24.3.6
 <a href="https://wg21.link/range.access.rbegin">[range.access.rbegin]</a></span> for complete description), but a key aspect of the design there is that if <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>begin<span class="op">(</span>E<span class="op">)</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>end<span class="op">(</span>E<span class="op">)</span></code> give you <code class="sourceCode cpp">bidirectional_iterator</code>s, then <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>E<span class="op">)</span></code> itself does the wrapping and provides you <code class="sourceCode cpp">make_reverse_iterator<span class="op">(</span>ranges​<span class="op">::</span>​end<span class="op">(</span>E<span class="op">))</span></code>. No more pushing work onto the containers. That means that it works even in this case:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">struct</span> simple_span <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="dt">int</span><span class="op">*</span> begin<span class="op">()</span> <span class="kw">const</span>;</span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="dt">int</span><span class="op">*</span> end<span class="op">()</span> <span class="kw">const</span>;</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="op">}</span>;</span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="dt">void</span> algo<span class="op">(</span>simple_span ss<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="kw">auto</span> rit <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>ss<span class="op">)</span>; <span class="co">// ok</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="kw">auto</span> rend <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>rend<span class="op">(</span>ss<span class="op">)</span>;  <span class="co">// ok</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    <span class="co">// ...</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="op">}</span></span></code></pre></div>
<p><code class="sourceCode cpp">std<span class="op">::</span>rbegin</code> would’ve failed in this case, because we don’t have the boilerplate necessary to make it work. But instead of pushing that boilerplate onto <code class="sourceCode cpp">simple_span</code>, we consigned it into <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin</code>. A much better solution.</p>
<h2 data-number="2.2" id="const-is-no-different"><span class="header-section-number">2.2</span> Const Is No Different<a href="#const-is-no-different" class="self-link"></a></h2>
<p>A generic <code class="sourceCode cpp">reverse_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> is not that complicated. We’re basically inverting operations. But the crux of the iterator remains the same: <code class="sourceCode cpp"><span class="op">*</span>it</code> passes through to its underlying iterator.</p>
<p>A generic <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> at first seems much less complicated. <em>Every</em> operation is passthrough, except for one. We are <em>only</em> modifying the behavior of the dereference operator. Yet, doing the right thing for dereference is decidedly non-trivial. Let’s go through some cases. We’re going to look at both the value type and reference type of several ranges and say what we want the desired <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>iterator_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></code> to dereference into:</p>
<table>
<colgroup>
<col style="width: 25%"></col>
<col style="width: 25%"></col>
<col style="width: 25%"></col>
<col style="width: 25%"></col>
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><div style="text-align:center">
<strong><code class="sourceCode cpp">range_value_t<span class="op">&lt;</span>R<span class="op">&gt;</span></code></strong>
</div></th>
<th><div style="text-align:center">
<strong><code class="sourceCode cpp">range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;</span></code></strong>
</div></th>
<th><div style="text-align:center">
<strong>desired result type</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span><span class="op">&amp;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="kw">const</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
</tr>
<tr class="odd">
<td>a range of prvalue <code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> <span class="kw">const</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;::</span>reference</code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
</tr>
<tr class="even">
<td>zipping a <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp">vector<span class="op">&lt;</span>U<span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">&lt;</span>T<span class="op">&amp;</span>, U<span class="op">&amp;&gt;</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">&lt;</span>T <span class="kw">const</span><span class="op">&amp;</span>, U <span class="kw">const</span><span class="op">&amp;&gt;</span></code></td>
</tr>
</tbody>
</table>
<p>This table points out a few things:</p>
<ul>
<li>A first thought might be that we need to return a <code class="sourceCode cpp">range_value_t<span class="op">&lt;</span>R<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span></code>, but while that works in some cases, it would lead to every element dangling in other cases.</li>
<li>Sometimes, <code class="sourceCode cpp">It</code> is already a <code class="sourceCode cpp">const_iterator</code>, so we would want to actively avoid wrapping in such a case.</li>
<li>The last couple rows are hard.</li>
</ul>
<p>Thankfully, this is a solved problem. The <code class="sourceCode cpp">views<span class="op">::</span>const_</code> <a href="https://github.com/ericniebler/range-v3/blob/d098b9610ac2f182f667ae9274ac2fac7f1327f5/include/range/v3/view/const.hpp">in range-v3</a> has for many years used a formula that works for all of these cases. In C++20 Ranges terms, I would spell it this way:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_or_output_iterator It<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">using</span> const_ref_for <span class="op">=</span> std<span class="op">::</span>common_reference_t<span class="op">&lt;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    std<span class="op">::</span>iter_value_t<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;&amp;</span>,</span>
<span id="cb4-4"><a href="#cb4-4"></a>    std<span class="op">::</span>iter_reference_t<span class="op">&lt;</span>It<span class="op">&gt;&gt;</span>;</span></code></pre></div>
<p>This does not yield the correct result for the last row in my table at the moment, but if we make the changes to <code class="sourceCode cpp">std<span class="op">::</span>tuple</code> proscribed in <span class="citation" data-cites="P2214R0">[<a href="#ref-P2214R0" role="doc-biblioref">P2214R0</a>]</span>, then it would.</p>
<p>Avoiding unnecessary wrapping can be achieved through a factory function that checks to see if such wrapping would change type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_or_output_iterator It<span class="op">&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">constexpr</span> <span class="kw">auto</span> make_const_iterator<span class="op">(</span>It it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>same_as<span class="op">&lt;</span>const_ref_for<span class="op">&lt;</span>It<span class="op">&gt;</span>, std<span class="op">::</span>iter_reference_t<span class="op">&lt;</span>It<span class="op">&gt;&gt;)</span> <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>        <span class="co">// already a const_iterator</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>        <span class="cf">return</span> it;</span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>        <span class="cf">return</span> const_iterator<span class="op">&lt;</span>It<span class="op">&gt;(</span>it<span class="op">)</span>;</span>
<span id="cb5-8"><a href="#cb5-8"></a>    <span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="op">}</span></span></code></pre></div>
<h2 data-number="2.3" id="implementing-a-stdconst_iteratorit"><span class="header-section-number">2.3</span> Implementing a <code class="sourceCode cpp">std<span class="op">::</span>const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code><a href="#implementing-a-stdconst_iteratorit" class="self-link"></a></h2>
<p>There’s a lot of boilerplate in implementing a C++20 iterator. And especially for <code class="sourceCode cpp">const_iterator</code> where every single operation but one is simply pass-through to the underlying iterator. Every function here is a one-liner, there are really only three interesting things in this whole implementation:</p>
<ol type="1">
<li>Providing <code class="sourceCode cpp">iterator_concept <span class="op">=</span> contiguous_iterator_tag;</code> ensures that wrapping a contiguous mutable iterator produces a contiguous <code class="sourceCode cpp">const_iterator</code>.</li>
<li>Only providing <code class="sourceCode cpp">iterator_category</code> for <code class="sourceCode cpp">forward_iterator</code>s ensures that we correctly handle C++20 input iterators (more on this later, and see also <span class="citation" data-cites="P2259R0">[<a href="#ref-P2259R0" role="doc-biblioref">P2259R0</a>]</span>).</li>
<li>The spelling of the <code class="sourceCode cpp">reference</code> type for this iterator, described above.</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span> <span class="kw">struct</span> iterator_concept_for <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span> <span class="kw">requires</span> std<span class="op">::</span>contiguous_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">struct</span> iterator_concept_for<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="kw">using</span> iterator_concept <span class="op">=</span> std<span class="op">::</span>contiguous_iterator_tag;</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="op">}</span>;</span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span> <span class="kw">struct</span> iterator_category_for <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>forward_iterator It<span class="op">&gt;</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="kw">struct</span> iterator_category_for<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    <span class="kw">using</span> iterator_category <span class="op">=</span> <span class="kw">typename</span> std<span class="op">::</span>iterator_traits<span class="op">&lt;</span>It<span class="op">&gt;::</span>iterator_category;</span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="op">}</span>;</span>
<span id="cb6-12"><a href="#cb6-12"></a></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_or_output_iterator It<span class="op">&gt;</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="kw">class</span> const_iterator <span class="op">:</span> <span class="kw">public</span> iterator_concept_for<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>                     , <span class="kw">public</span> iterator_category_for<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="op">{</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>    It it;</span>
<span id="cb6-18"><a href="#cb6-18"></a></span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>    <span class="kw">using</span> value_type <span class="op">=</span> std<span class="op">::</span>iter_value_t<span class="op">&lt;</span>It<span class="op">&gt;</span>;</span>
<span id="cb6-21"><a href="#cb6-21"></a>    <span class="kw">using</span> difference_type <span class="op">=</span> std<span class="op">::</span>iter_difference_t<span class="op">&lt;</span>It<span class="op">&gt;</span>;</span>
<span id="cb6-22"><a href="#cb6-22"></a>    <span class="kw">using</span> reference <span class="op">=</span> const_ref_for<span class="op">&lt;</span>It<span class="op">&gt;</span>;</span>
<span id="cb6-23"><a href="#cb6-23"></a></span>
<span id="cb6-24"><a href="#cb6-24"></a>    const_iterator<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb6-25"><a href="#cb6-25"></a>    const_iterator<span class="op">(</span>It it<span class="op">)</span> <span class="op">:</span> it<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>it<span class="op">))</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb6-26"><a href="#cb6-26"></a></span>
<span id="cb6-27"><a href="#cb6-27"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">++()</span> <span class="op">-&gt;</span> const_iterator<span class="op">&amp;</span> <span class="op">{</span> <span class="op">++</span>it; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb6-28"><a href="#cb6-28"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="op">-&gt;</span> const_iterator <span class="kw">requires</span> std<span class="op">::</span>forward_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="kw">auto</span> cpy <span class="op">=</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">++*</span><span class="kw">this</span>; <span class="cf">return</span> cpy; <span class="op">}</span>        </span>
<span id="cb6-29"><a href="#cb6-29"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span> <span class="op">++*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb6-30"><a href="#cb6-30"></a></span>
<span id="cb6-31"><a href="#cb6-31"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">--()</span> <span class="op">-&gt;</span> const_iterator<span class="op">&amp;</span> <span class="kw">requires</span> std<span class="op">::</span>bidirectional_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="op">--</span>it; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb6-32"><a href="#cb6-32"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">--(</span><span class="dt">int</span><span class="op">)</span> <span class="op">-&gt;</span> const_iterator <span class="kw">requires</span> std<span class="op">::</span>bidirectional_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="kw">auto</span> cpy <span class="op">=</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">--*</span><span class="kw">this</span>; <span class="cf">return</span> cpy; <span class="op">}</span>        </span>
<span id="cb6-33"><a href="#cb6-33"></a></span>
<span id="cb6-34"><a href="#cb6-34"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+(</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span> n<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> const_iterator <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> const_iterator<span class="op">(</span>it <span class="op">+</span> n<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb6-35"><a href="#cb6-35"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-(</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span> n<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> const_iterator <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> const_iterator<span class="op">(</span>it <span class="op">-</span> n<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb6-36"><a href="#cb6-36"></a>    <span class="kw">friend</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+(</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span> n, const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">-&gt;</span> const_iterator <span class="op">{</span> <span class="cf">return</span> rhs <span class="op">+</span> n; <span class="op">}</span></span>
<span id="cb6-37"><a href="#cb6-37"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+=(</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span> n<span class="op">)</span> <span class="op">-&gt;</span> const_iterator<span class="op">&amp;</span> <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> it <span class="op">+=</span> n; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb6-38"><a href="#cb6-38"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-=(</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span> n<span class="op">)</span> <span class="op">-&gt;</span> const_iterator<span class="op">&amp;</span> <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> it <span class="op">-=</span> n; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span>        </span>
<span id="cb6-39"><a href="#cb6-39"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-(</span>const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> difference_type <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> it <span class="op">-</span> rhs<span class="op">.</span>it; <span class="op">}</span></span>
<span id="cb6-40"><a href="#cb6-40"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">[](</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span> n<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> reference <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> it<span class="op">[</span>n<span class="op">]</span>; <span class="op">}</span></span>
<span id="cb6-41"><a href="#cb6-41"></a></span>
<span id="cb6-42"><a href="#cb6-42"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">*()</span> <span class="kw">const</span> <span class="op">-&gt;</span> reference <span class="op">{</span> <span class="cf">return</span> <span class="op">*</span>it; <span class="op">}</span></span>
<span id="cb6-43"><a href="#cb6-43"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="kw">const</span> <span class="op">-&gt;</span> value_type <span class="kw">const</span><span class="op">*</span> <span class="kw">requires</span> std<span class="op">::</span>contiguous_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> std<span class="op">::</span>to_address<span class="op">(</span>it<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb6-44"><a href="#cb6-44"></a></span>
<span id="cb6-45"><a href="#cb6-45"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">==(</span>const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span>  <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="kw">requires</span> std<span class="op">::</span>equality_comparable<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span>  <span class="cf">return</span> it <span class="op">==</span> rhs<span class="op">.</span>it; <span class="op">}</span></span>
<span id="cb6-46"><a href="#cb6-46"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> it <span class="op">&lt;=&gt;</span> rhs<span class="op">.</span>it; <span class="op">}</span></span>
<span id="cb6-47"><a href="#cb6-47"></a></span>
<span id="cb6-48"><a href="#cb6-48"></a>    <span class="kw">auto</span> base<span class="op">()</span> <span class="op">-&gt;</span> It<span class="op">&amp;</span> <span class="op">{</span> <span class="cf">return</span> it; <span class="op">}</span></span>
<span id="cb6-49"><a href="#cb6-49"></a>    <span class="kw">auto</span> base<span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> It <span class="kw">const</span><span class="op">&amp;</span> <span class="op">{</span> <span class="cf">return</span> it; <span class="op">}</span></span>
<span id="cb6-50"><a href="#cb6-50"></a><span class="op">}</span>;</span></code></pre></div>
<h2 data-number="2.4" id="implementing-a-const_sentineli-s"><span class="header-section-number">2.4</span> Implementing a <code class="sourceCode cpp">const_sentinel<span class="op">&lt;</span>I, S<span class="op">&gt;</span></code><a href="#implementing-a-const_sentineli-s" class="self-link"></a></h2>
<p>One of the changes in C++20 Ranges as compared to C++17 Ranges is the introduction of the Sentinel concept. A range is no longer a pair of two <code class="sourceCode cpp">iterator</code>s, it is an <code class="sourceCode cpp">iterator</code>/<code class="sourceCode cpp">sentinel</code> pair. The <code class="sourceCode cpp">sentinel</code> could be the same type as the <code class="sourceCode cpp">iterator</code>, such a range is known as a <code class="sourceCode cpp">common_range</code> but it need not be.</p>
<p>We would need to handle producing a wrapped <code class="sourceCode cpp">sentinel</code> in addition to producing a wrapped <code class="sourceCode cpp">iterator</code>. Thankfully, <code class="sourceCode cpp">sentinel</code> only has a single associated operation: <code class="sourceCode cpp"><span class="op">==</span></code>. As a result, while there are more cases to consider, the implementation is much less code:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_or_output_iterator It, std<span class="op">::</span>sentinel_for<span class="op">&lt;</span>It<span class="op">&gt;</span> S<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">struct</span> const_sentinel <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    S s;</span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>        <span class="cf">return</span> rhs<span class="op">.</span>base<span class="op">()</span> <span class="op">==</span> s;</span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="op">}</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="op">}</span>;</span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_or_output_iterator It, std<span class="op">::</span>sentinel_for<span class="op">&lt;</span>It<span class="op">&gt;</span> S<span class="op">&gt;</span></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="kw">constexpr</span> <span class="kw">auto</span> make_const_sentinel<span class="op">(</span>S s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>same_as<span class="op">&lt;</span>const_ref_for<span class="op">&lt;</span>It<span class="op">&gt;</span>, std<span class="op">::</span>iter_reference_t<span class="op">&lt;</span>It<span class="op">&gt;&gt;)</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>        <span class="co">// if the iterator is already a const_iterator, pass it through</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>        <span class="cf">return</span> s;</span>
<span id="cb7-14"><a href="#cb7-14"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>same_as<span class="op">&lt;</span>It, S<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>        <span class="co">// we have an iterator pair, so we wrap it the same way</span></span>
<span id="cb7-16"><a href="#cb7-16"></a>        <span class="cf">return</span> const_iterator<span class="op">&lt;</span>It<span class="op">&gt;(</span>s<span class="op">)</span>;</span>
<span id="cb7-17"><a href="#cb7-17"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18"></a>        <span class="cf">return</span> const_sentinel<span class="op">&lt;</span>It, S<span class="op">&gt;{</span>s<span class="op">}</span>;</span>
<span id="cb7-19"><a href="#cb7-19"></a>    <span class="op">}</span></span>
<span id="cb7-20"><a href="#cb7-20"></a><span class="op">}</span></span></code></pre></div>
<p>Note that we need the iterator type as a template parameter here.</p>
<h2 data-number="2.5" id="better-algorithms-for-stdrangescbegin-and-stdrangesend"><span class="header-section-number">2.5</span> Better algorithms for <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>end</code><a href="#better-algorithms-for-stdrangescbegin-and-stdrangesend" class="self-link"></a></h2>
<p><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> today (<span>24.3.4
 <a href="https://wg21.link/range.access.cbegin">[range.access.cbegin]</a></span>), similar <code class="sourceCode cpp">std<span class="op">::</span>begin</code>, unconditionally calls <code class="sourceCode cpp">ranges<span class="op">::</span>begin</code>. While <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>E<span class="op">)</span></code> does conditionally call <code class="sourceCode cpp">E<span class="op">.</span>rbegin<span class="op">()</span></code>, I wonder to what extent this facility actually needs to be customizeable. The goal is to provide a <code class="sourceCode cpp">const_iterator</code> version of <code class="sourceCode cpp">begin<span class="op">()</span></code>.</p>
<p>With the above pieces, we can do precisely that (<a href="https://godbolt.org/z/o3od9r">full implementation</a>):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="kw">auto</span> cbegin <span class="op">=</span> first_of<span class="op">(</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="co">// 1. non-borrowed rvalue</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    delete_if_nonborrowed_rvalue,</span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="co">// 2. make_const_iterator(begin(as_const(E)))</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="op">[](</span>std<span class="op">::</span>ranges<span class="op">::</span>range <span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">)</span> </span>
<span id="cb8-6"><a href="#cb8-6"></a>        RETURNS<span class="op">(</span>make_const_iterator<span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>begin<span class="op">(</span>std<span class="op">::</span>as_const<span class="op">(</span>r<span class="op">))))</span>,</span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="co">// 3. make_const_iterator(begin(E))</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="op">[](</span>std<span class="op">::</span>ranges<span class="op">::</span>range <span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">)</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>        RETURNS<span class="op">(</span>make_const_iterator<span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>begin<span class="op">(</span>r<span class="op">)))</span></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="op">)</span>;</span>
<span id="cb8-11"><a href="#cb8-11"></a></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="kw">auto</span> cend <span class="op">=</span> first_of<span class="op">(</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="co">// 1. non-borrowed rvalue</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>    delete_if_nonborrowed_rvalue,</span>
<span id="cb8-15"><a href="#cb8-15"></a>    <span class="co">// 2. make_const_sentinel&lt;iterator_t&lt;decltype(as_const(E))&gt;&gt;(end(as_const(E)))</span></span>
<span id="cb8-16"><a href="#cb8-16"></a>    <span class="op">[](</span>std<span class="op">::</span>ranges<span class="op">::</span>range <span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">)</span> </span>
<span id="cb8-17"><a href="#cb8-17"></a>        RETURNS<span class="op">(</span>make_const_sentinel<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>begin<span class="op">(</span>std<span class="op">::</span>as_const<span class="op">(</span>r<span class="op">)))&gt;(</span>std<span class="op">::</span>ranges<span class="op">::</span>end<span class="op">(</span>std<span class="op">::</span>as_const<span class="op">(</span>r<span class="op">))))</span>,</span>
<span id="cb8-18"><a href="#cb8-18"></a>    <span class="co">// 3. make_const_sentinel&lt;iterator_t&lt;decltype(E)&gt;(end(E))</span></span>
<span id="cb8-19"><a href="#cb8-19"></a>    <span class="op">[]&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>range R<span class="op">&gt;(</span>R<span class="op">&amp;&amp;</span> r<span class="op">)</span> </span>
<span id="cb8-20"><a href="#cb8-20"></a>        RETURNS<span class="op">(</span>make_const_sentinel<span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>iterator_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;(</span>std<span class="op">::</span>ranges<span class="op">::</span>end<span class="op">(</span>r<span class="op">)))</span></span>
<span id="cb8-21"><a href="#cb8-21"></a><span class="op">)</span>;</span></code></pre></div>
<p>Here, <code class="sourceCode cpp">cbegin<span class="op">(</span>r<span class="op">)</span></code> and <code class="sourceCode cpp">cend<span class="op">(</span>r<span class="op">)</span></code> produce a range that is top-level const over any underlying range, without having to modify any of those underlying ranges to opt in to this behavior. This works for <code class="sourceCode cpp">std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>span<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code> and <code class="sourceCode cpp">boost<span class="op">::</span>iterator_range<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;</span></code> and even <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>filter_view</code> (the third step — wrapping the result of <code class="sourceCode cpp">begin</code> and <code class="sourceCode cpp">end</code> without first going through <code class="sourceCode cpp">as_const</code> — is to handle views that are iterable but not <code class="sourceCode cpp"><span class="kw">const</span></code>-iterable, that you might nevertheless want <code class="sourceCode cpp">const_iterator</code>s for).</p>
<p>In addition to simply working across all ranges, it has a few other features worth noting:</p>
<ul>
<li>For a <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v</code>, <code class="sourceCode cpp">cbegin<span class="op">(</span>v<span class="op">)</span></code> gives precisely the type <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>const_iterator</code> (not <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>iterator<span class="op">&gt;</span></code>).</li>
<li>For a <code class="sourceCode cpp">span<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> s</code>, <code class="sourceCode cpp">cbegin<span class="op">(</span>s<span class="op">)</span></code> provides a contiguous iterator over <code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code>, not just any kind of iterator.</li>
</ul>
<h2 data-number="2.6" id="a-viewsconst_"><span class="header-section-number">2.6</span> A <code class="sourceCode cpp">views<span class="op">::</span>const_</code><a href="#a-viewsconst_" class="self-link"></a></h2>
<p>A whole const-view can be implemented on top of these pieces, in the same way that <code class="sourceCode cpp">views<span class="op">::</span>reverse</code> is implemented on top of <code class="sourceCode cpp">reverse_iterator</code> (full implementation at the <a href="https://godbolt.org/z/o3od9r">same link as before</a>):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>input_range V<span class="op">&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>view<span class="op">&lt;</span>V<span class="op">&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">class</span> const_view <span class="op">:</span> <span class="kw">public</span> std<span class="op">::</span>ranges<span class="op">::</span>view_interface<span class="op">&lt;</span>const_view<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>    V base <span class="op">=</span> V<span class="op">()</span>;</span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="kw">constexpr</span> const_view<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="kw">constexpr</span> const_view<span class="op">(</span>V base<span class="op">)</span> <span class="op">:</span> base<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>base<span class="op">))</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> begin<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> cbegin<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> end<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> cend<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> size<span class="op">()</span> <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>sized_range<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> std<span class="op">::</span>ranges<span class="op">::</span>size<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb9-12"><a href="#cb9-12"></a></span>
<span id="cb9-13"><a href="#cb9-13"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> begin<span class="op">()</span> <span class="kw">const</span> <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>range<span class="op">&lt;</span>V <span class="kw">const</span><span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> cbegin<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> end<span class="op">()</span> <span class="kw">const</span> <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>range<span class="op">&lt;</span>V <span class="kw">const</span><span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> cend<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> size<span class="op">()</span> <span class="kw">const</span> <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>sized_range<span class="op">&lt;</span>V <span class="kw">const</span><span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> std<span class="op">::</span>ranges<span class="op">::</span>size<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="op">}</span>;</span>
<span id="cb9-17"><a href="#cb9-17"></a></span>
<span id="cb9-18"><a href="#cb9-18"></a><span class="co">// libstdc++ specific (hopefully standard version coming soon!)</span></span>
<span id="cb9-19"><a href="#cb9-19"></a><span class="kw">inline</span> <span class="kw">constexpr</span> std<span class="op">::</span>views<span class="op">::</span>__adaptor<span class="op">::</span>_RangeAdaptorClosure const_ <span class="op">=</span></span>
<span id="cb9-20"><a href="#cb9-20"></a>    <span class="op">[]&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>viewable_range R<span class="op">&gt;(</span>R<span class="op">&amp;&amp;</span> r<span class="op">)</span></span>
<span id="cb9-21"><a href="#cb9-21"></a>    <span class="op">{</span></span>
<span id="cb9-22"><a href="#cb9-22"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>same_as<span class="op">&lt;</span>const_ref_for<span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>iterator_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span>, std<span class="op">::</span>ranges<span class="op">::</span>range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;)</span> <span class="op">{</span></span>
<span id="cb9-23"><a href="#cb9-23"></a>            <span class="cf">return</span> std<span class="op">::</span>views<span class="op">::</span>all<span class="op">(</span>FWD<span class="op">(</span>r<span class="op">))</span>;</span>
<span id="cb9-24"><a href="#cb9-24"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>enable_borrowed_range<span class="op">&lt;</span>std<span class="op">::</span>remove_cvref_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;)</span> <span class="op">{</span></span>
<span id="cb9-25"><a href="#cb9-25"></a>            <span class="cf">return</span> std<span class="op">::</span>ranges<span class="op">::</span>subrange<span class="op">(</span>cbegin<span class="op">(</span>FWD<span class="op">(</span>r<span class="op">))</span>, cend<span class="op">(</span>FWD<span class="op">(</span>r<span class="op">)))</span>;</span>
<span id="cb9-26"><a href="#cb9-26"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb9-27"><a href="#cb9-27"></a>            <span class="cf">return</span> const_view<span class="op">&lt;</span>std<span class="op">::</span>views<span class="op">::</span>all_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;(</span>std<span class="op">::</span>views<span class="op">::</span>all<span class="op">(</span>FWD<span class="op">(</span>r<span class="op">)))</span>;</span>
<span id="cb9-28"><a href="#cb9-28"></a>        <span class="op">}</span></span>
<span id="cb9-29"><a href="#cb9-29"></a>    <span class="op">}</span>;</span></code></pre></div>
<p>To me, this is the ultimate goal for this problem, since it’s the one that guarantees correctness even in the presence of a range-based for statement:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="kw">const</span><span class="op">&amp;</span> e <span class="op">:</span> r <span class="op">|</span> views<span class="op">::</span>const_<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<h2 data-number="2.7" id="what-about-stdcbegin-and-stdcend"><span class="header-section-number">2.7</span> What about <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code>?<a href="#what-about-stdcbegin-and-stdcend" class="self-link"></a></h2>
<p>The above presents an implementation strategy for <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cend</code>.</p>
<p>But what about <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code>? The problem is, while the former is C++20 technology and so can make use of the C++20 iterator model, <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> is C++11 technology and so has to remain fixed with the C++11 iterator model. The biggest difference for these purposes has to do with input iterators.</p>
<p>In C++11, even for an input iterator, this is valid code:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">auto</span> val <span class="op">=</span> <span class="op">*</span>it<span class="op">++</span>;</span></code></pre></div>
<p>But in C++20, an input iterator’s postfix increment operator need not return a copy of itself. All the ones in the standard library return <code class="sourceCode cpp"><span class="dt">void</span></code>. This is the safer design, since any use of postfix increment that isn’t either ignoring the result or exactly the above expression are simply wrong for input iterators.</p>
<p>Trying to be backwards compatible with pre-C++20 iterators is quite hard (again, see <span class="citation" data-cites="P2259R0">[<a href="#ref-P2259R0" role="doc-biblioref">P2259R0</a>]</span>), and the <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> implementation provided in this paper would <em>not</em> valid C++17 input iterator.</p>
<p>Additionally, the C++20 iterator concepts require default construction and not all C++17 iterators in the wild have this functionality, so we cannot impose it retroactively. Would we really want to introduce a second <code class="sourceCode cpp">const_iterator</code> type to improve <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code>? Moreover, would we want to extend <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> to also handle non-<code class="sourceCode cpp"><span class="kw">const</span></code>-iterable ranges? This is technically doable:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> C<span class="op">&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="kw">concept</span> can_begin <span class="op">=</span> <span class="kw">requires</span> <span class="op">(</span>C<span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span> std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb12-3"><a href="#cb12-3"></a></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="kw">requires</span> can_begin<span class="op">&lt;</span><span class="kw">const</span> C<span class="op">&gt;</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="kw">constexpr</span> <span class="kw">auto</span> cbegin<span class="op">(</span><span class="kw">const</span> C<span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>    <span class="co">// today&#39;s overload, but also conditionally wrap</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="op">}</span></span>
<span id="cb12-9"><a href="#cb12-9"></a></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>    <span class="kw">requires</span> <span class="op">(</span>can_begin<span class="op">&lt;</span>C<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>can_begin<span class="op">&lt;</span><span class="kw">const</span> C<span class="op">&gt;)</span></span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="kw">constexpr</span> <span class="kw">auto</span> cbegin<span class="op">(</span>C<span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>    <span class="co">// fallback for non-const-iterable ranges</span></span>
<span id="cb12-14"><a href="#cb12-14"></a><span class="op">}</span></span></code></pre></div>
<p>We the negated constraint to prefer the <code class="sourceCode cpp"><span class="kw">const</span> C<span class="op">&amp;</span></code> overload even for non-const arguments.</p>
<p>But we didn’t introduce a C++20 iteration model to then go back and give us more work to keep two models in lock-step. The C++20 one on its own is hard enough, and is a better model. We should just commit to it.</p>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="act-v-a-concluding-proposal"><span class="header-section-number">3</span> Act V: A Concluding Proposal<a href="#act-v-a-concluding-proposal" class="self-link"></a></h1>
<p>The status quo is that we have an algorithm named <code class="sourceCode cpp">cbegin</code> whose job is to provide a <code class="sourceCode cpp">const_iterator</code>, but it does not always do that, and sometimes it doesn’t even provide a mutable iterator. This is an unfortunate situation.</p>
<p>We can resolve this by extending <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cend</code> to conditionally wrap their provided range’s <code class="sourceCode cpp">iterator</code>/<code class="sourceCode cpp">sentinel</code> pairs to ensure that the result is a <code class="sourceCode cpp">const_iterator</code>, and use these tools to build up a <code class="sourceCode cpp">views<span class="op">::</span>const_</code> range adapter. This completely solves the problem without any imposed boilerplate per range.</p>
<p>However, <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code> are harder to extend and seem not worth doing so. This means that <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> do different things, but <code class="sourceCode cpp">std<span class="op">::</span>rbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin</code> <em>already</em> do different things. <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin</code> is already a superior <code class="sourceCode cpp">std<span class="op">::</span>rbegin</code>, so having <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> be a superior <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> only follows from that.</p>
<p>Ultimately, the question is where in the Ranges Plan for C++23 <span class="citation" data-cites="P2214R0">[<a href="#ref-P2214R0" role="doc-biblioref">P2214R0</a>]</span> such an improvement would fit in? That paper is focused exclusively on providing a large amount of new functionality to users. The facility proposed in this paper, while an improvement over the status quo, does not seem more important than any of that paper. I just want us to keep that in mind - I do not consider this problem in the top tier of ranges-related problems that need solving.</p>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="epilogue"><span class="header-section-number">4</span> Epilogue<a href="#epilogue" class="self-link"></a></h1>
<p>Thanks to Tim Song for helping me work through the design and implementation details of this paper, and Peter Dimov and Tomasz Kamiński for insisting on design sanity (even as they insisted on different designs).</p>
<h1 data-number="5" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">5</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-LWG2128">
<p>[LWG2128] Dmitry Polukhin. Absence of global functions cbegin/cend. <br />
<a href="https://wg21.link/lwg2128">https://wg21.link/lwg2128</a></p>
</div>
<div id="ref-LWG3320">
<p>[LWG3320] Poland. span::cbegin/cend methods produce different results than std::[ranges::]cbegin/cend. <br />
<a href="https://wg21.link/lwg3320">https://wg21.link/lwg3320</a></p>
</div>
<div id="ref-N1674">
<p>[N1674] Walter E. Brown. 2004-08-31. A Proposal to Improve const_iterator Use from C++0X Containers. <br />
<a href="https://wg21.link/n1674">https://wg21.link/n1674</a></p>
</div>
<div id="ref-N1913">
<p>[N1913] Walter E. Brown. 2005-10-20. A Proposal to Improve const_iterator Use (version 3). <br />
<a href="https://wg21.link/n1913">https://wg21.link/n1913</a></p>
</div>
<div id="ref-N4380">
<p>[N4380] ADAM David Alan Martin, Alisdair Meredith. 2015-02-05. Constant View: A proposal for a std::as_const helper function template. <br />
<a href="https://wg21.link/n4380">https://wg21.link/n4380</a></p>
</div>
<div id="ref-P0122R7">
<p>[P0122R7] Neil MacIntosh, Stephan T. Lavavej. 2018-03-16. span: bounds-safe views for sequences of objects. <br />
<a href="https://wg21.link/p0122r7">https://wg21.link/p0122r7</a></p>
</div>
<div id="ref-P0896R4">
<p>[P0896R4] Eric Niebler, Casey Carter, Christopher Di Bella. 2018-11-09. The One Ranges Proposal. <br />
<a href="https://wg21.link/p0896r4">https://wg21.link/p0896r4</a></p>
</div>
<div id="ref-P1035R7">
<p>[P1035R7] Christopher Di Bella, Casey Carter, Corentin Jabot. 2019-08-02. Input Range Adaptors. <br />
<a href="https://wg21.link/p1035r7">https://wg21.link/p1035r7</a></p>
</div>
<div id="ref-P1255R6">
<p>[P1255R6] Steve Downey. 2020-04-05. A view of 0 or 1 elements: views::maybe. <br />
<a href="https://wg21.link/p1255r6">https://wg21.link/p1255r6</a></p>
</div>
<div id="ref-P2210R0">
<p>[P2210R0] Barry Revzin. 2020-08-14. Superior String Splitting. <br />
<a href="https://wg21.link/p2210r0">https://wg21.link/p2210r0</a></p>
</div>
<div id="ref-P2214R0">
<p>[P2214R0] Barry Revzin, Conor Hoekstra, Tim Song. 2020-10-15. A Plan for C++23 Ranges. <br />
<a href="https://wg21.link/p2214r0">https://wg21.link/p2214r0</a></p>
</div>
<div id="ref-P2259R0">
<p>[P2259R0] Tim Song. 2020-11-20. Repairing input range adaptors and counted_iterator. <br />
<a href="https://wg21.link/p2259r0">https://wg21.link/p2259r0</a></p>
</div>
</div>
</div>
</div>
</body>
</html>

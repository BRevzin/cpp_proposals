<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2020-12-25" />
  <title>`cbegin` should always return a constant iterator</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center"><code class="sourceCode cpp">cbegin</code> should always return a constant iterator</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>DxxxxR0</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2020-12-25</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      LEWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#how-we-got-to-here"><span class="toc-section-number">1</span> How we got to here<span></span></a>
<ul>
<li><a href="#prologue-terminology"><span class="toc-section-number">1.1</span> Prologue: Terminology<span></span></a></li>
<li><a href="#act-i-introduction-of-member-cbegin"><span class="toc-section-number">1.2</span> Act I: Introduction of Member <code class="sourceCode cpp">cbegin</code><span></span></a></li>
<li><a href="#act-ii-rise-of-non-member-cbegin"><span class="toc-section-number">1.3</span> Act II: Rise of Non-Member <code class="sourceCode cpp">cbegin</code><span></span></a></li>
<li><a href="#act-iii-climax-of-the-views"><span class="toc-section-number">1.4</span> Act III: Climax of the Views<span></span></a></li>
<li><a href="#intermezzo-examining-the-c20-status-quo"><span class="toc-section-number">1.5</span> Intermezzo: Examining the C++20 Status Quo<span></span></a></li>
<li><a href="#a-non-solution-member-cbegin"><span class="toc-section-number">1.6</span> A Non-Solution: Member <code class="sourceCode cpp">cbegin<span class="op">()</span></code><span></span></a></li>
</ul></li>
<li><a href="#act-iv-stdconst_iterator"><span class="toc-section-number">2</span> Act IV: <code class="sourceCode cpp">std<span class="op">::</span>const_iterator</code><span></span></a>
<ul>
<li><a href="#a-reverse-digression"><span class="toc-section-number">2.1</span> A Reverse Digression<span></span></a></li>
<li><a href="#const-is-no-different"><span class="toc-section-number">2.2</span> Const Is No Different<span></span></a></li>
<li><a href="#implementing-stdconst_iteratorit"><span class="toc-section-number">2.3</span> Implementing <code class="sourceCode cpp">std<span class="op">::</span>const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code><span></span></a></li>
<li><a href="#implementing-const_sentineli-s"><span class="toc-section-number">2.4</span> Implementing <code class="sourceCode cpp">const_sentinel<span class="op">&lt;</span>I, S<span class="op">&gt;</span></code>?<span></span></a></li>
<li><a href="#better-algorithms-for-stdrangescbegin-and-stdrangesend"><span class="toc-section-number">2.5</span> Better Algorithms for <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>end</code><span></span></a></li>
<li><a href="#a-viewsconst_"><span class="toc-section-number">2.6</span> A <code class="sourceCode cpp">views<span class="op">::</span>const_</code><span></span></a></li>
<li><a href="#what-about-stdcbegin-and-stdcend"><span class="toc-section-number">2.7</span> What About <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code>?<span></span></a></li>
<li><a href="#now-reverse-it"><span class="toc-section-number">2.8</span> Now Reverse It<span></span></a></li>
</ul></li>
<li><a href="#act-v-a-concluding-proposal"><span class="toc-section-number">3</span> Act V: A Concluding Proposal<span></span></a></li>
<li><a href="#epilogue"><span class="toc-section-number">4</span> Epilogue<span></span></a></li>
<li><a href="#bibliography"><span class="toc-section-number">5</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="how-we-got-to-here"><span class="header-section-number">1</span> How we got to here<a href="#how-we-got-to-here" class="self-link"></a></h1>
<p>A tale in many acts.</p>
<h2 data-number="1.1" id="prologue-terminology"><span class="header-section-number">1.1</span> Prologue: Terminology<a href="#prologue-terminology" class="self-link"></a></h2>
<p><span>23.3.1
 <a href="https://wg21.link/iterator.requirements.general">[iterator.requirements.general]</a></span>/5 states:</p>
<blockquote>
<p>Iterators that further meet the requirements of output iterators are called <em>mutable iterators</em>. Nonmutable iterators are referred to as <em>constant iterators</em>.</p>
</blockquote>
<p>This paper uses those terms with those meanings: a mutable iterator is one that is writable to, a constant iterator is one that is not writable to.</p>
<h2 data-number="1.2" id="act-i-introduction-of-member-cbegin"><span class="header-section-number">1.2</span> Act I: Introduction of Member <code class="sourceCode cpp">cbegin</code><a href="#act-i-introduction-of-member-cbegin" class="self-link"></a></h2>
<p>In 2004, C++0x had added <code class="sourceCode cpp"><span class="kw">auto</span></code> but not yet added the range-based for statement. So there was this problem: how do you write a for loop that is immutable? The goal of the paper was quite clear:</p>
<div class="quote">
<p>This paper proposes to improve user access to the <code class="sourceCode cpp"><span class="kw">const</span></code> versions of C++ container <code class="sourceCode cpp">iterator</code>s and <code class="sourceCode cpp">reverse_iterator</code>s.</p>
</div>
<p>and:</p>
<div class="quote">
<p>However, when a container traversal is intended for inspection only, it is a generally preferred practice to use a <code class="sourceCode cpp">const_iterator</code> in order to permit the compiler to diagnose <code class="sourceCode cpp"><span class="kw">const</span></code>-correctness violations</p>
</div>
<p>The solution proposed in <span class="citation" data-cites="N1674">[<a href="#ref-N1674" role="doc-biblioref">N1674</a>]</span> (and later adopted by way of <span class="citation" data-cites="N1913">[<a href="#ref-N1913" role="doc-biblioref">N1913</a>]</span>) was to add members <code class="sourceCode cpp">cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">cend<span class="op">()</span></code> (and <code class="sourceCode cpp">crbegin<span class="op">()</span></code> and <code class="sourceCode cpp">crend<span class="op">()</span></code>) to all the standard library containers, facilitating this code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> v<span class="op">.</span>cbegin<span class="op">()</span>, end <span class="op">=</span> v<span class="op">.</span>cend<span class="op">()</span>; it <span class="op">!=</span> end; <span class="op">++</span>it<span class="op">)</span>  <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="co">//use *it ...</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="op">}</span></span></code></pre></div>
<p><code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> was specified in all of these containers to perform <code class="sourceCode cpp">as_const<span class="op">(</span>c<span class="op">).</span>begin<span class="op">()</span></code>. Although <code class="sourceCode cpp">std<span class="op">::</span>as_const</code> itself was not added until much later - it is a C++17 feature, first proposed in <span class="citation" data-cites="N4380">[<a href="#ref-N4380" role="doc-biblioref">N4380</a>]</span>.</p>
<h2 data-number="1.3" id="act-ii-rise-of-non-member-cbegin"><span class="header-section-number">1.3</span> Act II: Rise of Non-Member <code class="sourceCode cpp">cbegin</code><a href="#act-ii-rise-of-non-member-cbegin" class="self-link"></a></h2>
<p>C++11 thus added the free functions <code class="sourceCode cpp">std<span class="op">::</span>begin</code> and <code class="sourceCode cpp">std<span class="op">::</span>end</code>, and member functions <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">c<span class="op">.</span>cend<span class="op">()</span></code>. But it did not yet have free functions to fetch constant iterators: those were added in 2013 by way of <span class="citation" data-cites="LWG2128">[<a href="#ref-LWG2128" role="doc-biblioref">LWG2128</a>]</span>.</p>
<p>While, <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span></code> always calls <code class="sourceCode cpp">c<span class="op">.</span>begin<span class="op">()</span></code> (except for C arrays), <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> was not specified to call <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code>. Instead it, too, called <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span></code> (not even <code class="sourceCode cpp">c<span class="op">.</span>begin<span class="op">()</span></code>):</p>
<div class="quote">
<p>Implement <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code>/<code class="sourceCode cpp">cend<span class="op">()</span></code> by calling <code class="sourceCode cpp">std<span class="op">::</span>begin</code>/<code class="sourceCode cpp">end<span class="op">()</span></code>. This has numerous advantages:</p>
<ol type="1">
<li>It automatically works with arrays, which is the whole point of these non-member functions.</li>
<li>It works with C++98/03-era user containers, written before <code class="sourceCode cpp">cbegin</code>/<code class="sourceCode cpp">cend<span class="op">()</span></code> members were invented.</li>
<li>It works with <code class="sourceCode cpp">initializer_list</code>, which is extremely minimal and lacks <code class="sourceCode cpp">cbegin</code>/<code class="sourceCode cpp">cend<span class="op">()</span></code> members.</li>
<li>22.2.1 [container.requirements.general] guarantees that this is equivalent to calling <code class="sourceCode cpp">cbegin</code>/<code class="sourceCode cpp">cend<span class="op">()</span></code> members.</li>
</ol>
</div>
<p>There are two important goals here to highlight.</p>
<p>First, the goal is still to provide constant iterators, not just call <code class="sourceCode cpp">begin<span class="op">()</span> <span class="kw">const</span></code>. The latter is an implementation strategy for the former.</p>
<p>Second, the goal is to avoid boilerplate. An implementation where <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> called <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> would require <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> to exist, which, as is clear from the list above, is not the case for a lot of useful types.</p>
<p>As a result, <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> is basically specified to be <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>as_const<span class="op">(</span>c<span class="op">))</span></code> (although, again, predating <code class="sourceCode cpp">std<span class="op">::</span>as_const</code>) which is basically <code class="sourceCode cpp">as_const<span class="op">(</span>c<span class="op">).</span>begin<span class="op">()</span></code>.</p>
<p>The status quo at this point is that <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code>, <code class="sourceCode cpp">as_const<span class="op">(</span>c<span class="op">).</span>begin<span class="op">()</span></code>, and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> are all equivalent (where they are all valid) and all yield constant iterators.</p>
<h2 data-number="1.4" id="act-iii-climax-of-the-views"><span class="header-section-number">1.4</span> Act III: Climax of the Views<a href="#act-iii-climax-of-the-views" class="self-link"></a></h2>
<p>Before 2018, the standard library had two non-owning range types: <code class="sourceCode cpp">std<span class="op">::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;</span></code> (since C++11) and <code class="sourceCode cpp">std<span class="op">::</span>string_view</code> (since C++17). Non-owning ranges are shallow-<code class="sourceCode cpp"><span class="kw">const</span></code>, but both of these types are <em>always</em>-<code class="sourceCode cpp"><span class="kw">const</span></code> so that distinction was insignificant.</p>
<p>That soon changed. 2018 opened with the addition of <code class="sourceCode cpp">std<span class="op">::</span>span</code> <span class="citation" data-cites="P0122R7">[<a href="#ref-P0122R7" role="doc-biblioref">P0122R7</a>]</span> and closed with the adoption of Ranges <span class="citation" data-cites="P0896R4">[<a href="#ref-P0896R4" role="doc-biblioref">P0896R4</a>]</span>, with a few more views added the subsequent year by way of <span class="citation" data-cites="P1035R7">[<a href="#ref-P1035R7" role="doc-biblioref">P1035R7</a>]</span>. Now, for the first time, the C++ standard library had non-owning ranges that were nevertheless mutable. Ranges itself was but a small part of the range-v3 library, so there is a promise of many more views to come.</p>
<p>These types really throw a wrench in the <code class="sourceCode cpp">cbegin</code> design: because now <code class="sourceCode cpp">begin<span class="op">()</span> <span class="kw">const</span></code> does not necessarily yield a constant iterator, whereas this had previously always been the case.</p>
<p>It’s important to note that while it had previously always been the case <em>in the standard library</em>, that is not true for the broad C++ community. In particular, Boost.Range (which begat range-v3 which begat C++20 Ranges) has for a very long time had a type named <code class="sourceCode cpp">boost<span class="op">::</span>iterator_range<span class="op">&lt;</span>It<span class="op">&gt;</span></code> (the predecessor to <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>subrange<span class="op">&lt;</span>It<span class="op">&gt;</span></code>). This is a view, although that term hadn’t existed yet, and so it had a <code class="sourceCode cpp">begin<span class="op">()</span> <span class="kw">const</span></code> member function that just returned an <code class="sourceCode cpp">It</code>. Which means that <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> on an <code class="sourceCode cpp">iterator_range<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;</span></code> gives you an <code class="sourceCode cpp"><span class="dt">int</span><span class="op">*</span></code> - a mutable iterator.</p>
<p>Where this discrepancy became most apparently visible was the specification of <code class="sourceCode cpp">std<span class="op">::</span>span</code> during the ballot resolution (by way of <span class="citation" data-cites="LWG3320">[<a href="#ref-LWG3320" role="doc-biblioref">LWG3320</a>]</span>). For the sake of simplicity, I am going to assume that the iterator types of <code class="sourceCode cpp">span<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp">span<span class="op">&lt;</span>T <span class="kw">const</span><span class="op">&gt;</span></code> are just <code class="sourceCode cpp">T<span class="op">*</span></code> and <code class="sourceCode cpp">T <span class="kw">const</span><span class="op">*</span></code>, respectively.</p>
<ul>
<li><code class="sourceCode cpp">span<span class="op">&lt;</span>T<span class="op">&gt;::</span>begin<span class="op">()</span> <span class="kw">const</span></code>, like all the other views, is shallow <code class="sourceCode cpp"><span class="kw">const</span></code>, and so returns <code class="sourceCode cpp">T<span class="op">*</span></code>.</li>
<li><code class="sourceCode cpp">span<span class="op">&lt;</span>T<span class="op">&gt;::</span>cbegin<span class="op">()</span> <span class="kw">const</span></code>, like the other standard library containers, was provided for convenient access to a constant iterator. This returned <code class="sourceCode cpp">T <span class="kw">const</span><span class="op">*</span></code>. Unlike the other standard library containers, this did not simply defer to <code class="sourceCode cpp">begin<span class="op">()</span> <span class="kw">const</span></code>.</li>
</ul>
<p>So far so good. But because <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>s<span class="op">)</span></code> is specified to do <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>as_const<span class="op">(</span>s<span class="op">))</span></code>, we end up having different behavior between <code class="sourceCode cpp">s<span class="op">.</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>s<span class="op">)</span></code>. This is the first (and, thus far, only) type in the standard library for which this is the case - and while <code class="sourceCode cpp">s<span class="op">.</span>cbegin<span class="op">()</span></code> would have yielded a constant iterator, <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>s<span class="op">)</span></code> does not.</p>
<p>As a result of NB comment resolution, to ship a coherent C++20, <code class="sourceCode cpp">span</code>’s <code class="sourceCode cpp">cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">cend<span class="op">()</span></code> members were removed, for consistency.</p>
<h2 data-number="1.5" id="intermezzo-examining-the-c20-status-quo"><span class="header-section-number">1.5</span> Intermezzo: Examining the C++20 Status Quo<a href="#intermezzo-examining-the-c20-status-quo" class="self-link"></a></h2>
<p>This leaves us in a state where:</p>
<ul>
<li><p>for all the standard library containers, <code class="sourceCode cpp">r<span class="op">.</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>r<span class="op">)</span></code> are equivalent, both meaning <code class="sourceCode cpp">as_const<span class="op">(</span>r<span class="op">).</span>begin<span class="op">()</span></code>, and both yielding a constant iterator. This is likely true for many containers defined outside of the standard library as well.</p></li>
<li><p>for most of the standard library views, <code class="sourceCode cpp">r<span class="op">.</span>cbegin<span class="op">()</span></code> does not exist and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>r<span class="op">)</span></code> is a valid expression that could yield a mutable iterator (e.g. <code class="sourceCode cpp">std<span class="op">::</span>span<span class="op">&lt;</span>T<span class="op">&gt;</span></code>). There are three different kinds of exceptions:</p>
<ol type="1">
<li><code class="sourceCode cpp">std<span class="op">::</span>string_view<span class="op">::</span>cbegin<span class="op">()</span></code> exists and is a constant iterator (since it is <code class="sourceCode cpp"><span class="kw">const</span></code>-only). <code class="sourceCode cpp">std<span class="op">::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;::</span>cbegin<span class="op">()</span></code> does <em>not</em> exist, but <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>il<span class="op">)</span></code> also yields a constant iterator.</li>
<li><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>single_view<span class="op">&lt;</span>T<span class="op">&gt;</span></code> is an owning view and is actually thus deep <code class="sourceCode cpp"><span class="kw">const</span></code>. While it does not have a <code class="sourceCode cpp">cbegin<span class="op">()</span></code> member function, <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>v<span class="op">)</span></code> nevertheless yields a constant iterator (the proposed <code class="sourceCode cpp">views<span class="op">::</span>maybe</code> in <span class="citation" data-cites="P1255R6">[<a href="#ref-P1255R6" role="doc-biblioref">P1255R6</a>]</span> would also fit into this category).</li>
<li><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>filter_view<span class="op">&lt;</span>V, F<span class="op">&gt;</span></code> is not actually <code class="sourceCode cpp"><span class="kw">const</span></code>-iterable at all, so it is neither the case that <code class="sourceCode cpp">filt<span class="op">.</span>cbegin<span class="op">()</span></code> exists as a member function nor that <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>filt<span class="op">)</span></code> (nor <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin<span class="op">(</span>filt<span class="op">)</span></code>) is well-formed. Many other views fit this category as well (<code class="sourceCode cpp">drop_view</code> being the most obvious, but <code class="sourceCode cpp">drop</code>, <code class="sourceCode cpp">reverse</code>, and <code class="sourceCode cpp">join</code> may not be either, etc.). Other future views may fit into this category as well (e.g. my proposed improvement to <code class="sourceCode cpp">views<span class="op">::</span>split</code> in <span class="citation" data-cites="P2210R0">[<a href="#ref-P2210R0" role="doc-biblioref">P2210R0</a>]</span>).</li>
</ol></li>
</ul>
<p>Put differently, the C++20 status quo is that <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> on an owning range always provides a constant iterator while <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> on a non-owning view could provide a mutable iterator or not compile at all.</p>
<p>The original desire of Walter’s paper from more than 15 years ago (which, in 2020 terms, may as well have happened at the last Jupiter/Saturn conjunction) still holds today:</p>
<div class="quote">
<p>However, when a container traversal is intended for inspection only, it is a generally preferred practice to use a <code class="sourceCode cpp">const_iterator</code> in order to permit the compiler to diagnose <code class="sourceCode cpp"><span class="kw">const</span></code>-correctness violations</p>
</div>
<p>How could we add <code class="sourceCode cpp"><span class="kw">const</span></code>-correctness to views?</p>
<h2 data-number="1.6" id="a-non-solution-member-cbegin"><span class="header-section-number">1.6</span> A Non-Solution: Member <code class="sourceCode cpp">cbegin<span class="op">()</span></code><a href="#a-non-solution-member-cbegin" class="self-link"></a></h2>
<p>One approach we could take to provide reliable <code class="sourceCode cpp"><span class="kw">const</span></code>-traversal of unknown ranges is to push the problem onto the ranges:</p>
<ol type="1">
<li>We could say that <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> (and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> as well) first tries to call <code class="sourceCode cpp">c<span class="op">.</span>cbegin<span class="op">()</span></code> if that exists and only if it doesn’t to fall-back to its present behavior of <code class="sourceCode cpp">std<span class="op">::</span>begin<span class="op">(</span>as_const<span class="op">(</span>c<span class="op">))</span></code>.</li>
<li>We could then pair such a change with going through the standard library and ensuring that all views have a member <code class="sourceCode cpp">cbegin<span class="op">()</span> <span class="kw">const</span></code> that yields a constant iterator. Even the ones like <code class="sourceCode cpp">std<span class="op">::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;</span></code> that don’t currently have such a member?</li>
</ol>
<p>Such a design would ensure that for all standard library ranges, <code class="sourceCode cpp">r<span class="op">.</span>cbegin<span class="op">()</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>r<span class="op">)</span></code> are equivalent and yield a constant iterator. Except for <code class="sourceCode cpp">filter_view</code>, for which <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>filt<span class="op">)</span></code> would continue to not compile as it takes a <code class="sourceCode cpp">C <span class="kw">const</span><span class="op">&amp;</span></code>.</p>
<p>What does this do for all the views outside of the standard library? It does nothing. <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>v<span class="op">)</span></code> on such views would continue to yield a mutable iterator, as it does today with <code class="sourceCode cpp">boost<span class="op">::</span>iterator_range</code>. That, in of itself, makes this change somewhat unsatisfactory.</p>
<p>But what would it actually mean to add a member <code class="sourceCode cpp">cbegin<span class="op">()</span> <span class="kw">const</span></code> to every view type? What would such a member function do? What it <em>should</em> do is the exact same thing for every view — the same exact same thing that all views external to the standard library would have to do in order to opt in to <code class="sourceCode cpp"><span class="kw">const</span></code>-traversal-on-demand.</p>
<p>But if every type needs to do the same thing, that’s an algorithm. The standard library should provide it once rather than having every view re-implement it. Or, more likely, have every view delegate to the algorithm and just have boilerplate member function implementations. A substantial amount of view implementations are already boilerplate, we do not need more.</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="act-iv-stdconst_iterator"><span class="header-section-number">2</span> Act IV: <code class="sourceCode cpp">std<span class="op">::</span>const_iterator</code><a href="#act-iv-stdconst_iterator" class="self-link"></a></h1>
<p>The problem we actually have is this: given an iterator, how do I create an iterator that is identical in all respects except for top-level mutability? This is, ultimately, the problem that from the very beginning <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;::</span>const_iterator</code> is intending to solve. It is a <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;::</span>iterator</code> in all respects (it’s contiguous, its value type is <code class="sourceCode cpp">T</code>, it would have the same bounds coming from the same container) except that dereferencing such an iterator would give a <code class="sourceCode cpp">T <span class="kw">const</span><span class="op">&amp;</span></code> instead of a <code class="sourceCode cpp">T<span class="op">&amp;</span></code>.</p>
<h2 data-number="2.1" id="a-reverse-digression"><span class="header-section-number">2.1</span> A Reverse Digression<a href="#a-reverse-digression" class="self-link"></a></h2>
<p>We’re already used to the fact that some iterators are generic wrappers over other iterators. <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code> is already specified as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> Allocator <span class="op">=</span> allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="kw">class</span> vector <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="kw">public</span><span class="op">:</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="co">// types</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    </span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="kw">using</span> iterator               <span class="op">=</span> <em>implementation-defined</em>; <span class="co">// see [container.requirements]</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="kw">using</span> const_iterator         <span class="op">=</span> <em>implementation-defined</em>; <span class="co">// see [container.requirements]</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="kw">using</span> reverse_iterator       <span class="op">=</span> std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>iterator<span class="op">&gt;</span>;</span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="kw">using</span> const_reverse_iterator <span class="op">=</span> std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>const_iterator<span class="op">&gt;</span>;</span></code></pre></div>
<p>Nobody is especially surprised by the fact that every container isn’t manually implementing its own bespoke reverse iterators. <code class="sourceCode cpp">std<span class="op">::</span>reverse_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> does the job. Yet, <code class="sourceCode cpp">std<span class="op">::</span>rbegin<span class="op">(</span>c<span class="op">)</span></code> always calls <code class="sourceCode cpp">c<span class="op">.</span>rbegin<span class="op">()</span></code> (except for arrays). Even though we’ve had this perfectly generic solution for a long time, if you wanted your container to support reverse-iteration, you just had to write these boilerplate <code class="sourceCode cpp">rbegin<span class="op">()</span></code>/<code class="sourceCode cpp">rend<span class="op">()</span></code> member functions that wrapped your iterators.</p>
<p>Ranges improved this situation. <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>E<span class="op">)</span></code> is a much more complicated algorithm that takes many steps (see <span>24.3.6
 <a href="https://wg21.link/range.access.rbegin">[range.access.rbegin]</a></span> for complete description), but a key aspect of the design there is that if <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>begin<span class="op">(</span>E<span class="op">)</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>end<span class="op">(</span>E<span class="op">)</span></code> give you <code class="sourceCode cpp">bidirectional_iterator</code>s, then <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>E<span class="op">)</span></code> itself does the wrapping and provides you <code class="sourceCode cpp">make_reverse_iterator<span class="op">(</span>ranges​<span class="op">::</span>​end<span class="op">(</span>E<span class="op">))</span></code>. No more pushing work onto the containers. That means that it works even in this case:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">struct</span> simple_span <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="dt">int</span><span class="op">*</span> begin<span class="op">()</span> <span class="kw">const</span>;</span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="dt">int</span><span class="op">*</span> end<span class="op">()</span> <span class="kw">const</span>;</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="op">}</span>;</span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="dt">void</span> algo<span class="op">(</span>simple_span ss<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="kw">auto</span> rit <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>ss<span class="op">)</span>; <span class="co">// ok</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="kw">auto</span> rend <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>rend<span class="op">(</span>ss<span class="op">)</span>;  <span class="co">// ok</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    <span class="co">// ...</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="op">}</span></span></code></pre></div>
<p><code class="sourceCode cpp">std<span class="op">::</span>rbegin</code> would’ve failed in this case, because we don’t have the boilerplate necessary to make it work. But instead of pushing that boilerplate onto <code class="sourceCode cpp">simple_span</code>, we consigned it into <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin</code>. A much better solution.</p>
<h2 data-number="2.2" id="const-is-no-different"><span class="header-section-number">2.2</span> Const Is No Different<a href="#const-is-no-different" class="self-link"></a></h2>
<p>A generic <code class="sourceCode cpp">reverse_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> is not that complicated. We’re basically inverting operations. But the crux of the iterator remains the same: <code class="sourceCode cpp"><span class="op">*</span>it</code> passes through to its underlying iterator.</p>
<p>A generic <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> at first seems much less complicated. <em>Every</em> operation is passthrough, except for one. We are <em>only</em> modifying the behavior of the dereference operator. Yet, doing the right thing for dereference is decidedly non-trivial. Let’s go through some cases. We’re going to look at both the value type and reference type of several ranges and say what we want the desired <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>iterator_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></code> to dereference into:</p>
<table>
<colgroup>
<col style="width: 25%"></col>
<col style="width: 25%"></col>
<col style="width: 25%"></col>
<col style="width: 25%"></col>
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><div style="text-align:center">
<strong><code class="sourceCode cpp">range_value_t<span class="op">&lt;</span>R<span class="op">&gt;</span></code></strong>
</div></th>
<th><div style="text-align:center">
<strong><code class="sourceCode cpp">range_reference_t<span class="op">&lt;</span>R<span class="op">&gt;</span></code></strong>
</div></th>
<th><div style="text-align:center">
<strong>desired result type</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span><span class="op">&amp;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="kw">const</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">array<span class="op">&lt;</span><span class="dt">int</span> <span class="kw">const</span>, N<span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code></td>
</tr>
<tr class="even">
<td>a range of prvalue <code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">int</span></code></td>
</tr>
<tr class="odd">
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> <span class="kw">const</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
</tr>
<tr class="even">
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
<td><code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;::</span>reference</code></td>
<td><code class="sourceCode cpp"><span class="dt">bool</span></code></td>
</tr>
<tr class="odd">
<td>zipping a <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp">vector<span class="op">&lt;</span>U<span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">&lt;</span>T<span class="op">&amp;</span>, U<span class="op">&amp;&gt;</span></code></td>
<td><code class="sourceCode cpp">tuple<span class="op">&lt;</span>T <span class="kw">const</span><span class="op">&amp;</span>, U <span class="kw">const</span><span class="op">&amp;&gt;</span></code></td>
</tr>
</tbody>
</table>
<p>This table points out a few things:</p>
<ul>
<li>A first thought might be that we need to return a <code class="sourceCode cpp">range_value_t<span class="op">&lt;</span>R<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span></code>, but while that works in some cases, it would lead to every element dangling in other cases.</li>
<li>Sometimes, <code class="sourceCode cpp">It</code> is already a constant iterator, so we would want to actively avoid wrapping in such a case.</li>
<li>The last couple rows are hard.</li>
</ul>
<p>Thankfully, this is a solved problem. The <code class="sourceCode cpp">views<span class="op">::</span>const_</code> <a href="https://github.com/ericniebler/range-v3/blob/d098b9610ac2f182f667ae9274ac2fac7f1327f5/include/range/v3/view/const.hpp">in range-v3</a> has for many years used a formula that works for all of these cases. In C++20 Ranges terms, I would spell it this way:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_iterator It<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">using</span> const_ref_for <span class="op">=</span> std<span class="op">::</span>common_reference_t<span class="op">&lt;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    std<span class="op">::</span>iter_value_t<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;&amp;</span>,</span>
<span id="cb4-4"><a href="#cb4-4"></a>    std<span class="op">::</span>iter_reference_t<span class="op">&lt;</span>It<span class="op">&gt;&gt;</span>;</span></code></pre></div>
<p>This does not yield the correct result for the last row in my table at the moment, but if we make the changes to <code class="sourceCode cpp">std<span class="op">::</span>tuple</code> prescribed in <span class="citation" data-cites="P2214R0">[<a href="#ref-P2214R0" role="doc-biblioref">P2214R0</a>]</span>, then it would.</p>
<p>Avoiding unnecessary wrapping can be achieved through a factory function that checks to see if such wrapping would change type:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">// a type is a constant iterator if its an iterator whose reference type is</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co">// the same as the type that const_ref_for would pick for it</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">concept</span> <em>constant-iterator</em> <span class="op">=</span> std<span class="op">::</span>input_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>                         <span class="op">&amp;&amp;</span> std<span class="op">::</span>same_as<span class="op">&lt;</span>const_ref_for<span class="op">&lt;</span>It<span class="op">&gt;</span>, std<span class="op">::</span>iter_reference_t<span class="op">&lt;</span>It<span class="op">&gt;&gt;</span>;</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">// a type is a constant range if it is a range whose iterator is a constant iterator</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> R<span class="op">&gt;</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="kw">concept</span> <em>constant-range</em> <span class="op">=</span> std<span class="op">::</span>ranges<span class="op">::</span>range<span class="op">&lt;</span>R<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <em>constant-iterator</em><span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>iterator_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span>;</span>
<span id="cb5-10"><a href="#cb5-10"></a></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_iterator It<span class="op">&gt;</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="kw">constexpr</span> <span class="kw">auto</span> make_const_iterator<span class="op">(</span>It it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><em>constant-iterator</em><span class="op">&lt;</span>It<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>        <span class="co">// already a constant iterator</span></span>
<span id="cb5-15"><a href="#cb5-15"></a>        <span class="cf">return</span> it;</span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>        <span class="cf">return</span> const_iterator<span class="op">&lt;</span>It<span class="op">&gt;(</span>it<span class="op">)</span>;</span>
<span id="cb5-18"><a href="#cb5-18"></a>    <span class="op">}</span></span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="op">}</span></span></code></pre></div>
<h2 data-number="2.3" id="implementing-stdconst_iteratorit"><span class="header-section-number">2.3</span> Implementing <code class="sourceCode cpp">std<span class="op">::</span>const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code><a href="#implementing-stdconst_iteratorit" class="self-link"></a></h2>
<p>There’s a lot of boilerplate in implementing a C++20 iterator. And especially for <code class="sourceCode cpp">const_iterator</code> where every single operation but one is simply pass-through to the underlying iterator. Every function here is a one-liner, there are really only three interesting things in this whole implementation:</p>
<ol type="1">
<li>Providing <code class="sourceCode cpp">iterator_concept <span class="op">=</span> contiguous_iterator_tag;</code> ensures that wrapping a contiguous mutable iterator produces a contiguous constant iterator.</li>
<li>Only providing <code class="sourceCode cpp">iterator_category</code> for <code class="sourceCode cpp">forward_iterator</code>s ensures that we correctly handle C++20 input iterators (more on this later, and see also <span class="citation" data-cites="P2259R0">[<a href="#ref-P2259R0" role="doc-biblioref">P2259R0</a>]</span>).</li>
<li>The spelling of the <code class="sourceCode cpp">reference</code> type for this iterator, described above.</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span> <span class="kw">struct</span> iterator_concept_for <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span> <span class="kw">requires</span> std<span class="op">::</span>contiguous_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">struct</span> iterator_concept_for<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="kw">using</span> iterator_concept <span class="op">=</span> std<span class="op">::</span>contiguous_iterator_tag;</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="op">}</span>;</span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> It<span class="op">&gt;</span> <span class="kw">struct</span> iterator_category_for <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>forward_iterator It<span class="op">&gt;</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="kw">struct</span> iterator_category_for<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    <span class="kw">using</span> iterator_category <span class="op">=</span> <span class="kw">typename</span> std<span class="op">::</span>iterator_traits<span class="op">&lt;</span>It<span class="op">&gt;::</span>iterator_category;</span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="op">}</span>;</span>
<span id="cb6-12"><a href="#cb6-12"></a></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>input_iterator It<span class="op">&gt;</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="kw">class</span> const_iterator <span class="op">:</span> <span class="kw">public</span> iterator_concept_for<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>                     , <span class="kw">public</span> iterator_category_for<span class="op">&lt;</span>It<span class="op">&gt;</span></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="op">{</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>    It it;</span>
<span id="cb6-18"><a href="#cb6-18"></a></span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>    <span class="kw">using</span> value_type <span class="op">=</span> std<span class="op">::</span>iter_value_t<span class="op">&lt;</span>It<span class="op">&gt;</span>;</span>
<span id="cb6-21"><a href="#cb6-21"></a>    <span class="kw">using</span> difference_type <span class="op">=</span> std<span class="op">::</span>iter_difference_t<span class="op">&lt;</span>It<span class="op">&gt;</span>;</span>
<span id="cb6-22"><a href="#cb6-22"></a>    <span class="kw">using</span> reference <span class="op">=</span> const_ref_for<span class="op">&lt;</span>It<span class="op">&gt;</span>;</span>
<span id="cb6-23"><a href="#cb6-23"></a></span>
<span id="cb6-24"><a href="#cb6-24"></a>    const_iterator<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb6-25"><a href="#cb6-25"></a>    const_iterator<span class="op">(</span>It it<span class="op">)</span> <span class="op">:</span> it<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>it<span class="op">))</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb6-26"><a href="#cb6-26"></a></span>
<span id="cb6-27"><a href="#cb6-27"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">++()</span> <span class="op">-&gt;</span> const_iterator<span class="op">&amp;</span> <span class="op">{</span> <span class="op">++</span>it; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb6-28"><a href="#cb6-28"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="op">-&gt;</span> const_iterator <span class="kw">requires</span> std<span class="op">::</span>forward_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="kw">auto</span> cpy <span class="op">=</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">++*</span><span class="kw">this</span>; <span class="cf">return</span> cpy; <span class="op">}</span>        </span>
<span id="cb6-29"><a href="#cb6-29"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span> <span class="op">++*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb6-30"><a href="#cb6-30"></a></span>
<span id="cb6-31"><a href="#cb6-31"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">--()</span> <span class="op">-&gt;</span> const_iterator<span class="op">&amp;</span> <span class="kw">requires</span> std<span class="op">::</span>bidirectional_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="op">--</span>it; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb6-32"><a href="#cb6-32"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">--(</span><span class="dt">int</span><span class="op">)</span> <span class="op">-&gt;</span> const_iterator <span class="kw">requires</span> std<span class="op">::</span>bidirectional_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="kw">auto</span> cpy <span class="op">=</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">--*</span><span class="kw">this</span>; <span class="cf">return</span> cpy; <span class="op">}</span>        </span>
<span id="cb6-33"><a href="#cb6-33"></a></span>
<span id="cb6-34"><a href="#cb6-34"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+(</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span> n<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> const_iterator <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> const_iterator<span class="op">(</span>it <span class="op">+</span> n<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb6-35"><a href="#cb6-35"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-(</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span> n<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> const_iterator <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> const_iterator<span class="op">(</span>it <span class="op">-</span> n<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb6-36"><a href="#cb6-36"></a>    <span class="kw">friend</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+(</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span> n, const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">-&gt;</span> const_iterator <span class="op">{</span> <span class="cf">return</span> rhs <span class="op">+</span> n; <span class="op">}</span></span>
<span id="cb6-37"><a href="#cb6-37"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+=(</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span> n<span class="op">)</span> <span class="op">-&gt;</span> const_iterator<span class="op">&amp;</span> <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> it <span class="op">+=</span> n; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb6-38"><a href="#cb6-38"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-=(</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span> n<span class="op">)</span> <span class="op">-&gt;</span> const_iterator<span class="op">&amp;</span> <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> it <span class="op">-=</span> n; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span>        </span>
<span id="cb6-39"><a href="#cb6-39"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-(</span>const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> difference_type <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> it <span class="op">-</span> rhs<span class="op">.</span>it; <span class="op">}</span></span>
<span id="cb6-40"><a href="#cb6-40"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">[](</span>std<span class="op">::</span><span class="dt">ptrdiff_t</span> n<span class="op">)</span> <span class="kw">const</span> <span class="op">-&gt;</span> reference <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> it<span class="op">[</span>n<span class="op">]</span>; <span class="op">}</span></span>
<span id="cb6-41"><a href="#cb6-41"></a></span>
<span id="cb6-42"><a href="#cb6-42"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">*()</span> <span class="kw">const</span> <span class="op">-&gt;</span> reference <span class="op">{</span> <span class="cf">return</span> <span class="op">*</span>it; <span class="op">}</span></span>
<span id="cb6-43"><a href="#cb6-43"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="kw">const</span> <span class="op">-&gt;</span> value_type <span class="kw">const</span><span class="op">*</span> <span class="kw">requires</span> std<span class="op">::</span>contiguous_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> std<span class="op">::</span>to_address<span class="op">(</span>it<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb6-44"><a href="#cb6-44"></a></span>
<span id="cb6-45"><a href="#cb6-45"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">==(</span>const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span>  <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="kw">requires</span> std<span class="op">::</span>equality_comparable<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span>  <span class="cf">return</span> it <span class="op">==</span> rhs<span class="op">.</span>it; <span class="op">}</span></span>
<span id="cb6-46"><a href="#cb6-46"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>const_iterator <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">requires</span> std<span class="op">::</span>random_access_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> it <span class="op">&lt;=&gt;</span> rhs<span class="op">.</span>it; <span class="op">}</span></span>
<span id="cb6-47"><a href="#cb6-47"></a></span>
<span id="cb6-48"><a href="#cb6-48"></a>    <span class="kw">auto</span> base<span class="op">()</span> <span class="op">-&gt;</span> It<span class="op">&amp;</span> <span class="op">{</span> <span class="cf">return</span> it; <span class="op">}</span></span>
<span id="cb6-49"><a href="#cb6-49"></a>    <span class="kw">auto</span> base<span class="op">()</span> <span class="kw">const</span> <span class="op">-&gt;</span> It <span class="kw">const</span><span class="op">&amp;</span> <span class="op">{</span> <span class="cf">return</span> it; <span class="op">}</span></span>
<span id="cb6-50"><a href="#cb6-50"></a><span class="op">}</span>;</span></code></pre></div>
<h2 data-number="2.4" id="implementing-const_sentineli-s"><span class="header-section-number">2.4</span> Implementing <code class="sourceCode cpp">const_sentinel<span class="op">&lt;</span>I, S<span class="op">&gt;</span></code>?<a href="#implementing-const_sentineli-s" class="self-link"></a></h2>
<p>One of the changes in C++20 Ranges as compared to C++17 Ranges is the introduction of the Sentinel concept. A range is no longer a pair of two <code class="sourceCode cpp">iterator</code>s, it is an <code class="sourceCode cpp">iterator</code>/<code class="sourceCode cpp">sentinel</code> pair. The <code class="sourceCode cpp">sentinel</code> could be the same type as the <code class="sourceCode cpp">iterator</code>, such a range is known as a <code class="sourceCode cpp">common_range</code> but it need not be. We would need to handle producing a wrapped <code class="sourceCode cpp">sentinel</code> in addition to producing a wrapped <code class="sourceCode cpp">iterator</code>.</p>
<p>However, the question of what to do about sentinels is a bit more complicated than what to do about iterators, because we have to deal with convertability.</p>
<p>We have this expectation that a range’s mutable iterator is convertible to its constant iterator. That is, given any type <code class="sourceCode cpp">R</code> such <code class="sourceCode cpp">range<span class="op">&lt;</span>R<span class="op">&gt;</span></code> and <code class="sourceCode cpp">range<span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&gt;</span></code> both hold, that <code class="sourceCode cpp">iterator_t<span class="op">&lt;</span>R<span class="op">&gt;</span></code> is convertible to <code class="sourceCode cpp">iterator_t<span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&gt;</span></code>. For example, we expect <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;::</span>iterator</code> to be convertible to <code class="sourceCode cpp">vector<span class="op">&lt;</span>T<span class="op">&gt;::</span>const_iterator</code>, and likewise for any other container or view.</p>
<p>Adding the concept of a <code class="sourceCode cpp">const_iterator</code> further complicates matters because now we have the following cross-convertibility and cross-comparability graph:</p>
<p><img src="data:image/png;base64,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" alt="caption" /></p>
<p>A black arrow from <code class="sourceCode cpp">T</code> to <code class="sourceCode cpp">U</code> indicates that <code class="sourceCode cpp">T</code> needs to be convertible to <code class="sourceCode cpp">U</code>, while the blue bidirectional arrows between <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code> indicate that <code class="sourceCode cpp">equality_comparable_with<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code> holds (i.e. not only that the types can be compared with <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code> but also that there is a common type between them). That is, every pair of types here needs to model <code class="sourceCode cpp">equality_comparable_with</code>.</p>
<p>Even though <code class="sourceCode cpp">iterator_t<span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&gt;</span></code> and <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>iterator_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;</span></code> are not convertible to each other, they still have a <code class="sourceCode cpp">common_type</code>: <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>iterator_t<span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&gt;&gt;</span></code>.</p>
<p>The complexity of the above graph, and the need for all the cross-comparisons and cross-conversions anyway, suggests that there isn’t much point in having a <code class="sourceCode cpp">const_sentinel<span class="op">&lt;</span>I, S<span class="op">&gt;</span></code> type at best. At worst, it’s a complex interplay of types to get right. We need to ensure that <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span>const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span>, S<span class="op">&gt;</span></code> holds anyway, regardless of whether we pursue a <code class="sourceCode cpp">const_sentinel<span class="op">&lt;</span>I, S<span class="op">&gt;</span></code> type, so wrapping doesn’t really do much for us. Hopefully, we don’t find a problem that necessitates wrapping in the future (c.f. <span class="citation" data-cites="LWG3386">[<a href="#ref-LWG3386" role="doc-biblioref">LWG3386</a>]</span>).</p>
<p>As such, what we need for <code class="sourceCode cpp">make_const_sentinel</code> is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> S<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">constexpr</span> <span class="kw">auto</span> make_const_sentinel<span class="op">(</span>S s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>input_iterator<span class="op">&lt;</span>S<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>        <span class="co">// the sentinel here is an iterator in its own right, so we need to (possibly) wrap it the same way</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>        <span class="cf">return</span> make_const_iterator<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>s<span class="op">))</span>;</span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>        <span class="cf">return</span> s;</span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="op">}</span></span></code></pre></div>
<p>We could take the iterator type as a template parameter to enforce that <code class="sourceCode cpp">S</code> satisfies <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span>I<span class="op">&gt;</span></code>, but this function is only used as a building block of an algorithm that would already enforce this, so it’s probably not necessary.</p>
<p>But to make <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code> satisfy the graph illustrated above, we have to make several changes to what I showed in the previous section:</p>
<div>
<div class="sourceCode" id="cb8"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb8-1"><a href="#cb8-1"></a>  template &lt;std::input_iterator It&gt;</span>
<span id="cb8-2"><a href="#cb8-2"></a>  class const_iterator : public iterator_concept_for&lt;It&gt;</span>
<span id="cb8-3"><a href="#cb8-3"></a>                       , public iterator_category_for&lt;It&gt;</span>
<span id="cb8-4"><a href="#cb8-4"></a>  {</span>
<span id="cb8-5"><a href="#cb8-5"></a>      It it;</span>
<span id="cb8-6"><a href="#cb8-6"></a>  </span>
<span id="cb8-7"><a href="#cb8-7"></a>  public:</span>
<span id="cb8-8"><a href="#cb8-8"></a>      using value_type = std::iter_value_t&lt;It&gt;;</span>
<span id="cb8-9"><a href="#cb8-9"></a>      using difference_type = std::iter_difference_t&lt;It&gt;;</span>
<span id="cb8-10"><a href="#cb8-10"></a>      using reference = const_ref_for&lt;It&gt;;</span>
<span id="cb8-11"><a href="#cb8-11"></a>  </span>
<span id="cb8-12"><a href="#cb8-12"></a>      const_iterator() = default;</span>
<span id="cb8-13"><a href="#cb8-13"></a>      const_iterator(It it) : it(std::move(it)) { }</span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="va">+     template &lt;std::convertible_to&lt;It&gt; U&gt;</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="va">+     const_iterator(const_iterator&lt;U&gt; c) : it(std::move(c.base())) { }</span></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="va">+     const_iterator(std::convertible_to&lt;It&gt; auto&amp;&amp; c) : it(FWD(c)) { }</span></span>
<span id="cb8-17"><a href="#cb8-17"></a></span>
<span id="cb8-18"><a href="#cb8-18"></a>      // ...</span>
<span id="cb8-19"><a href="#cb8-19"></a>      </span>
<span id="cb8-20"><a href="#cb8-20"></a><span class="st">-     auto operator==(const_iterator const&amp; rhs) const  -&gt; bool requires std::equality_comparable&lt;It&gt; {  return it == rhs.it; }</span></span>
<span id="cb8-21"><a href="#cb8-21"></a><span class="st">-     auto operator&lt;=&gt;(const_iterator const&amp; rhs) const requires std::random_access_iterator&lt;It&gt; { return it &lt;=&gt; rhs.it; }    </span></span>
<span id="cb8-22"><a href="#cb8-22"></a><span class="va">+     template &lt;std::sentinel_for&lt;It&gt; S&gt;</span></span>
<span id="cb8-23"><a href="#cb8-23"></a><span class="va">+     auto operator==(S const&amp; s) const -&gt; bool {</span></span>
<span id="cb8-24"><a href="#cb8-24"></a><span class="va">+         return it == s;</span></span>
<span id="cb8-25"><a href="#cb8-25"></a><span class="va">+     }</span></span>
<span id="cb8-26"><a href="#cb8-26"></a><span class="va">+ </span></span>
<span id="cb8-27"><a href="#cb8-27"></a><span class="va">+     template &lt;std::sentinel_for&lt;It&gt; S&gt;</span></span>
<span id="cb8-28"><a href="#cb8-28"></a><span class="va">+         requires std::random_access_iterator&lt;It&gt; &amp;&amp; requires (It const&amp; it, S s) { it &lt;=&gt; s; }</span></span>
<span id="cb8-29"><a href="#cb8-29"></a><span class="va">+     auto operator&lt;=&gt;(S const&amp; s) const {</span></span>
<span id="cb8-30"><a href="#cb8-30"></a><span class="va">+         return it &lt;=&gt; s;</span></span>
<span id="cb8-31"><a href="#cb8-31"></a><span class="va">+     }</span></span>
<span id="cb8-32"><a href="#cb8-32"></a><span class="va">+ </span></span>
<span id="cb8-33"><a href="#cb8-33"></a><span class="va">+     template &lt;std::sized_sentinel_for&lt;It&gt; S&gt;</span></span>
<span id="cb8-34"><a href="#cb8-34"></a><span class="va">+     auto operator-(S const&amp; s) const -&gt; std::iter_difference_t&lt;It&gt; {</span></span>
<span id="cb8-35"><a href="#cb8-35"></a><span class="va">+         return it - s;</span></span>
<span id="cb8-36"><a href="#cb8-36"></a><span class="va">+     }</span></span>
<span id="cb8-37"><a href="#cb8-37"></a>  </span>
<span id="cb8-38"><a href="#cb8-38"></a>      auto base() -&gt; It&amp; { return it; }</span>
<span id="cb8-39"><a href="#cb8-39"></a>      auto base() const -&gt; It const&amp; { return it; }</span>
<span id="cb8-40"><a href="#cb8-40"></a>  };</span>
<span id="cb8-41"><a href="#cb8-41"></a>  </span>
<span id="cb8-42"><a href="#cb8-42"></a><span class="va">+ template &lt;std::input_iterator It, std::sized_sentinel_for&lt;It&gt; S&gt;</span></span>
<span id="cb8-43"><a href="#cb8-43"></a><span class="va">+ auto operator-(S const&amp; s, const_iterator&lt;It&gt; const&amp; rhs) -&gt; std::iter_difference_t&lt;It&gt; {</span></span>
<span id="cb8-44"><a href="#cb8-44"></a><span class="va">+     return s - rhs.it;</span></span>
<span id="cb8-45"><a href="#cb8-45"></a><span class="va">+ }</span></span>
<span id="cb8-46"><a href="#cb8-46"></a><span class="va">+ </span></span>
<span id="cb8-47"><a href="#cb8-47"></a><span class="va">+ template &lt;typename T, std::common_with&lt;T&gt; U&gt;</span></span>
<span id="cb8-48"><a href="#cb8-48"></a><span class="va">+ struct std::common_type&lt;const_iterator&lt;T&gt;, U&gt; {</span></span>
<span id="cb8-49"><a href="#cb8-49"></a><span class="va">+     using type = const_iterator&lt;std::common_type_t&lt;T, U&gt;&gt;;</span></span>
<span id="cb8-50"><a href="#cb8-50"></a><span class="va">+ };</span></span>
<span id="cb8-51"><a href="#cb8-51"></a><span class="va">+ template &lt;typename T, std::common_with&lt;T&gt; U&gt;</span></span>
<span id="cb8-52"><a href="#cb8-52"></a><span class="va">+ struct std::common_type&lt;U, const_iterator&lt;T&gt;&gt; {</span></span>
<span id="cb8-53"><a href="#cb8-53"></a><span class="va">+     using type = const_iterator&lt;std::common_type_t&lt;T, U&gt;&gt;;</span></span>
<span id="cb8-54"><a href="#cb8-54"></a><span class="va">+ };</span></span>
<span id="cb8-55"><a href="#cb8-55"></a><span class="va">+ template &lt;typename T, std::common_with&lt;T&gt; U&gt;</span></span>
<span id="cb8-56"><a href="#cb8-56"></a><span class="va">+ struct std::common_type&lt;const_iterator&lt;T&gt;, const_iterator&lt;U&gt;&gt; {</span></span>
<span id="cb8-57"><a href="#cb8-57"></a><span class="va">+     using type = const_iterator&lt;std::common_type_t&lt;T, U&gt;&gt;;</span></span>
<span id="cb8-58"><a href="#cb8-58"></a><span class="va">+ };      </span></span></code></pre></div>
</div>
<p>The added converting constructors satisfy the conversion rules, the extended comparisons cover the other types we need to compare against, the <code class="sourceCode cpp">common_type</code> specializations cover the cases where we might not be convertible in either direction but still need to have a common type. The remainder, the two <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">-()</span></code> overloads are to handle the <code class="sourceCode cpp">sized_sentinel_for</code> cases.</p>
<p>With all of that, we have a <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>I<span class="op">&gt;</span></code> that satisfies the intricate web of comparisons, conversions, and common types that we would expect for constant iterators.</p>
<h2 data-number="2.5" id="better-algorithms-for-stdrangescbegin-and-stdrangesend"><span class="header-section-number">2.5</span> Better Algorithms for <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>end</code><a href="#better-algorithms-for-stdrangescbegin-and-stdrangesend" class="self-link"></a></h2>
<p><code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> today (<span>24.3.4
 <a href="https://wg21.link/range.access.cbegin">[range.access.cbegin]</a></span>), similar <code class="sourceCode cpp">std<span class="op">::</span>begin</code>, unconditionally calls <code class="sourceCode cpp">ranges<span class="op">::</span>begin</code>. While <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>E<span class="op">)</span></code> does conditionally call <code class="sourceCode cpp">E<span class="op">.</span>rbegin<span class="op">()</span></code>, I wonder to what extent this facility actually needs to be customizeable. The goal is to provide a constant iterator version of <code class="sourceCode cpp">begin<span class="op">()</span></code>.</p>
<p>With the above pieces, we can do precisely that (see full implementation <span class="citation" data-cites="const-impl">[<a href="#ref-const-impl" role="doc-biblioref">const-impl</a>]</span>, complete with many tests):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="kw">auto</span> possibly_const <span class="op">=</span> <span class="op">[]&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>range R<span class="op">&gt;(</span>R<span class="op">&amp;</span> r<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>range<span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&gt;</span> <span class="kw">and</span> <span class="kw">not</span> std<span class="op">::</span>ranges<span class="op">::</span>view<span class="op">&lt;</span>std<span class="op">::</span>remove_const_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;)</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>        <span class="cf">return</span> <span class="kw">const_cast</span><span class="op">&lt;</span>R <span class="kw">const</span><span class="op">&amp;&gt;(</span>r<span class="op">)</span>;</span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>        <span class="cf">return</span> r;</span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="op">}</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="op">}</span>;</span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="kw">auto</span> cbegin <span class="op">=</span> first_of<span class="op">(</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>    <span class="co">// 1. non-borrowed rvalue</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>    delete_if_nonborrowed_rvalue,</span>
<span id="cb9-12"><a href="#cb9-12"></a>    <span class="co">// 2. possibly-wrapped begin of possibly-const r</span></span>
<span id="cb9-13"><a href="#cb9-13"></a>    <span class="op">[](</span>std<span class="op">::</span>ranges<span class="op">::</span>range <span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">)</span> </span>
<span id="cb9-14"><a href="#cb9-14"></a>        RETURNS<span class="op">(</span>make_const_iterator<span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>begin<span class="op">(</span>possibly_const<span class="op">(</span>r<span class="op">))))</span></span>
<span id="cb9-15"><a href="#cb9-15"></a><span class="op">)</span>;</span>
<span id="cb9-16"><a href="#cb9-16"></a></span>
<span id="cb9-17"><a href="#cb9-17"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="kw">auto</span> cend <span class="op">=</span> first_of<span class="op">(</span></span>
<span id="cb9-18"><a href="#cb9-18"></a>    <span class="co">// 1. non-borrowed rvalue</span></span>
<span id="cb9-19"><a href="#cb9-19"></a>    delete_if_nonborrowed_rvalue,</span>
<span id="cb9-20"><a href="#cb9-20"></a>    <span class="co">// 2. possibly-wrapped end of possibly-const r</span></span>
<span id="cb9-21"><a href="#cb9-21"></a>    <span class="op">[](</span>std<span class="op">::</span>ranges<span class="op">::</span>range <span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">)</span> </span>
<span id="cb9-22"><a href="#cb9-22"></a>        RETURNS<span class="op">(</span>make_const_sentinel<span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>end<span class="op">(</span>possibly_const<span class="op">(</span>r<span class="op">))))</span></span>
<span id="cb9-23"><a href="#cb9-23"></a><span class="op">)</span>;</span></code></pre></div>
<p>Here, <code class="sourceCode cpp">cbegin<span class="op">(</span>r<span class="op">)</span></code> and <code class="sourceCode cpp">cend<span class="op">(</span>r<span class="op">)</span></code> produce a range that is top-level const over any underlying range, without having to modify any of those underlying ranges to opt in to this behavior. This works for <code class="sourceCode cpp">std<span class="op">::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code> and <code class="sourceCode cpp">std<span class="op">::</span>span<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code> and <code class="sourceCode cpp">boost<span class="op">::</span>iterator_range<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;</span></code> and even views like <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>filter_view</code> (<code class="sourceCode cpp">possibly_const</code> ensures that if get passed a non-<code class="sourceCode cpp"><span class="kw">const</span></code> <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code>, we treat it as <code class="sourceCode cpp"><span class="kw">const</span></code> first — which is both valid and necessary — while <code class="sourceCode cpp">filter_view <span class="kw">const</span></code> isn’t a <code class="sourceCode cpp">range</code> so we cannot treat it as <code class="sourceCode cpp"><span class="kw">const</span></code> first).</p>
<p>In addition to simply working across all ranges, it has a few other features worth noting:</p>
<ul>
<li>For a <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v</code>, <code class="sourceCode cpp">cbegin<span class="op">(</span>v<span class="op">)</span></code> gives precisely the type <code class="sourceCode cpp">vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>const_iterator</code> (not <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>iterator<span class="op">&gt;</span></code>).</li>
<li>For a <code class="sourceCode cpp">span<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> s</code>, <code class="sourceCode cpp">cbegin<span class="op">(</span>s<span class="op">)</span></code> provides a contiguous iterator over <code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span></code>, not just any kind of iterator.</li>
</ul>
<p>Note that here, <code class="sourceCode cpp">ranges<span class="op">::</span>end</code> already checks that the type returned is a <code class="sourceCode cpp">sentinel</code> for the type returned by <code class="sourceCode cpp">ranges<span class="op">::</span>begin</code>. Given that fact, the implementation here already ensures that <code class="sourceCode cpp">sentinel_for<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>cbegin<span class="op">(</span>r<span class="op">))</span>, <span class="kw">decltype</span><span class="op">(</span>cend<span class="op">(</span>r<span class="op">))&gt;</span></code> holds.</p>
<h2 data-number="2.6" id="a-viewsconst_"><span class="header-section-number">2.6</span> A <code class="sourceCode cpp">views<span class="op">::</span>const_</code><a href="#a-viewsconst_" class="self-link"></a></h2>
<p>A whole const-view can be implemented on top of these pieces, in the same way that <code class="sourceCode cpp">views<span class="op">::</span>reverse</code> is implemented on top of <code class="sourceCode cpp">reverse_iterator</code> (see the full implementation <span class="citation" data-cites="const-impl">[<a href="#ref-const-impl" role="doc-biblioref">const-impl</a>]</span>):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">template</span> <span class="op">&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>input_range V<span class="op">&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>view<span class="op">&lt;</span>V<span class="op">&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">class</span> const_view <span class="op">:</span> <span class="kw">public</span> std<span class="op">::</span>ranges<span class="op">::</span>view_interface<span class="op">&lt;</span>const_view<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>    V base <span class="op">=</span> V<span class="op">()</span>;</span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="kw">constexpr</span> const_view<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span>;</span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="kw">constexpr</span> const_view<span class="op">(</span>V base<span class="op">)</span> <span class="op">:</span> base<span class="op">(</span>std<span class="op">::</span>move<span class="op">(</span>base<span class="op">))</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> begin<span class="op">()</span> <span class="kw">requires</span> <span class="op">(!</span><em>simple-view</em><span class="op">&lt;</span>V<span class="op">&gt;)</span> <span class="op">{</span> <span class="cf">return</span> cbegin<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> end<span class="op">()</span> <span class="kw">requires</span> <span class="op">(!</span><em>simple-view</em><span class="op">&lt;</span>V<span class="op">&gt;)</span> <span class="op">{</span> <span class="cf">return</span> cend<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> size<span class="op">()</span> <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>sized_range<span class="op">&lt;</span>V<span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> std<span class="op">::</span>ranges<span class="op">::</span>size<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12"></a></span>
<span id="cb10-13"><a href="#cb10-13"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> begin<span class="op">()</span> <span class="kw">const</span> <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>range<span class="op">&lt;</span>V <span class="kw">const</span><span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> cbegin<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> end<span class="op">()</span> <span class="kw">const</span> <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>range<span class="op">&lt;</span>V <span class="kw">const</span><span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> cend<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb10-15"><a href="#cb10-15"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> size<span class="op">()</span> <span class="kw">const</span> <span class="kw">requires</span> std<span class="op">::</span>ranges<span class="op">::</span>sized_range<span class="op">&lt;</span>V <span class="kw">const</span><span class="op">&gt;</span> <span class="op">{</span> <span class="cf">return</span> std<span class="op">::</span>ranges<span class="op">::</span>size<span class="op">(</span>base<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="op">}</span>;</span>
<span id="cb10-17"><a href="#cb10-17"></a></span>
<span id="cb10-18"><a href="#cb10-18"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> V<span class="op">&gt;</span></span>
<span id="cb10-19"><a href="#cb10-19"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="op">::</span>std<span class="op">::</span>ranges<span class="op">::</span>enable_borrowed_range<span class="op">&lt;</span>const_view<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span> <span class="op">=</span></span>
<span id="cb10-20"><a href="#cb10-20"></a>    std<span class="op">::</span>ranges<span class="op">::</span>enable_borrowed_range<span class="op">&lt;</span>V<span class="op">&gt;</span>;</span>
<span id="cb10-21"><a href="#cb10-21"></a></span>
<span id="cb10-22"><a href="#cb10-22"></a><span class="co">// libstdc++ specific (hopefully standard version coming soon!)</span></span>
<span id="cb10-23"><a href="#cb10-23"></a><span class="kw">inline</span> <span class="kw">constexpr</span> std<span class="op">::</span>views<span class="op">::</span>__adaptor<span class="op">::</span>_RangeAdaptorClosure const_ <span class="op">=</span></span>
<span id="cb10-24"><a href="#cb10-24"></a>    <span class="op">[]&lt;</span>std<span class="op">::</span>ranges<span class="op">::</span>viewable_range R<span class="op">&gt;(</span>R<span class="op">&amp;&amp;</span> r<span class="op">)</span></span>
<span id="cb10-25"><a href="#cb10-25"></a>    <span class="op">{</span></span>
<span id="cb10-26"><a href="#cb10-26"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><em>constant-range</em><span class="op">&lt;</span>R<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb10-27"><a href="#cb10-27"></a>            <span class="cf">return</span> std<span class="op">::</span>views<span class="op">::</span>all<span class="op">(</span>r<span class="op">)</span>;</span>
<span id="cb10-28"><a href="#cb10-28"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><em>constant-range</em><span class="op">&lt;</span>std<span class="op">::</span>remove_reference_t<span class="op">&lt;</span>R<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb10-29"><a href="#cb10-29"></a>            <span class="cf">return</span> std<span class="op">::</span>views<span class="op">::</span>all<span class="op">(</span>std<span class="op">::</span>as_const<span class="op">(</span>r<span class="op">))</span>;</span>
<span id="cb10-30"><a href="#cb10-30"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>            <span class="cf">return</span> const_view<span class="op">&lt;</span>std<span class="op">::</span>views<span class="op">::</span>all_t<span class="op">&lt;</span>R<span class="op">&gt;&gt;(</span>std<span class="op">::</span>views<span class="op">::</span>all<span class="op">(</span>r<span class="op">))</span>;</span>
<span id="cb10-32"><a href="#cb10-32"></a>        <span class="op">}</span></span>
<span id="cb10-33"><a href="#cb10-33"></a>    <span class="op">}</span>;</span></code></pre></div>
<p>The four cases here are:</p>
<ol type="1">
<li><code class="sourceCode cpp">r</code> is already a constant range, no need to do anything, pass it through. Examples are <code class="sourceCode cpp">std<span class="op">::</span>span<span class="op">&lt;</span>T <span class="kw">const</span><span class="op">&gt;</span></code> or <code class="sourceCode cpp">std<span class="op">::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">const</span></code> or <code class="sourceCode cpp">std<span class="op">::</span>set<span class="op">&lt;</span>T<span class="op">&gt;</span></code>.</li>
<li><code class="sourceCode cpp">r</code> is not a constant range but <code class="sourceCode cpp">std<span class="op">::</span>as_const<span class="op">(</span>r<span class="op">)</span></code> would be. Rather than do any wrapping ourselves, we defer to <code class="sourceCode cpp">std<span class="op">::</span>as_const</code>. Example is <code class="sourceCode cpp">std<span class="op">::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span></code>.</li>
<li><code class="sourceCode cpp">r</code> is neither a constant range nor can easily be made one, so we have to wrap ourselves. Examples are basically any mutable view.</li>
</ol>
<p>To me, being able to provide a <code class="sourceCode cpp">views<span class="op">::</span>const_</code> is the ultimate solution for this problem, since it’s the one that guarantees correctness even in the presence of a range-based for statement:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="kw">const</span><span class="op">&amp;</span> e <span class="op">:</span> r <span class="op">|</span> views<span class="op">::</span>const_<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<p>Or passing a constant range to an algorithm:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a>dont_touch_me<span class="op">(</span>views<span class="op">::</span>const_<span class="op">(</span>r<span class="op">))</span>;</span></code></pre></div>
<p>As far as naming goes, obviously we can’t just call it <code class="sourceCode cpp">views<span class="op">::</span><span class="kw">const</span></code>. range-v3 calls it <code class="sourceCode cpp">const_</code>, but there’s a few other good name options here like <code class="sourceCode cpp">views<span class="op">::</span>as_const</code> or <code class="sourceCode cpp">views<span class="op">::</span>to_const</code>.</p>
<h2 data-number="2.7" id="what-about-stdcbegin-and-stdcend"><span class="header-section-number">2.7</span> What About <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code>?<a href="#what-about-stdcbegin-and-stdcend" class="self-link"></a></h2>
<p>The above presents an implementation strategy for <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cend</code>.</p>
<p>But what about <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code>? The problem is, while the former is C++20 technology and so can make use of the C++20 iterator model, <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> is C++11 technology and so has to remain fixed with the C++11 iterator model. The biggest difference for these purposes has to do with input iterators.</p>
<p>In C++11, even for an input iterator, this is valid code:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">auto</span> val <span class="op">=</span> <span class="op">*</span>it<span class="op">++</span>;</span></code></pre></div>
<p>But in C++20, an input iterator’s postfix increment operator need not return a copy of itself. All the ones in the standard library return <code class="sourceCode cpp"><span class="dt">void</span></code>. This is the safer design, since any use of postfix increment that isn’t either ignoring the result or exactly the above expression are simply wrong for input iterators.</p>
<p>Trying to be backwards compatible with pre-C++20 iterators is quite hard (again, see <span class="citation" data-cites="P2259R0">[<a href="#ref-P2259R0" role="doc-biblioref">P2259R0</a>]</span>), and the <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> implementation provided in this paper would <em>not</em> be a valid C++17 input iterator. Additionally, C++20 input iterators are required to be default constructible while C++17 input iterators were not.</p>
<p>On the other hand, is it critically important to have a constant iterator for a C++17 input iterator? You’re not going to mutate anything meaningful anyway.</p>
<p>A simple solution could have <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>c<span class="op">)</span></code> pass through C++17 input iterators unconditionally, and otherwise do <code class="sourceCode cpp">make_const_iterator<span class="op">(</span>as_const<span class="op">(</span>c<span class="op">).</span>begin<span class="op">())</span></code> (i.e. the <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> described above) for all iterators that are either C++20 iterators or C++17 forward iterators. This probably addresses the majority of the use-cases with minimal fuss.</p>
<p>Moreover, would we want to extend <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> to also handle non-<code class="sourceCode cpp"><span class="kw">const</span></code>-iterable ranges? This is technically doable:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> C<span class="op">&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">concept</span> can_begin <span class="op">=</span> <span class="kw">requires</span> <span class="op">(</span>C<span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span> std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb14-3"><a href="#cb14-3"></a></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="kw">requires</span> can_begin<span class="op">&lt;</span><span class="kw">const</span> C<span class="op">&gt;</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="kw">constexpr</span> <span class="kw">auto</span> cbegin<span class="op">(</span><span class="kw">const</span> C<span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span class="co">// today&#39;s overload, but also conditionally wrap</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="op">}</span></span>
<span id="cb14-9"><a href="#cb14-9"></a></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>    <span class="kw">requires</span> <span class="op">(</span>can_begin<span class="op">&lt;</span>C<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>can_begin<span class="op">&lt;</span><span class="kw">const</span> C<span class="op">&gt;)</span></span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="kw">constexpr</span> <span class="kw">auto</span> cbegin<span class="op">(</span>C<span class="op">&amp;</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-13"><a href="#cb14-13"></a>    <span class="co">// fallback for non-const-iterable ranges</span></span>
<span id="cb14-14"><a href="#cb14-14"></a><span class="op">}</span></span></code></pre></div>
<p>I negated the constraint to prefer the <code class="sourceCode cpp"><span class="kw">const</span> C<span class="op">&amp;</span></code> overload even for non-const arguments.</p>
<p>But we didn’t introduce a C++20 iteration model to then go back and give us more work to keep two models in lock-step. The C++20 one on its own is hard enough, and is a better model. We should just commit to it.</p>
<p>It’d probably just be good enough to do something like:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">constexpr</span> <span class="kw">auto</span> cbegin<span class="op">(</span>C <span class="kw">const</span><span class="op">&amp;</span> c<span class="op">)</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>    <span class="kw">requires</span> <span class="kw">requires</span> <span class="op">{</span> std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="op">{</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>    <span class="cf">if</span> consetxpr <span class="op">(</span>std<span class="op">::</span>forward_iterator<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">))&gt;)</span> <span class="op">{</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>        <span class="cf">return</span> make_const_iterator<span class="op">(</span>std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">))</span>;</span>
<span id="cb15-7"><a href="#cb15-7"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb15-8"><a href="#cb15-8"></a>        <span class="co">// leave input iterators (or... whatever) alone</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>        <span class="cf">return</span> std<span class="op">::</span>begin<span class="op">(</span>c<span class="op">)</span>;</span>
<span id="cb15-10"><a href="#cb15-10"></a>    <span class="op">}</span></span>
<span id="cb15-11"><a href="#cb15-11"></a><span class="op">}</span></span></code></pre></div>
<p>And similarly for <code class="sourceCode cpp">std<span class="op">::</span>cend</code>. This isn’t entirely without peril: currently we say nothing about the constraints for <code class="sourceCode cpp">std<span class="op">::</span>cbegin<span class="op">(</span>r<span class="op">)</span></code>; just that it calls <code class="sourceCode cpp">r<span class="op">.</span>begin<span class="op">()</span></code>, <em>whatever that is</em>. There isn’t a requirement that this ends up giving an iterator and there’s no requirement that any of the operations that <code class="sourceCode cpp">std<span class="op">::</span>forward_iterator</code> would check are SFINAE-friendly. I don’t know if we necessarily care about such (mis)uses of <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code>, but it is worth nothing.</p>
<h2 data-number="2.8" id="now-reverse-it"><span class="header-section-number">2.8</span> Now Reverse It<a href="#now-reverse-it" class="self-link"></a></h2>
<p>Now that we can produce a constant iterator for a range, producing a reversed constant iterator is a matter of composing operations. We don’t have to worry about sentinels in this case:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="kw">auto</span> crbegin <span class="op">=</span> first_of<span class="op">(</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>    <span class="co">// 1. non-borrowed rvalue</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>    delete_if_nonborrowed_rvalue,</span>
<span id="cb16-4"><a href="#cb16-4"></a>    <span class="co">// 2. possibly-wrapped reversed begin of possibly-const range</span></span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="op">[](</span>std<span class="op">::</span>ranges<span class="op">::</span>range <span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">)</span> RETURNS<span class="op">(</span>make_const_iterator<span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>rbegin<span class="op">(</span>possibly_const<span class="op">(</span>r<span class="op">))))</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="op">)</span>;</span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="kw">inline</span> <span class="kw">constexpr</span> <span class="kw">auto</span> crend <span class="op">=</span> first_of<span class="op">(</span></span>
<span id="cb16-9"><a href="#cb16-9"></a>    <span class="co">// 1. non-borrowed rvalue</span></span>
<span id="cb16-10"><a href="#cb16-10"></a>    delete_if_nonborrowed_rvalue,</span>
<span id="cb16-11"><a href="#cb16-11"></a>    <span class="co">// 2. possibly-wrapped reversed end of possibly-const range</span></span>
<span id="cb16-12"><a href="#cb16-12"></a>    <span class="op">[](</span>std<span class="op">::</span>ranges<span class="op">::</span>range <span class="kw">auto</span><span class="op">&amp;&amp;</span> r<span class="op">)</span> RETURNS<span class="op">(</span>make_const_iterator<span class="op">(</span>std<span class="op">::</span>ranges<span class="op">::</span>rend<span class="op">(</span>possibly_const<span class="op">(</span>r<span class="op">))))</span></span>
<span id="cb16-13"><a href="#cb16-13"></a><span class="op">)</span>;</span></code></pre></div>
<p>Notably here, <code class="sourceCode cpp">ranges<span class="op">::</span>rbegin</code> and <code class="sourceCode cpp">ranges<span class="op">::</span>rend</code> already themselves will try to produce a <code class="sourceCode cpp">std<span class="op">::</span>reverse_iterator</code> if the underlying range is bidirectional. Similarly, we’re ourselves trying to produce a <code class="sourceCode cpp">std<span class="op">::</span>const_iterator</code>.</p>
<p>The extension to <code class="sourceCode cpp">std<span class="op">::</span>crbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>crend</code> mirrors the similar extension to <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">constexpr</span> <span class="kw">auto</span> crbegin<span class="op">(</span>C <span class="kw">const</span><span class="op">&amp;</span> c<span class="op">)</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="kw">requires</span> <span class="kw">requires</span> <span class="op">{</span> std<span class="op">::</span>rbegin<span class="op">(</span>c<span class="op">)</span>; <span class="op">}</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="op">{</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="cf">if</span> consetxpr <span class="op">(</span>std<span class="op">::</span>forward_iterator<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>std<span class="op">::</span>rbegin<span class="op">(</span>c<span class="op">))&gt;)</span> <span class="op">{</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>        <span class="cf">return</span> make_const_iterator<span class="op">(</span>std<span class="op">::</span>rbegin<span class="op">(</span>c<span class="op">))</span>;</span>
<span id="cb17-7"><a href="#cb17-7"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>        <span class="co">// leave input iterators (or... whatever) alone</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>        <span class="cf">return</span> std<span class="op">::</span>rbegin<span class="op">(</span>c<span class="op">)</span>;</span>
<span id="cb17-10"><a href="#cb17-10"></a>    <span class="op">}</span></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="op">}</span></span></code></pre></div>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="act-v-a-concluding-proposal"><span class="header-section-number">3</span> Act V: A Concluding Proposal<a href="#act-v-a-concluding-proposal" class="self-link"></a></h1>
<p>The status quo is that we have an algorithm named <code class="sourceCode cpp">cbegin</code> whose job is to provide a constant iterator, but it does not always do that, and sometimes it doesn’t even provide a mutable iterator. This is an unfortunate situation.</p>
<p>We can resolve this by extending <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cend</code> to conditionally wrap their provided range’s <code class="sourceCode cpp">iterator</code>/<code class="sourceCode cpp">sentinel</code> pairs to ensure that the result is a constant iterator, and use these tools to build up a <code class="sourceCode cpp">views<span class="op">::</span>const_</code> range adapter. This completely solves the problem without any imposed boilerplate per range.</p>
<p>However, <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>cend</code> are harder to extend. If we changed them at all, we would probably punt on handling C++17 input iterators and non-<code class="sourceCode cpp"><span class="kw">const</span></code>-iterable ranges. This means that <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> do different things, but <code class="sourceCode cpp">std<span class="op">::</span>rbegin</code> and <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin</code> <em>already</em> do different things. <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>rbegin</code> is already a superior <code class="sourceCode cpp">std<span class="op">::</span>rbegin</code>, so having <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> be a superior <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> only follows from that. In other words, <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code> is constrained to not deviate too much from its current behavior, whereas <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>cbegin</code> is new and Can Do Better.</p>
<p>Would it be worth making such a change to <code class="sourceCode cpp">std<span class="op">::</span>cbegin</code>?</p>
<p>Ultimately, the question is where in the Ranges Plan for C++23 <span class="citation" data-cites="P2214R0">[<a href="#ref-P2214R0" role="doc-biblioref">P2214R0</a>]</span> such an improvement would fit in? That paper is focused exclusively on providing a large amount of new functionality to users. The facility proposed in this paper, while an improvement over the status quo, does not seem more important than any of that paper. I just want us to keep that in mind - I do not consider this problem in the top tier of ranges-related problems that need solving.</p>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="epilogue"><span class="header-section-number">4</span> Epilogue<a href="#epilogue" class="self-link"></a></h1>
<p>Thanks to Tim Song for helping me work through the design and implementation details of this paper. Thanks to Peter Dimov and Tomasz Kamiński for insisting on design sanity (even as they insisted on different designs) and providing feedback. Thanks to Eric Niebler for having already solved the problem of how to come up with the right reference type for a <code class="sourceCode cpp">const_iterator<span class="op">&lt;</span>It<span class="op">&gt;</span></code> in range-v3.</p>
<h1 data-number="5" style="border-bottom:1px solid #cccccc" id="bibliography"><span class="header-section-number">5</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-const-impl">
<p>[const-impl] Barry Revzin. 2020. Implementing <code class="sourceCode cpp">cbegin</code>, <code class="sourceCode cpp">cend</code>, and <code class="sourceCode cpp">const_view</code>. <br />
<a href="https://godbolt.org/z/YnYsfK">https://godbolt.org/z/YnYsfK</a></p>
</div>
<div id="ref-LWG2128">
<p>[LWG2128] Dmitry Polukhin. Absence of global functions cbegin/cend. <br />
<a href="https://wg21.link/lwg2128">https://wg21.link/lwg2128</a></p>
</div>
<div id="ref-LWG3320">
<p>[LWG3320] Poland. span::cbegin/cend methods produce different results than std::[ranges::]cbegin/cend. <br />
<a href="https://wg21.link/lwg3320">https://wg21.link/lwg3320</a></p>
</div>
<div id="ref-LWG3386">
<p>[LWG3386] Tim Song. elements_view needs its own sentinel type. <br />
<a href="https://wg21.link/lwg3386">https://wg21.link/lwg3386</a></p>
</div>
<div id="ref-N1674">
<p>[N1674] Walter E. Brown. 2004-08-31. A Proposal to Improve const_iterator Use from C++0X Containers. <br />
<a href="https://wg21.link/n1674">https://wg21.link/n1674</a></p>
</div>
<div id="ref-N1913">
<p>[N1913] Walter E. Brown. 2005-10-20. A Proposal to Improve const_iterator Use (version 3). <br />
<a href="https://wg21.link/n1913">https://wg21.link/n1913</a></p>
</div>
<div id="ref-N4380">
<p>[N4380] ADAM David Alan Martin, Alisdair Meredith. 2015-02-05. Constant View: A proposal for a std::as_const helper function template. <br />
<a href="https://wg21.link/n4380">https://wg21.link/n4380</a></p>
</div>
<div id="ref-P0122R7">
<p>[P0122R7] Neil MacIntosh, Stephan T. Lavavej. 2018-03-16. span: bounds-safe views for sequences of objects. <br />
<a href="https://wg21.link/p0122r7">https://wg21.link/p0122r7</a></p>
</div>
<div id="ref-P0896R4">
<p>[P0896R4] Eric Niebler, Casey Carter, Christopher Di Bella. 2018-11-09. The One Ranges Proposal. <br />
<a href="https://wg21.link/p0896r4">https://wg21.link/p0896r4</a></p>
</div>
<div id="ref-P1035R7">
<p>[P1035R7] Christopher Di Bella, Casey Carter, Corentin Jabot. 2019-08-02. Input Range Adaptors. <br />
<a href="https://wg21.link/p1035r7">https://wg21.link/p1035r7</a></p>
</div>
<div id="ref-P1255R6">
<p>[P1255R6] Steve Downey. 2020-04-05. A view of 0 or 1 elements: views::maybe. <br />
<a href="https://wg21.link/p1255r6">https://wg21.link/p1255r6</a></p>
</div>
<div id="ref-P2210R0">
<p>[P2210R0] Barry Revzin. 2020-08-14. Superior String Splitting. <br />
<a href="https://wg21.link/p2210r0">https://wg21.link/p2210r0</a></p>
</div>
<div id="ref-P2214R0">
<p>[P2214R0] Barry Revzin, Conor Hoekstra, Tim Song. 2020-10-15. A Plan for C++23 Ranges. <br />
<a href="https://wg21.link/p2214r0">https://wg21.link/p2214r0</a></p>
</div>
<div id="ref-P2259R0">
<p>[P2259R0] Tim Song. 2020-11-20. Repairing input range adaptors and counted_iterator. <br />
<a href="https://wg21.link/p2259r0">https://wg21.link/p2259r0</a></p>
</div>
</div>
</div>
</div>
</body>
</html>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2020-05-03" />
  <title>Deducing this</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Deducing this</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>D0847R5</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2020-05-03</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      EWG =&gt; CWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Gašper Ažman<br>&lt;<a href="mailto:gasper.azman@gmail.com" class="email">gasper.azman@gmail.com</a>&gt;<br>
      Simon Brand<br>&lt;<a href="mailto:simon.brand@microsoft.com" class="email">simon.brand@microsoft.com</a>&gt;<br>
      Ben Deane, ben at elbeno dot com<br>&lt;<a href="mailto:ben@elbeno.com" class="email">ben@elbeno.com</a>&gt;<br>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#abstract"><span class="toc-section-number">1</span> Abstract<span></span></a></li>
<li><a href="#revision-history"><span class="toc-section-number">2</span> Revision History<span></span></a>
<ul>
<li><a href="#changes-since-r3"><span class="toc-section-number">2.1</span> Changes since r3<span></span></a></li>
<li><a href="#changes-since-r2"><span class="toc-section-number">2.2</span> Changes since r2<span></span></a></li>
<li><a href="#changes-since-r1"><span class="toc-section-number">2.3</span> Changes since r1<span></span></a></li>
<li><a href="#changes-since-r0"><span class="toc-section-number">2.4</span> Changes since r0<span></span></a></li>
</ul></li>
<li><a href="#motivation"><span class="toc-section-number">3</span> Motivation<span></span></a></li>
<li><a href="#proposal"><span class="toc-section-number">4</span> Proposal<span></span></a>
<ul>
<li><a href="#proposed-syntax"><span class="toc-section-number">4.1</span> Proposed Syntax<span></span></a></li>
<li><a href="#proposed-semantics"><span class="toc-section-number">4.2</span> Proposed semantics<span></span></a></li>
</ul></li>
<li><a href="#real-world-examples"><span class="toc-section-number">5</span> Real-World Examples<span></span></a>
<ul>
<li><a href="#deduplicating-code"><span class="toc-section-number">5.1</span> Deduplicating Code<span></span></a></li>
<li><a href="#crtp"><span class="toc-section-number">5.2</span> CRTP, without the C, R, or even T<span></span></a></li>
<li><a href="#recursive-lambdas"><span class="toc-section-number">5.3</span> Recursive Lambdas<span></span></a></li>
<li><a href="#by-value-member-functions"><span class="toc-section-number">5.4</span> By-value member functions<span></span></a></li>
<li><a href="#sfinae-friendly-callables"><span class="toc-section-number">5.5</span> SFINAE-friendly callables<span></span></a></li>
</ul></li>
<li><a href="#faq"><span class="toc-section-number">6</span> Frequently Asked Questions<span></span></a>
<ul>
<li><a href="#faq-rec-lambda-impl"><span class="toc-section-number">6.1</span> On the implementability of recursive lambdas<span></span></a></li>
<li><a href="#faq-demand"><span class="toc-section-number">6.2</span> Would library implementers use this<span></span></a></li>
<li><a href="#faq-function-ptr-type"><span class="toc-section-number">6.3</span> Function Pointer Types<span></span></a></li>
<li><a href="#faq-computed-deduction"><span class="toc-section-number">6.4</span> Deducing to Base-Class Pointer<span></span></a></li>
</ul></li>
<li><a href="#wording"><span class="toc-section-number">7</span> Proposed Wording<span></span></a>
<ul>
<li><a href="#feature-test-macro-tabcpp.predefined.ft"><span class="toc-section-number">7.1</span> Feature-test macro [tab:cpp.predefined.ft]<span></span></a></li>
</ul></li>
<li><a href="#acknowledgements"><span class="toc-section-number">8</span> Acknowledgements<span></span></a></li>
<li><a href="#bibliography"><span class="toc-section-number">9</span> References<span></span></a></li>
</ul>
</div>
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="abstract" data-number="1" style="border-bottom:1px solid #cccccc"><span class="header-section-number">1</span> Abstract<a href="#abstract" class="self-link"></a></h1>
<p>We propose a new mechanism for specifying or deducing the value category of the expression that a member-function is invoked on. In other words, a way to tell from within a member function whether the expression it’s invoked on is an lvalue or an rvalue; whether it is const or volatile; and the expression’s type.</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="revision-history" data-number="2" style="border-bottom:1px solid #cccccc"><span class="header-section-number">2</span> Revision History<a href="#revision-history" class="self-link"></a></h1>
<h2 data-number="2.1" id="changes-since-r3" data-number="2.1"><span class="header-section-number">2.1</span> Changes since r3<a href="#changes-since-r3" class="self-link"></a></h2>
<p>The feedback from Belfast in EWG was “This looks good, come back with wording and implementation”. This version adds wording, the implementation is in the works.</p>
<h2 data-number="2.2" id="changes-since-r2" data-number="2.2"><span class="header-section-number">2.2</span> Changes since r2<a href="#changes-since-r2" class="self-link"></a></h2>
<p><span class="citation" data-cites="P0847R2">[<a href="#ref-P0847R2" role="doc-biblioref">P0847R2</a>]</span> was presented in Kona in Jaunary 2019 to EWGI, with generally enthusiastic support.</p>
<p>This version adds:</p>
<ul>
<li>An FAQ entry for <a href="#faq-demand">library implementor feedback</a></li>
<li>An FAQ entry for <a href="#faq-rec-lambda-impl">implementability</a></li>
<li>An FAQ entry for <a href="#faq-computed-deduction">computed deduction</a>, an orthogonal feature that EWGI asked for in Kona.</li>
</ul>
<h2 data-number="2.3" id="changes-since-r1" data-number="2.3"><span class="header-section-number">2.3</span> Changes since r1<a href="#changes-since-r1" class="self-link"></a></h2>
<p><span class="citation" data-cites="P0847R1">[<a href="#ref-P0847R1" role="doc-biblioref">P0847R1</a>]</span> was presented in San Diego in November 2018 with a wide array of syntaxes and name lookup options. Discussion there revealed some potential issues with regards to lambdas that needed to be ironed out. This revision zeroes in on one specific syntax and name lookup semantic which solves all the use-cases.</p>
<h2 data-number="2.4" id="changes-since-r0" data-number="2.4"><span class="header-section-number">2.4</span> Changes since r0<a href="#changes-since-r0" class="self-link"></a></h2>
<p><span class="citation" data-cites="P0847R0">[<a href="#ref-P0847R0" role="doc-biblioref">P0847R0</a>]</span> was presented in Rapperswil in June 2018 using a syntax adjusted from the one used in that paper, using <code class="sourceCode cpp"><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self</code> to indicate the explicit object parameter rather than the <code class="sourceCode cpp">Self<span class="op">&amp;&amp;</span> <span class="kw">this</span> self</code> that appeared in r0 of our paper.</p>
<p>EWG strongly encouraged us to look in two new directions:</p>
<ul>
<li>a different syntax, placing the object parameter’s type after the member function’s parameter declarations (where the <em>cv-ref</em> qualifiers are today)</li>
<li>a different name lookup scheme, which could prevent implicit/unqualified access from within new-style member functions that have an explicit self-type annotation, regardless of syntax.</li>
</ul>
<p>This revision carefully explores both of these directions, presents different syntaxes and lookup schemes, and discusses in depth multiple use cases and how each syntax can or cannot address them.</p>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="motivation" data-number="3" style="border-bottom:1px solid #cccccc"><span class="header-section-number">3</span> Motivation<a href="#motivation" class="self-link"></a></h1>
<p>In C++03, member functions could have <em>cv</em>-qualifications, so it was possible to have scenarios where a particular class would want both a <code class="sourceCode cpp"><span class="kw">const</span></code> and non-<code class="sourceCode cpp"><span class="kw">const</span></code> overload of a particular member. (Note that it was also possible to want <code class="sourceCode cpp"><span class="kw">volatile</span></code> overloads, but those are less common and thus are not examined here.) In these cases, both overloads do the same thing — the only difference is in the types being accessed and used. This was handled by either duplicating the function while adjusting types and qualifications as necessary, or having one overload delegate to the other. An example of the latter can be found in Scott Meyers’s “Effective C++” <span class="citation" data-cites="Effective">[<a href="#ref-Effective" role="doc-biblioref">EffCpp</a>]</span>, Item 3:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">class</span> TextBlock <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>  <span class="dt">char</span> <span class="kw">const</span><span class="op">&amp;</span> <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_t</span> position<span class="op">)</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="co">// ...</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="cf">return</span> text<span class="op">[</span>position<span class="op">]</span>;</span>
<span id="cb1-6"><a href="#cb1-6"></a>  <span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a>  <span class="dt">char</span><span class="op">&amp;</span> <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_t</span> position<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="cf">return</span> <span class="kw">const_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&amp;&gt;(</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>      <span class="kw">static_cast</span><span class="op">&lt;</span>TextBlock <span class="kw">const</span><span class="op">&amp;&gt;(*</span><span class="kw">this</span><span class="op">)[</span>position<span class="op">]</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="op">)</span>;</span>
<span id="cb1-12"><a href="#cb1-12"></a>  <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>  <span class="co">// ...</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="op">}</span>;</span></code></pre></div>
<p>Arguably, neither duplication nor delegation via <code class="sourceCode cpp"><span class="kw">const_cast</span></code> are great solutions, but they work.</p>
<p>In C++11, member functions acquired a new axis to specialize on: ref-qualifiers. Now, instead of potentially needing two overloads of a single member function, we might need four: <code class="sourceCode cpp"><span class="op">&amp;</span></code>, <code class="sourceCode cpp"><span class="kw">const</span><span class="op">&amp;</span></code>, <code class="sourceCode cpp"><span class="op">&amp;&amp;</span></code>, or <code class="sourceCode cpp"><span class="kw">const</span><span class="op">&amp;&amp;</span></code>. We have three approaches to deal with this:</p>
<ul>
<li>We implement the same member four times;</li>
<li>We have three overloads delegate to the fourth; or</li>
<li>We have all four overloads delegate to a helper in the form of a private static member function.</li>
</ul>
<p>One example of the latter might be the overload set for <code class="sourceCode cpp">optional<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">()</span></code>, implemented as:</p>
<table style="width:100%">
<tr>
<th style="width:33%">
Quadruplication
</th>
<th style="width:33%">
Delegation to 4th
</th>
<th style="width:33%">
Delegation to helper
</th>
</tr>
<tr>
<td>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="co">// ...</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="kw">constexpr</span> T<span class="op">&amp;</span> value<span class="op">()</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="cf">if</span> <span class="op">(</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>      <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>m_value;</span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb2-9"><a href="#cb2-9"></a>  <span class="op">}</span></span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a>  <span class="kw">constexpr</span> T <span class="kw">const</span><span class="op">&amp;</span> value<span class="op">()</span> <span class="kw">const</span><span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>    <span class="cf">if</span> <span class="op">(</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>      <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>m_value;</span>
<span id="cb2-14"><a href="#cb2-14"></a>    <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>    <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb2-16"><a href="#cb2-16"></a>  <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17"></a></span>
<span id="cb2-18"><a href="#cb2-18"></a>  <span class="kw">constexpr</span> T<span class="op">&amp;&amp;</span> value<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>    <span class="cf">if</span> <span class="op">(</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>      <span class="cf">return</span> move<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>m_value<span class="op">)</span>;</span>
<span id="cb2-21"><a href="#cb2-21"></a>    <span class="op">}</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>    <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb2-23"><a href="#cb2-23"></a>  <span class="op">}</span></span>
<span id="cb2-24"><a href="#cb2-24"></a></span>
<span id="cb2-25"><a href="#cb2-25"></a>  <span class="kw">constexpr</span> T <span class="kw">const</span><span class="op">&amp;&amp;</span></span>
<span id="cb2-26"><a href="#cb2-26"></a>  value<span class="op">()</span> <span class="kw">const</span><span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb2-27"><a href="#cb2-27"></a>    <span class="cf">if</span> <span class="op">(</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb2-28"><a href="#cb2-28"></a>      <span class="cf">return</span> move<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>m_value<span class="op">)</span>;</span>
<span id="cb2-29"><a href="#cb2-29"></a>    <span class="op">}</span></span>
<span id="cb2-30"><a href="#cb2-30"></a>    <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb2-31"><a href="#cb2-31"></a>  <span class="op">}</span></span>
<span id="cb2-32"><a href="#cb2-32"></a>  <span class="co">// ...</span></span>
<span id="cb2-33"><a href="#cb2-33"></a><span class="op">}</span>;</span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="co">// ...</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="kw">constexpr</span> T<span class="op">&amp;</span> value<span class="op">()</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="cf">return</span> <span class="kw">const_cast</span><span class="op">&lt;</span>T<span class="op">&amp;&gt;(</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>      <span class="kw">static_cast</span><span class="op">&lt;</span>optional <span class="kw">const</span><span class="op">&amp;&gt;(</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>        <span class="op">*</span><span class="kw">this</span><span class="op">).</span>value<span class="op">())</span>;</span>
<span id="cb3-8"><a href="#cb3-8"></a>  <span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a>  <span class="kw">constexpr</span> T <span class="kw">const</span><span class="op">&amp;</span> value<span class="op">()</span> <span class="kw">const</span><span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="cf">if</span> <span class="op">(</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>      <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>m_value;</span>
<span id="cb3-13"><a href="#cb3-13"></a>    <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb3-15"><a href="#cb3-15"></a>  <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16"></a></span>
<span id="cb3-17"><a href="#cb3-17"></a>  <span class="kw">constexpr</span> T<span class="op">&amp;&amp;</span> value<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18"></a>    <span class="cf">return</span> <span class="kw">const_cast</span><span class="op">&lt;</span>T<span class="op">&amp;&amp;&gt;(</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>      <span class="kw">static_cast</span><span class="op">&lt;</span>optional <span class="kw">const</span><span class="op">&amp;&gt;(</span></span>
<span id="cb3-20"><a href="#cb3-20"></a>        <span class="op">*</span><span class="kw">this</span><span class="op">).</span>value<span class="op">())</span>;</span>
<span id="cb3-21"><a href="#cb3-21"></a>  <span class="op">}</span></span>
<span id="cb3-22"><a href="#cb3-22"></a></span>
<span id="cb3-23"><a href="#cb3-23"></a>  <span class="kw">constexpr</span> T <span class="kw">const</span><span class="op">&amp;&amp;</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>  value<span class="op">()</span> <span class="kw">const</span><span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb3-25"><a href="#cb3-25"></a>    <span class="cf">return</span> <span class="kw">static_cast</span><span class="op">&lt;</span>T <span class="kw">const</span><span class="op">&amp;&amp;&gt;(</span></span>
<span id="cb3-26"><a href="#cb3-26"></a>      value<span class="op">())</span>;</span>
<span id="cb3-27"><a href="#cb3-27"></a>  <span class="op">}</span></span>
<span id="cb3-28"><a href="#cb3-28"></a>  <span class="co">// ...</span></span>
<span id="cb3-29"><a href="#cb3-29"></a><span class="op">}</span>;</span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="co">// ...</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">constexpr</span> T<span class="op">&amp;</span> value<span class="op">()</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="cf">return</span> value_impl<span class="op">(*</span><span class="kw">this</span><span class="op">)</span>;</span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a>  <span class="kw">constexpr</span> T <span class="kw">const</span><span class="op">&amp;</span> value<span class="op">()</span> <span class="kw">const</span><span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="cf">return</span> value_impl<span class="op">(*</span><span class="kw">this</span><span class="op">)</span>;</span>
<span id="cb4-10"><a href="#cb4-10"></a>  <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a>  <span class="kw">constexpr</span> T<span class="op">&amp;&amp;</span> value<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="cf">return</span> value_impl<span class="op">(</span>move<span class="op">(*</span><span class="kw">this</span><span class="op">))</span>;</span>
<span id="cb4-14"><a href="#cb4-14"></a>  <span class="op">}</span></span>
<span id="cb4-15"><a href="#cb4-15"></a></span>
<span id="cb4-16"><a href="#cb4-16"></a>  <span class="kw">constexpr</span> T <span class="kw">const</span><span class="op">&amp;&amp;</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>  value<span class="op">()</span> <span class="kw">const</span><span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18"></a>    <span class="cf">return</span> value_impl<span class="op">(</span>move<span class="op">(*</span><span class="kw">this</span><span class="op">))</span>;</span>
<span id="cb4-19"><a href="#cb4-19"></a>  <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20"></a></span>
<span id="cb4-21"><a href="#cb4-21"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb4-22"><a href="#cb4-22"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Opt<span class="op">&gt;</span></span>
<span id="cb4-23"><a href="#cb4-23"></a>  <span class="kw">static</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>  value_impl<span class="op">(</span>Opt<span class="op">&amp;&amp;</span> opt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-25"><a href="#cb4-25"></a>    <span class="cf">if</span> <span class="op">(!</span>opt<span class="op">.</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb4-26"><a href="#cb4-26"></a>      <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb4-27"><a href="#cb4-27"></a>    <span class="op">}</span></span>
<span id="cb4-28"><a href="#cb4-28"></a>    <span class="cf">return</span> forward<span class="op">&lt;</span>Opt<span class="op">&gt;(</span>opt<span class="op">).</span>m_value;</span>
<span id="cb4-29"><a href="#cb4-29"></a>  <span class="op">}</span></span>
<span id="cb4-30"><a href="#cb4-30"></a>  <span class="co">// ...</span></span>
<span id="cb4-31"><a href="#cb4-31"></a><span class="op">}</span>;</span></code></pre></div>
</td>
</tr>
</table>
<p>This is far from a complicated function, but essentially repeating the same code four times — or using artificial delegation to avoid doing so — begs a rewrite. Unfortunately, it’s impossible to improve; we <em>must</em> implement it this way. It seems we should be able to abstract away the qualifiers as we can for non-member functions, where we simply don’t have this problem:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="co">// ...</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Opt<span class="op">&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="kw">friend</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> value<span class="op">(</span>Opt<span class="op">&amp;&amp;</span> o<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>        <span class="cf">if</span> <span class="op">(</span>o<span class="op">.</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>            <span class="cf">return</span> forward<span class="op">&lt;</span>Opt<span class="op">&gt;(</span>o<span class="op">).</span>m_value;</span>
<span id="cb5-8"><a href="#cb5-8"></a>        <span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>        <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb5-10"><a href="#cb5-10"></a>    <span class="op">}</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>    <span class="co">// ...</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="op">}</span>;</span></code></pre></div>
<p>All four cases are now handled with just one function… except it’s a non-member function, not a member function. Different semantics, different syntax, doesn’t help.</p>
<p>There are many cases where we need two or four overloads of the same member function for different <code class="sourceCode cpp"><span class="kw">const</span></code>- or ref-qualifiers. More than that, there are likely additional cases where a class should have four overloads of a particular member function but, due to developer laziness, doesn’t. We think that there are enough such cases to merit a better solution than simply “write it, write it again, then write it two more times.”</p>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="proposal" data-number="4" style="border-bottom:1px solid #cccccc"><span class="header-section-number">4</span> Proposal<a href="#proposal" class="self-link"></a></h1>
<p>We propose a new way of declaring non-static member functions that will allow for deducing the type and value category of the class instance parameter while still being invocable with regular member function syntax. This is a strict extension to the language.</p>
<p>We believe that the ability to write <em>cv-ref qualifier</em>-aware member function templates without duplication will improve code maintainability, decrease the likelihood of bugs, and make fast, correct code easier to write.</p>
<p>The proposal is sufficiently general and orthogonal to allow for several new exciting features and design patterns for C++:</p>
<ul>
<li><a href="#recursive-lambdas">recursive lambdas</a></li>
<li>a new approach to <a href="#crtp">mixins</a>, a CRTP without the CRT</li>
<li><a href="#move-into-parameter">move-or-copy-into-parameter support for member functions</a></li>
<li>efficiency by avoiding double indirection with <a href="#by-value-member-functions-for-performance">invocation</a></li>
<li>perfect, sfinae-friendly <a href="#sfinae-friendly-callables">call wrappers</a></li>
</ul>
<p>These are explored in detail in the <a href="#real-world-examples">examples</a> section.</p>
<p>This proposal assumes the existence of two library additions, though it does not propose them:</p>
<ul>
<li><code class="sourceCode cpp">like_t</code>, a metafunction that applies the <em>cv</em>- and <em>ref</em>-qualifiers of the first type onto the second (e.g. <code class="sourceCode cpp">like_t<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;</span>, <span class="dt">double</span><span class="op">&gt;</span></code> is <code class="sourceCode cpp"><span class="dt">double</span><span class="op">&amp;</span></code>, <code class="sourceCode cpp">like_t<span class="op">&lt;</span>X <span class="kw">const</span><span class="op">&amp;&amp;</span>, Y<span class="op">&gt;</span></code> is <code class="sourceCode cpp">Y <span class="kw">const</span><span class="op">&amp;&amp;</span></code>, etc.)</li>
<li><code class="sourceCode cpp">forward_like</code>, a version of <code class="sourceCode cpp">forward</code> that is intended to forward a variable not based on its own type but instead based on some other type. <code class="sourceCode cpp">forward_like<span class="op">&lt;</span>T<span class="op">&gt;(</span>u<span class="op">)</span></code> is short-hand for <code class="sourceCode cpp">forward<span class="op">&lt;</span>like_t<span class="op">&lt;</span>T,<span class="kw">decltype</span><span class="op">(</span>u<span class="op">)&gt;&gt;(</span>u<span class="op">)</span></code>.</li>
</ul>
<h2 data-number="4.1" id="proposed-syntax" data-number="4.1"><span class="header-section-number">4.1</span> Proposed Syntax<a href="#proposed-syntax" class="self-link"></a></h2>
<p>The proposed syntax in this paper is to use an explicit <code class="sourceCode cpp"><span class="kw">this</span></code>-annotated parameter.</p>
<p>A non-static member function can be declared to take as its first parameter an <em>explicit object parameter</em>, denoted with the prefixed keyword <code class="sourceCode cpp"><span class="kw">this</span></code>. Once we elevate the object parameter to a proper function parameter, it can be deduced following normal function template deduction rules:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">struct</span> X <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="dt">void</span> foo<span class="op">(</span><span class="kw">this</span> X <span class="kw">const</span><span class="op">&amp;</span> self, <span class="dt">int</span> i<span class="op">)</span>;</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="dt">void</span> bar<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span>;</span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="op">}</span>;</span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="kw">struct</span> D <span class="op">:</span> X <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="dt">void</span> ex<span class="op">(</span>X<span class="op">&amp;</span> x, D <span class="kw">const</span><span class="op">&amp;</span> d<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>    x<span class="op">.</span>foo<span class="op">(</span><span class="dv">42</span><span class="op">)</span>;      <span class="co">// &#39;self&#39; is bound to &#39;x&#39;, &#39;i&#39; is 42</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>    x<span class="op">.</span>bar<span class="op">()</span>;        <span class="co">// deduces Self as X&amp;, calls X::bar&lt;X&amp;&gt;</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>    move<span class="op">(</span>x<span class="op">).</span>bar<span class="op">()</span>;  <span class="co">// deduces Self as X, calls X::bar&lt;X&gt;</span></span>
<span id="cb6-14"><a href="#cb6-14"></a></span>
<span id="cb6-15"><a href="#cb6-15"></a>    d<span class="op">.</span>foo<span class="op">(</span><span class="dv">17</span><span class="op">)</span>;      <span class="co">// &#39;self&#39; is bound to &#39;d&#39;</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>    d<span class="op">.</span>bar<span class="op">()</span>;        <span class="co">// deduces Self as D const&amp;, calls X::bar&lt;D const&amp;&gt;</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="op">}</span></span></code></pre></div>
<p>Member functions with an explicit object parameter cannot be <code class="sourceCode cpp"><span class="kw">static</span></code> or have <em>cv</em>- or <em>ref</em>-qualifiers.</p>
<p>A call to a member function will interpret the object argument as the first (<code class="sourceCode cpp"><span class="kw">this</span></code>-annotated) parameter to it; the first argument in the parenthesized expression list is then interpreted as the second parameter, and so forth.</p>
<p>Following normal deduction rules, the template parameter corresponding to the explicit object parameter can deduce to a type derived from the class in which the member function is declared, as in the example above for <code class="sourceCode cpp">d<span class="op">.</span>bar<span class="op">()</span></code>).</p>
<p>We can use this syntax to implement <code class="sourceCode cpp">optional<span class="op">::</span>value<span class="op">()</span></code> and <code class="sourceCode cpp">optional<span class="op">::</span><span class="kw">operator</span><span class="op">-&gt;()</span></code> in just two functions instead of the current six:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">struct</span> optional <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span><span class="op">&amp;&amp;</span> value<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="cf">if</span> <span class="op">(!</span>self<span class="op">.</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>      <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="op">}</span></span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="cf">return</span> forward<span class="op">&lt;</span>Self<span class="op">&gt;(</span>self<span class="op">).</span>m_value;</span>
<span id="cb7-10"><a href="#cb7-10"></a>  <span class="op">}</span></span>
<span id="cb7-11"><a href="#cb7-11"></a></span>
<span id="cb7-12"><a href="#cb7-12"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-&gt;(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-14"><a href="#cb7-14"></a>    <span class="cf">return</span> addressof<span class="op">(</span>self<span class="op">.</span>m_value<span class="op">)</span>;</span>
<span id="cb7-15"><a href="#cb7-15"></a>  <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="op">}</span>;</span></code></pre></div>
<p>This syntax can be used in lambdas as well, with the <code class="sourceCode cpp"><span class="kw">this</span></code>-annotated parameter exposing a way to refer to the lambda itself in its body:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a>vector captured <span class="op">=</span> <span class="op">{</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span><span class="op">}</span>;</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="op">[</span>captured<span class="op">](</span><span class="kw">this</span> <span class="kw">auto</span><span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="cf">return</span> forward_like<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>self<span class="op">)&gt;(</span>captured<span class="op">)</span>;</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="op">}</span></span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="op">[</span>captured<span class="op">]&lt;</span><span class="kw">class</span> Self<span class="op">&gt;(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>  <span class="cf">return</span> forward_like<span class="op">&lt;</span>Self<span class="op">&gt;(</span>captured<span class="op">)</span>;</span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="op">}</span></span></code></pre></div>
<p>The lambdas can either move or copy from the capture, depending on whether the lambda is an lvalue or an rvalue.</p>
<h2 data-number="4.2" id="proposed-semantics" data-number="4.2"><span class="header-section-number">4.2</span> Proposed semantics<a href="#proposed-semantics" class="self-link"></a></h2>
<p>What follows is a description of how deducing <code class="sourceCode cpp"><span class="kw">this</span></code> affects all important language constructs — name lookup, type deduction, overload resolution, and so forth.</p>
<h3 data-number="4.2.1" id="name-lookup-candidate-functions" data-number="4.2.1"><span class="header-section-number">4.2.1</span> Name lookup: candidate functions<a href="#name-lookup-candidate-functions" class="self-link"></a></h3>
<p><strong>In C++17</strong>, name lookup includes both static and non-static member functions found by regular class lookup when invoking a named function or an operator, including the call operator, on an object of class type. Non-static member functions are treated as if there were an implicit object parameter whose type is an lvalue or rvalue reference to <em>cv</em> <code class="sourceCode cpp">X</code> (where the reference and <em>cv</em> qualifiers are determined based on the function’s own qualifiers) which binds to the object on which the function was invoked.</p>
<p>For non-static member functions using an explicit object parameter, lookup will work the same way as other member functions in C++17, with one exception: rather than implicitly determining the type of the object parameter based on the <em>cv</em>- and <em>ref</em>-qualifiers of the member function, these are now explicitly determined by the provided type of the explicit object parameter. The following examples illustrate this concept.</p>
<table style="width:100%">
<tr>
<th style="width:50%">
C++17
</th>
<th style="width:50%">
Proposed
</th>
</tr>
<tr>
<td>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">struct</span> X <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="co">// implicit object has type X&amp;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="dt">void</span> foo<span class="op">()</span> <span class="op">&amp;</span>;</span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="co">// implicit object has type X const&amp;</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>  <span class="dt">void</span> foo<span class="op">()</span> <span class="kw">const</span><span class="op">&amp;</span>;</span>
<span id="cb9-7"><a href="#cb9-7"></a></span>
<span id="cb9-8"><a href="#cb9-8"></a>  <span class="co">// implicit object has type X&amp;&amp;</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>  <span class="dt">void</span> bar<span class="op">()</span> <span class="op">&amp;&amp;</span>;</span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="op">}</span>;</span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">struct</span> X <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="co">// explicit object has type X&amp;</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="dt">void</span> foo<span class="op">(</span><span class="kw">this</span> X<span class="op">&amp;)</span>;</span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a>  <span class="co">// explicit object has type X const&amp;</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>  <span class="dt">void</span> foo<span class="op">(</span><span class="kw">this</span> X <span class="kw">const</span><span class="op">&amp;)</span>;</span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a>  <span class="co">// explicit object has type X&amp;&amp;</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>  <span class="dt">void</span> bar<span class="op">(</span><span class="kw">this</span> X<span class="op">&amp;&amp;)</span>;</span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="op">}</span>;</span></code></pre></div>
</td>
</tr>
</table>
<p>Name lookup on an expression like <code class="sourceCode cpp">obj<span class="op">.</span>foo<span class="op">()</span></code> in C++17 would find both overloads of <code class="sourceCode cpp">foo</code> in the first column, with the non-const overload discarded should <code class="sourceCode cpp">obj</code> be const.</p>
<p>With the proposed syntax, <code class="sourceCode cpp">obj<span class="op">.</span>foo<span class="op">()</span></code> would continue to find both overloads of <code class="sourceCode cpp">foo</code>, with identical behaviour to C++17.</p>
<p>The only change in how we look up candidate functions is in the case of an explicit object parameter, where the argument list is shifted by one. The first listed parameter is bound to the object argument, and the second listed parameter corresponds to the first argument of the call expression.</p>
<p>This paper does not propose any changes to overload <em>resolution</em> but merely suggests extending the candidate set to include non-static member functions and member function templates written in a new syntax. Therefore, given a call to <code class="sourceCode cpp">x<span class="op">.</span>foo<span class="op">()</span></code>, overload resolution would still select the first <code class="sourceCode cpp">foo<span class="op">()</span></code> overload if <code class="sourceCode cpp">x</code> is not <code class="sourceCode cpp"><span class="kw">const</span></code> and the second if it is.</p>
<p>The behaviors of the two columns are exactly equivalent as proposed.</p>
<p>The only change as far as candidates are concerned is that the proposal allows for deduction of the object parameter, which is new for the language.</p>
<h3 data-number="4.2.2" id="type-deduction" data-number="4.2.2"><span class="header-section-number">4.2.2</span> Type deduction<a href="#type-deduction" class="self-link"></a></h3>
<p>One of the main motivations of this proposal is to deduce the <em>cv</em>-qualifiers and value category of the class object, which requires that the explicit member object or type be deducible from the object on which the member function is invoked.</p>
<p>If the type of the object parameter is a template parameter, all of the usual template deduction rules apply as expected:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">struct</span> X <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="dt">void</span> foo<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span>, <span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="op">}</span>;</span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="kw">struct</span> D <span class="op">:</span> X <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb11-7"><a href="#cb11-7"></a></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="dt">void</span> ex<span class="op">(</span>X<span class="op">&amp;</span> x, D<span class="op">&amp;</span> d<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>    x<span class="op">.</span>foo<span class="op">(</span><span class="dv">1</span><span class="op">)</span>;       <span class="co">// Self=X&amp;</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>    move<span class="op">(</span>x<span class="op">).</span>foo<span class="op">(</span><span class="dv">2</span><span class="op">)</span>; <span class="co">// Self=X</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>    d<span class="op">.</span>foo<span class="op">(</span><span class="dv">3</span><span class="op">)</span>;       <span class="co">// Self=D&amp;</span></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="op">}</span></span></code></pre></div>
<p>It’s important to stress that deduction is able to deduce a derived type, which is extremely powerful. In the last line, regardless of syntax, <code class="sourceCode cpp">Self</code> deduces as <code class="sourceCode cpp">D<span class="op">&amp;</span></code>. This has implications for <a href="#name-lookup-within-member-functions">name lookup within member functions</a>, and leads to a potential <a href="#faq-computed-deduction">template argument deduction extension</a>.</p>
<h3 data-number="4.2.3" id="by-value-this" data-number="4.2.3"><span class="header-section-number">4.2.3</span> By value <code class="sourceCode cpp"><span class="kw">this</span></code><a href="#by-value-this" class="self-link"></a></h3>
<p>But what if the explicit type does not have reference type? What should this mean?</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">struct</span> less_than <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">this</span> less_than, T <span class="kw">const</span><span class="op">&amp;</span> lhs, U <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>        <span class="cf">return</span> lhs <span class="op">&lt;</span> rhs;</span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="op">}</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="op">}</span>;</span>
<span id="cb12-7"><a href="#cb12-7"></a></span>
<span id="cb12-8"><a href="#cb12-8"></a>less_than<span class="op">{}(</span><span class="dv">4</span>, <span class="dv">5</span><span class="op">)</span>;</span></code></pre></div>
<p>Clearly, the parameter specification should not lie, and the first parameter (<code class="sourceCode cpp">less_than<span class="op">{}</span></code>) is passed by value.</p>
<p>Following the proposed rules for candidate lookup, the call operator here would be a candidate, with the object parameter binding to the (empty) object and the other two parameters binding to the arguments. Having a value parameter is nothing new in the language at all — it has a clear and obvious meaning, but we’ve never been able to take an object parameter by value before. For cases in which this might be desirable, see <a href="#by-value-member-functions">by-value member functions</a>.</p>
<h3 data-number="4.2.4" id="name-lookup-within-member-functions" data-number="4.2.4"><span class="header-section-number">4.2.4</span> Name lookup: within member functions<a href="#name-lookup-within-member-functions" class="self-link"></a></h3>
<p>So far, we’ve only considered how member functions with explicit object parameters are found with name lookup and how they deduce that parameter. Now we move on to how the bodies of these functions actually behave.</p>
<p>Since the explicit object parameter is deduced from the object on which the function is called, this has the possible effect of deducing <em>derived</em> types. We must carefully consider how name lookup works in this context.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">struct</span> B <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb13-3"><a href="#cb13-3"></a></span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span> <span class="kw">auto</span><span class="op">&amp;&amp;</span> f1<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;)</span> <span class="op">{</span> <span class="cf">return</span> i;  <span class="op">}</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span> <span class="kw">auto</span><span class="op">&amp;&amp;</span> f2<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>i; <span class="op">}</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span> <span class="kw">auto</span><span class="op">&amp;&amp;</span> f3<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;)</span> <span class="op">{</span> <span class="cf">return</span> forward_like<span class="op">&lt;</span>Self<span class="op">&gt;(*</span><span class="kw">this</span><span class="op">).</span>i; <span class="op">}</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span> <span class="kw">auto</span><span class="op">&amp;&amp;</span> f4<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;)</span> <span class="op">{</span> <span class="cf">return</span> forward<span class="op">&lt;</span>Self<span class="op">&gt;(*</span><span class="kw">this</span><span class="op">).</span>i; <span class="op">}</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span> <span class="kw">auto</span><span class="op">&amp;&amp;</span> f5<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> forward<span class="op">&lt;</span>Self<span class="op">&gt;(</span>self<span class="op">).</span>i; <span class="op">}</span></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="op">}</span>;</span>
<span id="cb13-10"><a href="#cb13-10"></a></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="kw">struct</span> D <span class="op">:</span> B <span class="op">{</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>    <span class="co">// shadows B::i</span></span>
<span id="cb13-13"><a href="#cb13-13"></a>    <span class="dt">double</span> i <span class="op">=</span> <span class="fl">3.14</span>;</span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="op">}</span>;</span></code></pre></div>
<p>The question is, what do each of these five functions do? Should any of them be ill-formed? What is the safest option?</p>
<p>We believe that there are three approaches to choose from:</p>
<ol type="1">
<li><p>If there is an explicit object parameter, <code class="sourceCode cpp"><span class="kw">this</span></code> is inaccessible, and each access must be through <code class="sourceCode cpp">self</code>. There is no implicit lookup of members through <code class="sourceCode cpp"><span class="kw">this</span></code>. This makes <code class="sourceCode cpp">f1</code> through <code class="sourceCode cpp">f4</code> ill-formed and only <code class="sourceCode cpp">f5</code> well-formed. However, while <code class="sourceCode cpp">B<span class="op">().</span>f5<span class="op">()</span></code> returns a reference to <code class="sourceCode cpp">B<span class="op">::</span>i</code>, <code class="sourceCode cpp">D<span class="op">().</span>f5<span class="op">()</span></code> returns a reference to <code class="sourceCode cpp">D<span class="op">::</span>i</code>, since <code class="sourceCode cpp">self</code> is a reference to <code class="sourceCode cpp">D</code>.</p></li>
<li><p>If there is an explicit object parameter, <code class="sourceCode cpp"><span class="kw">this</span></code> is accessible and points to the base subobject. There is no implicit lookup of members; all access must be through <code class="sourceCode cpp"><span class="kw">this</span></code> or <code class="sourceCode cpp">self</code> explicitly. This makes <code class="sourceCode cpp">f1</code> ill-formed. <code class="sourceCode cpp">f2</code> would be well-formed and always return a reference to <code class="sourceCode cpp">B<span class="op">::</span>i</code>. Most importantly, <code class="sourceCode cpp"><span class="kw">this</span></code> would be <em>dependent</em> if the explicit object parameter was deduced. <code class="sourceCode cpp"><span class="kw">this</span><span class="op">-&gt;</span>i</code> is always going to be an <code class="sourceCode cpp"><span class="dt">int</span></code> but it could be either an <code class="sourceCode cpp"><span class="dt">int</span></code> or an <code class="sourceCode cpp"><span class="dt">int</span> <span class="kw">const</span></code> depending on whether the <code class="sourceCode cpp">B</code> object is const. <code class="sourceCode cpp">f3</code> would always be well-formed and would be the correct way to return a forwarding reference to <code class="sourceCode cpp">B<span class="op">::</span>i</code>. <code class="sourceCode cpp">f4</code> would be well-formed when invoked on <code class="sourceCode cpp">B</code> but ill-formed if invoked on <code class="sourceCode cpp">D</code> because of the requested implicit downcast. As before, <code class="sourceCode cpp">f5</code> would be well-formed.</p></li>
<li><p><code class="sourceCode cpp"><span class="kw">this</span></code> is always accessible and points to the base subobject; we allow implicit lookup as in C++17. This is mostly the same as the previous choice, except that now <code class="sourceCode cpp">f1</code> is well-formed and exactly equivalent to <code class="sourceCode cpp">f2</code>.</p></li>
</ol>
<p>Following discussion in San Diego, the option we are proposing is #1. This allows for the clearest model of what a <code class="sourceCode cpp"><span class="kw">this</span></code>-annotated function is: it is a <code class="sourceCode cpp"><span class="kw">static</span></code> member function that offers a more convenient function call syntax. There is no implicit <code class="sourceCode cpp"><span class="kw">this</span></code> in such functions, the only mention of <code class="sourceCode cpp"><span class="kw">this</span></code> would be the annotation on the object parameter. All member access must be done directly through the object parameter.</p>
<p>The consequence of such a choice is that we will need to defend against the object parameter being deduced to a derived type. To ensure that <code class="sourceCode cpp">f5<span class="op">()</span></code> above is always returning a reference to <code class="sourceCode cpp">B<span class="op">::</span>i</code>, we would need to write one of the following:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">auto</span><span class="op">&amp;&amp;</span> f5<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="co">// explicitly cast self to the appropriately qualified B</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="co">// note that we have to cast self, not self.i</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="cf">return</span> <span class="kw">static_cast</span><span class="op">&lt;</span>like_t<span class="op">&lt;</span>Self, B<span class="op">&gt;&amp;&amp;&gt;(</span>self<span class="op">).</span>i;</span>
<span id="cb14-6"><a href="#cb14-6"></a></span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span class="co">// use the explicit subobject syntax. Note that this is always</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>    <span class="co">// an lvalue reference - not a forwarding reference</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>    <span class="cf">return</span> self<span class="op">.</span>B<span class="op">::</span>i;</span>
<span id="cb14-10"><a href="#cb14-10"></a></span>
<span id="cb14-11"><a href="#cb14-11"></a>    <span class="co">// use the explicit subobject syntax to get a forwarding reference</span></span>
<span id="cb14-12"><a href="#cb14-12"></a>    <span class="cf">return</span> forward<span class="op">&lt;</span>Self<span class="op">&gt;(</span>self<span class="op">).</span>B<span class="op">::</span>i;</span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="4.2.5" id="writing-function-pointer-types" data-number="4.2.5"><span class="header-section-number">4.2.5</span> Writing the function pointer types for such functions<a href="#writing-function-pointer-types" class="self-link"></a></h3>
<p>As described in the previous section, the model for a member function with an explicit object parameter is a <code class="sourceCode cpp"><span class="kw">static</span></code> member function.</p>
<p>In other words, given:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">struct</span> Y <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>    <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span>, <span class="dt">int</span><span class="op">)</span> <span class="kw">const</span><span class="op">&amp;</span>;</span>
<span id="cb15-3"><a href="#cb15-3"></a>    <span class="dt">int</span> g<span class="op">(</span><span class="kw">this</span> Y <span class="kw">const</span><span class="op">&amp;</span>, <span class="dt">int</span>, <span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="op">}</span>;</span></code></pre></div>
<p>While the type of <code class="sourceCode cpp"><span class="op">&amp;</span>Y<span class="op">::</span>f</code> is <code class="sourceCode cpp"><span class="dt">int</span><span class="op">(</span>Y<span class="op">::*)(</span><span class="dt">int</span>, <span class="dt">int</span><span class="op">)</span> <span class="kw">const</span><span class="op">&amp;</span></code>, the type of <code class="sourceCode cpp"><span class="op">&amp;</span>Y<span class="op">::</span>g</code> is <code class="sourceCode cpp"><span class="dt">int</span><span class="op">(*)(</span>Y <span class="kw">const</span><span class="op">&amp;</span>, <span class="dt">int</span>, <span class="dt">int</span><span class="op">)</span></code>. As these are <em>just</em> function pointers, the usage of these two member functions differs once we drop them to pointers:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a>Y y;</span>
<span id="cb16-2"><a href="#cb16-2"></a>y<span class="op">.</span>f<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>; <span class="co">// ok as usual</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>y<span class="op">.</span>g<span class="op">(</span><span class="dv">3</span>, <span class="dv">4</span><span class="op">)</span>; <span class="co">// ok, this paper</span></span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="kw">auto</span> pf <span class="op">=</span> <span class="op">&amp;</span>Y<span class="op">::</span>f;</span>
<span id="cb16-6"><a href="#cb16-6"></a>pf<span class="op">(</span>y, <span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>;              <span class="co">// error: pointers to member functions are not callable</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="op">(</span>y<span class="op">.*</span>pf<span class="op">)(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>;            <span class="co">// okay, same as above</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>std<span class="op">::</span>invoke<span class="op">(</span>pf, y, <span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>; <span class="co">// ok</span></span>
<span id="cb16-9"><a href="#cb16-9"></a></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="kw">auto</span> pg <span class="op">=</span> <span class="op">&amp;</span>Y<span class="op">::</span>g;</span>
<span id="cb16-11"><a href="#cb16-11"></a>pg<span class="op">(</span>y, <span class="dv">3</span>, <span class="dv">4</span><span class="op">)</span>;              <span class="co">// okay, same as above</span></span>
<span id="cb16-12"><a href="#cb16-12"></a><span class="op">(</span>y<span class="op">.*</span>pg<span class="op">)(</span><span class="dv">3</span>, <span class="dv">4</span><span class="op">)</span>;            <span class="co">// error: pg is not a pointer to member function</span></span>
<span id="cb16-13"><a href="#cb16-13"></a>std<span class="op">::</span>invoke<span class="op">(</span>pg, y, <span class="dv">3</span>, <span class="dv">4</span><span class="op">)</span>; <span class="co">// ok</span></span></code></pre></div>
<p>The rules are the same when deduction kicks in:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">struct</span> B <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="dt">void</span> foo<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;)</span>;</span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="op">}</span>;</span>
<span id="cb17-5"><a href="#cb17-5"></a></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="kw">struct</span> D <span class="op">:</span> B <span class="op">{</span> <span class="op">}</span>;</span></code></pre></div>
<p>Types are as follows: - Type of <code class="sourceCode cpp"><span class="op">&amp;</span>B<span class="op">::</span>foo<span class="op">&lt;</span>B<span class="op">&gt;</span></code> is <code class="sourceCode cpp"><span class="dt">void</span><span class="op">(*)(</span>B<span class="op">&amp;&amp;)</span></code> - Type of <code class="sourceCode cpp"><span class="op">&amp;</span>B<span class="op">::</span>foo<span class="op">&lt;</span>B <span class="kw">const</span><span class="op">&amp;&gt;</span></code> is <code class="sourceCode cpp"><span class="dt">void</span><span class="op">(*)(</span>B <span class="kw">const</span><span class="op">&amp;)</span></code> - Type of <code class="sourceCode cpp"><span class="op">&amp;</span>D<span class="op">::</span>foo<span class="op">&lt;</span>B<span class="op">&gt;</span></code> is <code class="sourceCode cpp"><span class="dt">void</span><span class="op">(*)(</span>B<span class="op">&amp;&amp;)</span></code> - Type of <code class="sourceCode cpp"><span class="op">&amp;</span>B<span class="op">::</span>foo<span class="op">&lt;</span>D<span class="op">&gt;</span></code> is <code class="sourceCode cpp"><span class="dt">void</span><span class="op">(*)(</span>D<span class="op">&amp;&amp;)</span></code></p>
<p>This is exactly what happens if <code class="sourceCode cpp">foo</code> is a normal function.</p>
<p>By-value object parameters give you pointers to function in just the same way, the only difference being that the first parameter being a value parameter instead of a reference parameter:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="kw">struct</span> less_than <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">this</span> less_than, T <span class="kw">const</span><span class="op">&amp;</span>, T <span class="kw">const</span><span class="op">&amp;)</span>;</span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="op">}</span>;</span></code></pre></div>
<p>The type of <code class="sourceCode cpp"><span class="op">&amp;</span>less_than<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span><span class="kw">operator</span><span class="op">()</span></code> is <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(*)(</span>less_than<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span>, <span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;</span>, <span class="dt">int</span> <span class="kw">const</span><span class="op">&amp;)</span></code> and follows the usual rules of invocation:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a>less_than<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> lt;</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="kw">auto</span> p <span class="op">=</span> <span class="op">&amp;</span>less_than<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span><span class="kw">operator</span><span class="op">()</span>;</span>
<span id="cb19-3"><a href="#cb19-3"></a></span>
<span id="cb19-4"><a href="#cb19-4"></a>lt<span class="op">(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>;            <span class="co">// ok</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>p<span class="op">(</span>lt, <span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>;         <span class="co">// ok</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="op">(</span>lt<span class="op">.*</span>p<span class="op">)(</span><span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>;       <span class="co">// error: p is not a pointer to member function</span></span>
<span id="cb19-7"><a href="#cb19-7"></a>invoke<span class="op">(</span>p, lt, <span class="dv">1</span>, <span class="dv">2</span><span class="op">)</span>; <span class="co">// ok</span></span></code></pre></div>
<h3 data-number="4.2.6" id="pathological-cases" data-number="4.2.6"><span class="header-section-number">4.2.6</span> Pathological cases<a href="#pathological-cases" class="self-link"></a></h3>
<p>It is important to mention the pathological cases. First, what happens if <code class="sourceCode cpp">D</code> is incomplete but becomes valid later?</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">struct</span> D;</span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="kw">struct</span> B <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>    <span class="dt">void</span> foo<span class="op">(</span><span class="kw">this</span> D<span class="op">&amp;)</span>;</span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="op">}</span>;</span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="kw">struct</span> D <span class="op">:</span> B <span class="op">{</span> <span class="op">}</span>;</span></code></pre></div>
<p>Following the precedent of <span class="citation" data-cites="P0929R2">[<a href="#ref-P0929R2" role="doc-biblioref">P0929R2</a>]</span>, we think this should be fine, albeit strange. If <code class="sourceCode cpp">D</code> is incomplete, we simply postpone checking until the point of call or formation of pointer to member, etc. At that point, the call will either not be viable or the formation of pointer-to-member would be ill-formed.</p>
<p>For unrelated complete classes or non-classes:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">struct</span> A <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="kw">struct</span> B <span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>    <span class="dt">void</span> foo<span class="op">(</span><span class="kw">this</span> A<span class="op">&amp;)</span>;</span>
<span id="cb21-4"><a href="#cb21-4"></a>    <span class="dt">void</span> bar<span class="op">(</span><span class="kw">this</span> <span class="dt">int</span><span class="op">)</span>;</span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="op">}</span>;</span></code></pre></div>
<p>The declaration can be immediately diagnosed as ill-formed.</p>
<p>Another interesting case, courtesy of Jens Maurer:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">struct</span> D;</span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="kw">struct</span> B <span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>  <span class="dt">int</span> f1<span class="op">(</span><span class="kw">this</span> D<span class="op">)</span>;</span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="op">}</span>;</span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="kw">struct</span> D1 <span class="op">:</span> B <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="kw">struct</span> D2 <span class="op">:</span> B <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="kw">struct</span> D <span class="op">:</span> D1, D2 <span class="op">{</span> <span class="op">}</span>;</span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="dt">int</span> x <span class="op">=</span> D<span class="op">().</span>f1<span class="op">()</span>;  <span class="co">// error: ambiguous lookup</span></span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="dt">int</span> y <span class="op">=</span> B<span class="op">().</span>f1<span class="op">()</span>;  <span class="co">// error: B is not implicitly convertible to D</span></span>
<span id="cb22-11"><a href="#cb22-11"></a><span class="kw">auto</span> z <span class="op">=</span> <span class="op">&amp;</span>B<span class="op">::</span>f1;   <span class="co">// ok</span></span>
<span id="cb22-12"><a href="#cb22-12"></a>z<span class="op">(</span>D<span class="op">())</span>;            <span class="co">// ok</span></span></code></pre></div>
<p>Even though both <code class="sourceCode cpp">D<span class="op">().</span>f1<span class="op">()</span></code> and <code class="sourceCode cpp">B<span class="op">().</span>f1<span class="op">()</span></code> are ill-formed, for entirely different reasons, taking a pointer to <code class="sourceCode cpp"><span class="op">&amp;</span>B<span class="op">::</span>f1</code> is acceptable — its type is <code class="sourceCode cpp"><span class="dt">int</span><span class="op">(*)(</span>D<span class="op">)</span></code> — and that function pointer can be invoked with a <code class="sourceCode cpp">D</code>. Actually invoking this function does not require any further name lookup or conversion because by-value member functions do not have an implicit object parameter in this syntax (see <a href="#by-value-this">by-value <code class="sourceCode cpp"><span class="kw">this</span></code></a>.</p>
<h3 data-number="4.2.7" id="teachability-implications" data-number="4.2.7"><span class="header-section-number">4.2.7</span> Teachability Implications<a href="#teachability-implications" class="self-link"></a></h3>
<p>Explicitly naming the object as the <code class="sourceCode cpp"><span class="kw">this</span></code>-designated first parameter fits within many programmers’ mental models of the <code class="sourceCode cpp"><span class="kw">this</span></code> pointer being the first parameter to member functions “under the hood” and is comparable to its usage in other languages, e.g. Python and Rust. It also works as a more obvious way to teach how <code class="sourceCode cpp">std<span class="op">::</span>bind</code>, <code class="sourceCode cpp">std<span class="op">::</span>thread</code>, <code class="sourceCode cpp">std<span class="op">::</span>function</code>, and others work with a member function pointer by making the pointer explicit.</p>
<p>As such, we do not believe there to be any teachability problems.</p>
<h3 data-number="4.2.8" id="static-member-functions" data-number="4.2.8"><span class="header-section-number">4.2.8</span> Can <code class="sourceCode cpp"><span class="kw">static</span></code> member functions have an explicit object type?<a href="#static-member-functions" class="self-link"></a></h3>
<p>No. Static member functions currently do not have an implicit object parameter, and therefore have no reason to provide an explicit one.</p>
<h3 data-number="4.2.9" id="interplays-with-capturing-this" data-number="4.2.9"><span class="header-section-number">4.2.9</span> Interplays with capturing <code class="sourceCode cpp"><span class="op">[</span><span class="kw">this</span><span class="op">]</span></code> and <code class="sourceCode cpp"><span class="op">[*</span><span class="kw">this</span><span class="op">]</span></code> in lambdas<a href="#interplays-with-capturing-this" class="self-link"></a></h3>
<p>Interoperability is perfect, since they do not impact the meaning of <code class="sourceCode cpp"><span class="kw">this</span></code> in a function body. The introduced identifier <code class="sourceCode cpp">self</code> can then be used to refer to the lambda instance from the body.</p>
<h3 data-number="4.2.10" id="parsing-issues" data-number="4.2.10"><span class="header-section-number">4.2.10</span> Parsing issues<a href="#parsing-issues" class="self-link"></a></h3>
<p>The proposed syntax has no parsings issue that we are aware of.</p>
<h3 data-number="4.2.11" id="code-issues" data-number="4.2.11"><span class="header-section-number">4.2.11</span> Code issues<a href="#code-issues" class="self-link"></a></h3>
<p>There are two programmatic issues with this proposal that we are aware of:</p>
<ol type="1">
<li><p>Inadvertently referencing a shadowing member of a derived object in a base class <code class="sourceCode cpp"><span class="kw">this</span></code>-annotated member function. There are some use cases where we would want to do this on purposes (see <a href="#crtp">crtp</a>), but for other use-cases the programmer will have to be aware of potential issues and defend against them in a somewhat verobse way.</p></li>
<li><p>Because there is no way to <em>just</em> deduce <code class="sourceCode cpp"><span class="kw">const</span></code> vs non-<code class="sourceCode cpp"><span class="kw">const</span></code>, the only way to deduce the value category would be to take a forwarding reference. This means that potentially we create four instantiations when only two would be minimally necessary to solve the problem. But deferring to a templated implementation is an acceptable option and has been improved by no longer requiring casts. We believe that the problem is minimal.</p></li>
</ol>
<h1 data-number="5" style="border-bottom:1px solid #cccccc" id="real-world-examples" data-number="5" style="border-bottom:1px solid #cccccc"><span class="header-section-number">5</span> Real-World Examples<a href="#real-world-examples" class="self-link"></a></h1>
<p>What follows are several examples of the kinds of problems that can be solved using this proposal.</p>
<h2 data-number="5.1" id="deduplicating-code" data-number="5.1"><span class="header-section-number">5.1</span> Deduplicating Code<a href="#deduplicating-code" class="self-link"></a></h2>
<p>This proposal can de-duplicate and de-quadruplicate a large amount of code. In each case, the single function is only slightly more complex than the initial two or four, which makes for a huge win. What follows are a few examples of ways to reduce repeated code.</p>
<p>This particular implementation of <code class="sourceCode cpp">optional</code> is Simon’s, and can be viewed on <a href="https://github.com/TartanLlama/optional">GitHub</a>. It includes some functions proposed in <span class="citation" data-cites="P0798R0">[<a href="#ref-P0798R0" role="doc-biblioref">P0798R0</a>]</span>, with minor changes to better suit this format:</p>
<table style="width:100%">
<tr>
<th style="width:50%">
C++17
</th>
<th style="width:50%">
Proposed
</th>
</tr>
<tr>
<td>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">class</span> TextBlock <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb23-3"><a href="#cb23-3"></a>  <span class="dt">char</span> <span class="kw">const</span><span class="op">&amp;</span> <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_t</span> position<span class="op">)</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>    <span class="co">// ...</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>    <span class="cf">return</span> text<span class="op">[</span>position<span class="op">]</span>;</span>
<span id="cb23-6"><a href="#cb23-6"></a>  <span class="op">}</span></span>
<span id="cb23-7"><a href="#cb23-7"></a></span>
<span id="cb23-8"><a href="#cb23-8"></a>  <span class="dt">char</span><span class="op">&amp;</span> <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_t</span> position<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-9"><a href="#cb23-9"></a>    <span class="cf">return</span> <span class="kw">const_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&amp;&gt;(</span></span>
<span id="cb23-10"><a href="#cb23-10"></a>      <span class="kw">static_cast</span><span class="op">&lt;</span>TextBlock <span class="kw">const</span><span class="op">&amp;&gt;</span></span>
<span id="cb23-11"><a href="#cb23-11"></a>        <span class="op">(</span><span class="kw">this</span><span class="op">)[</span>position<span class="op">]</span></span>
<span id="cb23-12"><a href="#cb23-12"></a>    <span class="op">)</span>;</span>
<span id="cb23-13"><a href="#cb23-13"></a>  <span class="op">}</span></span>
<span id="cb23-14"><a href="#cb23-14"></a>  <span class="co">// ...</span></span>
<span id="cb23-15"><a href="#cb23-15"></a><span class="op">}</span>;</span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">class</span> TextBlock <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>  <span class="kw">auto</span><span class="op">&amp;</span> <span class="kw">operator</span><span class="op">[](</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self, <span class="dt">size_t</span> position<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>    <span class="co">// ...</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>    <span class="cf">return</span> self<span class="op">.</span>text<span class="op">[</span>position<span class="op">]</span>;</span>
<span id="cb24-7"><a href="#cb24-7"></a>  <span class="op">}</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>  <span class="co">// ...</span></span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="op">}</span>;</span></code></pre></div>
</td>
</tr>
<tr>
<td>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>  <span class="co">// ...</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>  <span class="kw">constexpr</span> T<span class="op">*</span> <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="op">{</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>    <span class="cf">return</span> addressof<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>m_value<span class="op">)</span>;</span>
<span id="cb25-6"><a href="#cb25-6"></a>  <span class="op">}</span></span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a>  <span class="kw">constexpr</span> T <span class="kw">const</span><span class="op">*</span></span>
<span id="cb25-9"><a href="#cb25-9"></a>  <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb25-10"><a href="#cb25-10"></a>    <span class="cf">return</span> addressof<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>m_value<span class="op">)</span>;</span>
<span id="cb25-11"><a href="#cb25-11"></a>  <span class="op">}</span></span>
<span id="cb25-12"><a href="#cb25-12"></a>  <span class="co">// ...</span></span>
<span id="cb25-13"><a href="#cb25-13"></a><span class="op">}</span>;</span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>  <span class="co">// ...</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb26-5"><a href="#cb26-5"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">-&gt;(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-6"><a href="#cb26-6"></a>    <span class="cf">return</span> addressof<span class="op">(</span>self<span class="op">.</span>m_value<span class="op">)</span>;</span>
<span id="cb26-7"><a href="#cb26-7"></a>  <span class="op">}</span></span>
<span id="cb26-8"><a href="#cb26-8"></a>  <span class="co">// ...</span></span>
<span id="cb26-9"><a href="#cb26-9"></a><span class="op">}</span>;</span></code></pre></div>
</td>
</tr>
<tr>
<td>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>  <span class="co">// ...</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>  <span class="kw">constexpr</span> T<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">*()</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb27-5"><a href="#cb27-5"></a>    <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>m_value;</span>
<span id="cb27-6"><a href="#cb27-6"></a>  <span class="op">}</span></span>
<span id="cb27-7"><a href="#cb27-7"></a></span>
<span id="cb27-8"><a href="#cb27-8"></a>  <span class="kw">constexpr</span> T <span class="kw">const</span><span class="op">&amp;</span> <span class="kw">operator</span><span class="op">*()</span> <span class="kw">const</span><span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb27-9"><a href="#cb27-9"></a>    <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>m_value;</span>
<span id="cb27-10"><a href="#cb27-10"></a>  <span class="op">}</span></span>
<span id="cb27-11"><a href="#cb27-11"></a></span>
<span id="cb27-12"><a href="#cb27-12"></a>  <span class="kw">constexpr</span> T<span class="op">&amp;&amp;</span> <span class="kw">operator</span><span class="op">*()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb27-13"><a href="#cb27-13"></a>    <span class="cf">return</span> move<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>m_value<span class="op">)</span>;</span>
<span id="cb27-14"><a href="#cb27-14"></a>  <span class="op">}</span></span>
<span id="cb27-15"><a href="#cb27-15"></a></span>
<span id="cb27-16"><a href="#cb27-16"></a>  <span class="kw">constexpr</span> T <span class="kw">const</span><span class="op">&amp;&amp;</span></span>
<span id="cb27-17"><a href="#cb27-17"></a>  <span class="kw">operator</span><span class="op">*()</span> <span class="kw">const</span><span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb27-18"><a href="#cb27-18"></a>    <span class="cf">return</span> move<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>m_value<span class="op">)</span>;</span>
<span id="cb27-19"><a href="#cb27-19"></a>  <span class="op">}</span></span>
<span id="cb27-20"><a href="#cb27-20"></a></span>
<span id="cb27-21"><a href="#cb27-21"></a>  <span class="kw">constexpr</span> T<span class="op">&amp;</span> value<span class="op">()</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb27-22"><a href="#cb27-22"></a>    <span class="cf">if</span> <span class="op">(</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb27-23"><a href="#cb27-23"></a>      <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>m_value;</span>
<span id="cb27-24"><a href="#cb27-24"></a>    <span class="op">}</span></span>
<span id="cb27-25"><a href="#cb27-25"></a>    <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb27-26"><a href="#cb27-26"></a>  <span class="op">}</span></span>
<span id="cb27-27"><a href="#cb27-27"></a></span>
<span id="cb27-28"><a href="#cb27-28"></a>  <span class="kw">constexpr</span> T <span class="kw">const</span><span class="op">&amp;</span> value<span class="op">()</span> <span class="kw">const</span><span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb27-29"><a href="#cb27-29"></a>    <span class="cf">if</span> <span class="op">(</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb27-30"><a href="#cb27-30"></a>      <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>m_value;</span>
<span id="cb27-31"><a href="#cb27-31"></a>    <span class="op">}</span></span>
<span id="cb27-32"><a href="#cb27-32"></a>    <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb27-33"><a href="#cb27-33"></a>  <span class="op">}</span></span>
<span id="cb27-34"><a href="#cb27-34"></a></span>
<span id="cb27-35"><a href="#cb27-35"></a>  <span class="kw">constexpr</span> T<span class="op">&amp;&amp;</span> value<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb27-36"><a href="#cb27-36"></a>    <span class="cf">if</span> <span class="op">(</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb27-37"><a href="#cb27-37"></a>      <span class="cf">return</span> move<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>m_value<span class="op">)</span>;</span>
<span id="cb27-38"><a href="#cb27-38"></a>    <span class="op">}</span></span>
<span id="cb27-39"><a href="#cb27-39"></a>    <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb27-40"><a href="#cb27-40"></a>  <span class="op">}</span></span>
<span id="cb27-41"><a href="#cb27-41"></a></span>
<span id="cb27-42"><a href="#cb27-42"></a>  <span class="kw">constexpr</span> T <span class="kw">const</span><span class="op">&amp;&amp;</span> value<span class="op">()</span> <span class="kw">const</span><span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb27-43"><a href="#cb27-43"></a>    <span class="cf">if</span> <span class="op">(</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb27-44"><a href="#cb27-44"></a>      <span class="cf">return</span> move<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>m_value<span class="op">)</span>;</span>
<span id="cb27-45"><a href="#cb27-45"></a>    <span class="op">}</span></span>
<span id="cb27-46"><a href="#cb27-46"></a>    <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb27-47"><a href="#cb27-47"></a>  <span class="op">}</span></span>
<span id="cb27-48"><a href="#cb27-48"></a>  <span class="co">// ...</span></span>
<span id="cb27-49"><a href="#cb27-49"></a><span class="op">}</span>;</span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>  <span class="co">// ...</span></span>
<span id="cb28-4"><a href="#cb28-4"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb28-5"><a href="#cb28-5"></a>  <span class="kw">constexpr</span> like_t<span class="op">&lt;</span>Self, T<span class="op">&gt;&amp;&amp;</span> <span class="kw">operator</span><span class="op">*(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-6"><a href="#cb28-6"></a>    <span class="cf">return</span> forward<span class="op">&lt;</span>Self<span class="op">&gt;(</span>self<span class="op">).</span>m_value;</span>
<span id="cb28-7"><a href="#cb28-7"></a>  <span class="op">}</span></span>
<span id="cb28-8"><a href="#cb28-8"></a></span>
<span id="cb28-9"><a href="#cb28-9"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb28-10"><a href="#cb28-10"></a>  <span class="kw">constexpr</span> like_t<span class="op">&lt;</span>Self, T<span class="op">&gt;&amp;&amp;</span> value<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-11"><a href="#cb28-11"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb28-12"><a href="#cb28-12"></a>      <span class="cf">return</span> forward<span class="op">&lt;</span>Self<span class="op">&gt;(</span>self<span class="op">).</span>m_value;</span>
<span id="cb28-13"><a href="#cb28-13"></a>    <span class="op">}</span></span>
<span id="cb28-14"><a href="#cb28-14"></a>    <span class="cf">throw</span> bad_optional_access<span class="op">()</span>;</span>
<span id="cb28-15"><a href="#cb28-15"></a>  <span class="op">}</span></span>
<span id="cb28-16"><a href="#cb28-16"></a>  <span class="co">// ...</span></span>
<span id="cb28-17"><a href="#cb28-17"></a><span class="op">}</span>;</span></code></pre></div>
</td>
</tr>
<tr>
<td>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb29-3"><a href="#cb29-3"></a>  <span class="co">// ...</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb29-5"><a href="#cb29-5"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> and_then<span class="op">(</span>F<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb29-6"><a href="#cb29-6"></a>    <span class="kw">using</span> result <span class="op">=</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>      invoke_result_t<span class="op">&lt;</span>F, T<span class="op">&amp;&gt;</span>;</span>
<span id="cb29-8"><a href="#cb29-8"></a>    <span class="kw">static_assert</span><span class="op">(</span></span>
<span id="cb29-9"><a href="#cb29-9"></a>      is_optional<span class="op">&lt;</span>result<span class="op">&gt;::</span>value,</span>
<span id="cb29-10"><a href="#cb29-10"></a>      <span class="st">&quot;F must return an optional&quot;</span><span class="op">)</span>;</span>
<span id="cb29-11"><a href="#cb29-11"></a></span>
<span id="cb29-12"><a href="#cb29-12"></a>    <span class="cf">return</span> has_value<span class="op">()</span></span>
<span id="cb29-13"><a href="#cb29-13"></a>        <span class="op">?</span> invoke<span class="op">(</span>forward<span class="op">&lt;</span>F<span class="op">&gt;(</span>f<span class="op">)</span>, <span class="op">**</span><span class="kw">this</span><span class="op">)</span></span>
<span id="cb29-14"><a href="#cb29-14"></a>        <span class="op">:</span> nullopt;</span>
<span id="cb29-15"><a href="#cb29-15"></a>  <span class="op">}</span></span>
<span id="cb29-16"><a href="#cb29-16"></a></span>
<span id="cb29-17"><a href="#cb29-17"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb29-18"><a href="#cb29-18"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> and_then<span class="op">(</span>F<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb29-19"><a href="#cb29-19"></a>    <span class="kw">using</span> result <span class="op">=</span></span>
<span id="cb29-20"><a href="#cb29-20"></a>      invoke_result_t<span class="op">&lt;</span>F, T<span class="op">&amp;&amp;&gt;</span>;</span>
<span id="cb29-21"><a href="#cb29-21"></a>    <span class="kw">static_assert</span><span class="op">(</span></span>
<span id="cb29-22"><a href="#cb29-22"></a>      is_optional<span class="op">&lt;</span>result<span class="op">&gt;::</span>value,</span>
<span id="cb29-23"><a href="#cb29-23"></a>      <span class="st">&quot;F must return an optional&quot;</span><span class="op">)</span>;</span>
<span id="cb29-24"><a href="#cb29-24"></a></span>
<span id="cb29-25"><a href="#cb29-25"></a>    <span class="cf">return</span> has_value<span class="op">()</span></span>
<span id="cb29-26"><a href="#cb29-26"></a>        <span class="op">?</span> invoke<span class="op">(</span>forward<span class="op">&lt;</span>F<span class="op">&gt;(</span>f<span class="op">)</span>,</span>
<span id="cb29-27"><a href="#cb29-27"></a>                 move<span class="op">(**</span><span class="kw">this</span><span class="op">))</span></span>
<span id="cb29-28"><a href="#cb29-28"></a>        <span class="op">:</span> nullopt;</span>
<span id="cb29-29"><a href="#cb29-29"></a>  <span class="op">}</span></span>
<span id="cb29-30"><a href="#cb29-30"></a></span>
<span id="cb29-31"><a href="#cb29-31"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb29-32"><a href="#cb29-32"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> and_then<span class="op">(</span>F<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="kw">const</span><span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb29-33"><a href="#cb29-33"></a>    <span class="kw">using</span> result <span class="op">=</span></span>
<span id="cb29-34"><a href="#cb29-34"></a>      invoke_result_t<span class="op">&lt;</span>F, T <span class="kw">const</span><span class="op">&amp;&gt;</span>;</span>
<span id="cb29-35"><a href="#cb29-35"></a>    <span class="kw">static_assert</span><span class="op">(</span></span>
<span id="cb29-36"><a href="#cb29-36"></a>      is_optional<span class="op">&lt;</span>result<span class="op">&gt;::</span>value,</span>
<span id="cb29-37"><a href="#cb29-37"></a>      <span class="st">&quot;F must return an optional&quot;</span><span class="op">)</span>;</span>
<span id="cb29-38"><a href="#cb29-38"></a></span>
<span id="cb29-39"><a href="#cb29-39"></a>    <span class="cf">return</span> has_value<span class="op">()</span></span>
<span id="cb29-40"><a href="#cb29-40"></a>        <span class="op">?</span> invoke<span class="op">(</span>forward<span class="op">&lt;</span>F<span class="op">&gt;(</span>f<span class="op">)</span>, <span class="op">**</span><span class="kw">this</span><span class="op">)</span></span>
<span id="cb29-41"><a href="#cb29-41"></a>        <span class="op">:</span> nullopt;</span>
<span id="cb29-42"><a href="#cb29-42"></a>  <span class="op">}</span></span>
<span id="cb29-43"><a href="#cb29-43"></a></span>
<span id="cb29-44"><a href="#cb29-44"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb29-45"><a href="#cb29-45"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> and_then<span class="op">(</span>F<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="kw">const</span><span class="op">&amp;&amp;</span> <span class="op">{</span></span>
<span id="cb29-46"><a href="#cb29-46"></a>    <span class="kw">using</span> result <span class="op">=</span></span>
<span id="cb29-47"><a href="#cb29-47"></a>      invoke_result_t<span class="op">&lt;</span>F, T <span class="kw">const</span><span class="op">&amp;&amp;&gt;</span>;</span>
<span id="cb29-48"><a href="#cb29-48"></a>    <span class="kw">static_assert</span><span class="op">(</span></span>
<span id="cb29-49"><a href="#cb29-49"></a>      is_optional<span class="op">&lt;</span>result<span class="op">&gt;::</span>value,</span>
<span id="cb29-50"><a href="#cb29-50"></a>      <span class="st">&quot;F must return an optional&quot;</span><span class="op">)</span>;</span>
<span id="cb29-51"><a href="#cb29-51"></a></span>
<span id="cb29-52"><a href="#cb29-52"></a>    <span class="cf">return</span> has_value<span class="op">()</span></span>
<span id="cb29-53"><a href="#cb29-53"></a>        <span class="op">?</span> invoke<span class="op">(</span>forward<span class="op">&lt;</span>F<span class="op">&gt;(</span>f<span class="op">)</span>,</span>
<span id="cb29-54"><a href="#cb29-54"></a>                 move<span class="op">(**</span><span class="kw">this</span><span class="op">))</span></span>
<span id="cb29-55"><a href="#cb29-55"></a>        <span class="op">:</span> nullopt;</span>
<span id="cb29-56"><a href="#cb29-56"></a>  <span class="op">}</span></span>
<span id="cb29-57"><a href="#cb29-57"></a>  <span class="co">// ...</span></span>
<span id="cb29-58"><a href="#cb29-58"></a><span class="op">}</span>;</span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>  <span class="co">// ...</span></span>
<span id="cb30-4"><a href="#cb30-4"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self, <span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> and_then<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self, F<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-6"><a href="#cb30-6"></a>    <span class="kw">using</span> val <span class="op">=</span> <span class="kw">decltype</span><span class="op">((</span></span>
<span id="cb30-7"><a href="#cb30-7"></a>        forward<span class="op">&lt;</span>Self<span class="op">&gt;(</span>self<span class="op">).</span>m_value<span class="op">))</span>;</span>
<span id="cb30-8"><a href="#cb30-8"></a>    <span class="kw">using</span> result <span class="op">=</span> invoke_result_t<span class="op">&lt;</span>F, val<span class="op">&gt;</span>;</span>
<span id="cb30-9"><a href="#cb30-9"></a></span>
<span id="cb30-10"><a href="#cb30-10"></a>    <span class="kw">static_assert</span><span class="op">(</span></span>
<span id="cb30-11"><a href="#cb30-11"></a>      is_optional<span class="op">&lt;</span>result<span class="op">&gt;::</span>value,</span>
<span id="cb30-12"><a href="#cb30-12"></a>      <span class="st">&quot;F must return an optional&quot;</span><span class="op">)</span>;</span>
<span id="cb30-13"><a href="#cb30-13"></a></span>
<span id="cb30-14"><a href="#cb30-14"></a>    <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>has_value<span class="op">()</span></span>
<span id="cb30-15"><a href="#cb30-15"></a>        <span class="op">?</span> invoke<span class="op">(</span>forward<span class="op">&lt;</span>F<span class="op">&gt;(</span>f<span class="op">)</span>,</span>
<span id="cb30-16"><a href="#cb30-16"></a>                 forward<span class="op">&lt;</span>Self<span class="op">&gt;(</span>self<span class="op">).</span>m_value<span class="op">)</span></span>
<span id="cb30-17"><a href="#cb30-17"></a>        <span class="op">:</span> nullopt;</span>
<span id="cb30-18"><a href="#cb30-18"></a>  <span class="op">}</span></span>
<span id="cb30-19"><a href="#cb30-19"></a>  <span class="co">// ...</span></span>
<span id="cb30-20"><a href="#cb30-20"></a><span class="op">}</span>;</span></code></pre></div>
</td>
</tr>
</table>
<p>There are a few more functions in <span class="citation" data-cites="P0798R0">[<a href="#ref-P0798R0" role="doc-biblioref">P0798R0</a>]</span> responsible for this explosion of overloads, so the difference in both code and clarity is dramatic.</p>
<p>For those that dislike returning auto in these cases, it is easy to write a metafunction matching the appropriate qualifiers from a type. It is certainly a better option than blindly copying and pasting code, hoping that the minor changes were made correctly in each case.</p>
<h2 data-number="5.2" id="crtp" data-number="5.2"><span class="header-section-number">5.2</span> CRTP, without the C, R, or even T<a href="#crtp" class="self-link"></a></h2>
<p>Today, a common design pattern is the Curiously Recurring Template Pattern. This implies passing the derived type as a template parameter to a base class template as a way of achieving static polymorphism. If we wanted to simply outsource implementing postfix incrementation to a base, we could use CRTP for that. But with explicit objects that already deduce to the derived objects, we don’t need any curious recurrence — we can use standard inheritance and let deduction do its thing. The base class doesn’t even need to be a template:</p>
<table style="width:100%">
<tr>
<th style="width:50%">
C++17
</th>
<th style="width:50%">
Proposed
</th>
</tr>
<tr>
<td>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Derived<span class="op">&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="kw">struct</span> add_postfix_increment <span class="op">{</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>    Derived <span class="kw">operator</span><span class="op">++(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>        <span class="kw">auto</span><span class="op">&amp;</span> self <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span>Derived<span class="op">&amp;&gt;(*</span><span class="kw">this</span><span class="op">)</span>;</span>
<span id="cb31-5"><a href="#cb31-5"></a></span>
<span id="cb31-6"><a href="#cb31-6"></a>        Derived tmp<span class="op">(</span>self<span class="op">)</span>;</span>
<span id="cb31-7"><a href="#cb31-7"></a>        <span class="op">++</span>self;</span>
<span id="cb31-8"><a href="#cb31-8"></a>        <span class="cf">return</span> tmp;</span>
<span id="cb31-9"><a href="#cb31-9"></a>    <span class="op">}</span></span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="op">}</span>;</span>
<span id="cb31-11"><a href="#cb31-11"></a></span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="kw">struct</span> some_type <span class="op">:</span> add_postfix_increment<span class="op">&lt;</span>some_type<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb31-13"><a href="#cb31-13"></a>    some_type<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">++()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb31-14"><a href="#cb31-14"></a><span class="op">}</span>;</span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">struct</span> add_postfix_increment <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">++(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self, <span class="dt">int</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>        <span class="kw">auto</span> tmp <span class="op">=</span> self;</span>
<span id="cb32-5"><a href="#cb32-5"></a>        <span class="op">++</span>self;</span>
<span id="cb32-6"><a href="#cb32-6"></a>        <span class="cf">return</span> tmp;</span>
<span id="cb32-7"><a href="#cb32-7"></a>    <span class="op">}</span></span>
<span id="cb32-8"><a href="#cb32-8"></a><span class="op">}</span>;</span>
<span id="cb32-9"><a href="#cb32-9"></a></span>
<span id="cb32-10"><a href="#cb32-10"></a></span>
<span id="cb32-11"><a href="#cb32-11"></a></span>
<span id="cb32-12"><a href="#cb32-12"></a><span class="kw">struct</span> some_type <span class="op">:</span> add_postfix_increment <span class="op">{</span></span>
<span id="cb32-13"><a href="#cb32-13"></a>    some_type<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">++()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb32-14"><a href="#cb32-14"></a><span class="op">}</span>;</span></code></pre></div>
</td>
</tr>
</table>
<p>The proposed examples aren’t much shorter, but they are certainly simpler by comparison.</p>
<h3 data-number="5.2.1" id="builder-pattern" data-number="5.2.1"><span class="header-section-number">5.2.1</span> Builder pattern<a href="#builder-pattern" class="self-link"></a></h3>
<p>Once we start to do any more with CRTP, complexity quickly increases, whereas with this proposal, it stays remarkably low.</p>
<p>Let’s say we have a builder that does multiple things. We might start with:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">struct</span> Builder <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2"></a>  Builder<span class="op">&amp;</span> a<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb33-3"><a href="#cb33-3"></a>  Builder<span class="op">&amp;</span> b<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>  Builder<span class="op">&amp;</span> c<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="op">}</span>;</span>
<span id="cb33-6"><a href="#cb33-6"></a></span>
<span id="cb33-7"><a href="#cb33-7"></a>Builder<span class="op">().</span>a<span class="op">().</span>b<span class="op">().</span>a<span class="op">().</span>b<span class="op">().</span>c<span class="op">()</span>;</span></code></pre></div>
<p>But now we want to create a specialized builder with new operations <code class="sourceCode cpp">d<span class="op">()</span></code> and <code class="sourceCode cpp">e<span class="op">()</span></code>. This specialized builder needs new member functions, and we don’t want to burden existing users with them. We also want <code class="sourceCode cpp">Special<span class="op">().</span>a<span class="op">().</span>d<span class="op">()</span></code> to work, so we need to use CRTP to <em>conditionally</em> return either a <code class="sourceCode cpp">Builder<span class="op">&amp;</span></code> or a <code class="sourceCode cpp">Special<span class="op">&amp;</span></code>:</p>
<table style="width:100%">
<tr>
<th style="width:50%">
C++17
</th>
<th style="width:50%">
Proposed
</th>
</tr>
<tr>
<td>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> D<span class="op">=</span><span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="kw">class</span> Builder <span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3"></a>  <span class="kw">using</span> Derived <span class="op">=</span> conditional_t<span class="op">&lt;</span>is_void_v<span class="op">&lt;</span>D<span class="op">&gt;</span>, Builder, D<span class="op">&gt;</span>;</span>
<span id="cb34-4"><a href="#cb34-4"></a>  Derived<span class="op">&amp;</span> self<span class="op">()</span> <span class="op">{</span></span>
<span id="cb34-5"><a href="#cb34-5"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">static_cast</span><span class="op">&lt;</span>Derived<span class="op">*&gt;(</span><span class="kw">this</span><span class="op">)</span>;</span>
<span id="cb34-6"><a href="#cb34-6"></a>  <span class="op">}</span></span>
<span id="cb34-7"><a href="#cb34-7"></a></span>
<span id="cb34-8"><a href="#cb34-8"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb34-9"><a href="#cb34-9"></a>  Derived<span class="op">&amp;</span> a<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb34-10"><a href="#cb34-10"></a>  Derived<span class="op">&amp;</span> b<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb34-11"><a href="#cb34-11"></a>  Derived<span class="op">&amp;</span> c<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb34-12"><a href="#cb34-12"></a><span class="op">}</span>;</span>
<span id="cb34-13"><a href="#cb34-13"></a></span>
<span id="cb34-14"><a href="#cb34-14"></a><span class="kw">struct</span> Special <span class="op">:</span> Builder<span class="op">&lt;</span>Special<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb34-15"><a href="#cb34-15"></a>  Special<span class="op">&amp;</span> d<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb34-16"><a href="#cb34-16"></a>  Special<span class="op">&amp;</span> e<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb34-17"><a href="#cb34-17"></a><span class="op">}</span>;</span>
<span id="cb34-18"><a href="#cb34-18"></a></span>
<span id="cb34-19"><a href="#cb34-19"></a>Builder<span class="op">().</span>a<span class="op">().</span>b<span class="op">().</span>a<span class="op">().</span>b<span class="op">().</span>c<span class="op">()</span>;</span>
<span id="cb34-20"><a href="#cb34-20"></a>Special<span class="op">().</span>a<span class="op">().</span>d<span class="op">().</span>e<span class="op">().</span>a<span class="op">()</span>;</span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">struct</span> Builder <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb35-3"><a href="#cb35-3"></a>    Self<span class="op">&amp;</span> a<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self; <span class="op">}</span></span>
<span id="cb35-4"><a href="#cb35-4"></a></span>
<span id="cb35-5"><a href="#cb35-5"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb35-6"><a href="#cb35-6"></a>    Self<span class="op">&amp;</span> b<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self; <span class="op">}</span></span>
<span id="cb35-7"><a href="#cb35-7"></a></span>
<span id="cb35-8"><a href="#cb35-8"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb35-9"><a href="#cb35-9"></a>    Self<span class="op">&amp;</span> c<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self; <span class="op">}</span></span>
<span id="cb35-10"><a href="#cb35-10"></a><span class="op">}</span>;</span>
<span id="cb35-11"><a href="#cb35-11"></a></span>
<span id="cb35-12"><a href="#cb35-12"></a><span class="kw">struct</span> Special <span class="op">:</span> Builder <span class="op">{</span></span>
<span id="cb35-13"><a href="#cb35-13"></a>    Special<span class="op">&amp;</span> d<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb35-14"><a href="#cb35-14"></a>    Special<span class="op">&amp;</span> e<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb35-15"><a href="#cb35-15"></a><span class="op">}</span>;</span>
<span id="cb35-16"><a href="#cb35-16"></a></span>
<span id="cb35-17"><a href="#cb35-17"></a>Builder<span class="op">().</span>a<span class="op">().</span>b<span class="op">().</span>a<span class="op">().</span>b<span class="op">().</span>c<span class="op">()</span>;</span>
<span id="cb35-18"><a href="#cb35-18"></a>Special<span class="op">().</span>a<span class="op">().</span>d<span class="op">().</span>e<span class="op">().</span>a<span class="op">()</span>;</span></code></pre></div>
</td>
</tr>
</table>
<p>The code on the right is dramatically easier to understand and therefore more accessible to more programmers than the code on the left.</p>
<p>But wait! There’s more!</p>
<p>What if we added a <em>super</em>-specialized builder, a more special form of <code class="sourceCode cpp">Special</code>? Now we need <code class="sourceCode cpp">Special</code> to opt-in to CRTP so that it knows which type to pass to <code class="sourceCode cpp">Builder</code>, ensuring that everything in the hierarchy returns the correct type. It’s about this point that most programmers would give up. But with this proposal, there’s no problem!</p>
<table style="width:100%">
<tr>
<th style="width:50%">
C++17
</th>
<th style="width:50%">
Proposed
</th>
</tr>
<tr>
<td>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> D<span class="op">=</span><span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="kw">class</span> Builder <span class="op">{</span></span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb36-4"><a href="#cb36-4"></a>  <span class="kw">using</span> Derived <span class="op">=</span> conditional_t<span class="op">&lt;</span>is_void_v<span class="op">&lt;</span>D<span class="op">&gt;</span>, Builder, D<span class="op">&gt;</span>;</span>
<span id="cb36-5"><a href="#cb36-5"></a>  Derived<span class="op">&amp;</span> self<span class="op">()</span> <span class="op">{</span></span>
<span id="cb36-6"><a href="#cb36-6"></a>    <span class="cf">return</span> <span class="op">*</span><span class="kw">static_cast</span><span class="op">&lt;</span>Derived<span class="op">*&gt;(</span><span class="kw">this</span><span class="op">)</span>;</span>
<span id="cb36-7"><a href="#cb36-7"></a>  <span class="op">}</span></span>
<span id="cb36-8"><a href="#cb36-8"></a></span>
<span id="cb36-9"><a href="#cb36-9"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb36-10"><a href="#cb36-10"></a>  Derived<span class="op">&amp;</span> a<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb36-11"><a href="#cb36-11"></a>  Derived<span class="op">&amp;</span> b<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb36-12"><a href="#cb36-12"></a>  Derived<span class="op">&amp;</span> c<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb36-13"><a href="#cb36-13"></a><span class="op">}</span>;</span>
<span id="cb36-14"><a href="#cb36-14"></a></span>
<span id="cb36-15"><a href="#cb36-15"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> D<span class="op">=</span><span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb36-16"><a href="#cb36-16"></a><span class="kw">struct</span> Special</span>
<span id="cb36-17"><a href="#cb36-17"></a>  <span class="op">:</span> Builder<span class="op">&lt;</span>conditional_t<span class="op">&lt;</span>is_void_v<span class="op">&lt;</span>D<span class="op">&gt;</span>,Special<span class="op">&lt;</span>D<span class="op">&gt;</span>,D<span class="op">&gt;</span></span>
<span id="cb36-18"><a href="#cb36-18"></a><span class="op">{</span></span>
<span id="cb36-19"><a href="#cb36-19"></a>  <span class="kw">using</span> Derived <span class="op">=</span> <span class="kw">typename</span> Special<span class="op">::</span>Builder<span class="op">::</span>Derived;</span>
<span id="cb36-20"><a href="#cb36-20"></a>  Derived<span class="op">&amp;</span> d<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>self<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb36-21"><a href="#cb36-21"></a>  Derived<span class="op">&amp;</span> e<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>self<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb36-22"><a href="#cb36-22"></a><span class="op">}</span>;</span>
<span id="cb36-23"><a href="#cb36-23"></a></span>
<span id="cb36-24"><a href="#cb36-24"></a><span class="kw">struct</span> Super <span class="op">:</span> Special<span class="op">&lt;</span>Super<span class="op">&gt;</span></span>
<span id="cb36-25"><a href="#cb36-25"></a><span class="op">{</span></span>
<span id="cb36-26"><a href="#cb36-26"></a>    Super<span class="op">&amp;</span> f<span class="op">()</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span>; <span class="op">}</span></span>
<span id="cb36-27"><a href="#cb36-27"></a><span class="op">}</span>;</span>
<span id="cb36-28"><a href="#cb36-28"></a></span>
<span id="cb36-29"><a href="#cb36-29"></a>Builder<span class="op">().</span>a<span class="op">().</span>b<span class="op">().</span>a<span class="op">().</span>b<span class="op">().</span>c<span class="op">()</span>;</span>
<span id="cb36-30"><a href="#cb36-30"></a>Special<span class="op">().</span>a<span class="op">().</span>d<span class="op">().</span>e<span class="op">().</span>a<span class="op">()</span>;</span>
<span id="cb36-31"><a href="#cb36-31"></a>Super<span class="op">().</span>a<span class="op">().</span>d<span class="op">().</span>f<span class="op">().</span>e<span class="op">()</span>;</span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">struct</span> Builder <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb37-3"><a href="#cb37-3"></a>    Self<span class="op">&amp;</span> a<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self; <span class="op">}</span></span>
<span id="cb37-4"><a href="#cb37-4"></a></span>
<span id="cb37-5"><a href="#cb37-5"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb37-6"><a href="#cb37-6"></a>    Self<span class="op">&amp;</span> b<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self; <span class="op">}</span></span>
<span id="cb37-7"><a href="#cb37-7"></a></span>
<span id="cb37-8"><a href="#cb37-8"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb37-9"><a href="#cb37-9"></a>    Self<span class="op">&amp;</span> c<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self; <span class="op">}</span></span>
<span id="cb37-10"><a href="#cb37-10"></a><span class="op">}</span>;</span>
<span id="cb37-11"><a href="#cb37-11"></a></span>
<span id="cb37-12"><a href="#cb37-12"></a><span class="kw">struct</span> Special <span class="op">:</span> Builder <span class="op">{</span></span>
<span id="cb37-13"><a href="#cb37-13"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb37-14"><a href="#cb37-14"></a>    Self<span class="op">&amp;</span> d<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self; <span class="op">}</span></span>
<span id="cb37-15"><a href="#cb37-15"></a></span>
<span id="cb37-16"><a href="#cb37-16"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb37-17"><a href="#cb37-17"></a>    Self<span class="op">&amp;</span> e<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self; <span class="op">}</span></span>
<span id="cb37-18"><a href="#cb37-18"></a><span class="op">}</span>;</span>
<span id="cb37-19"><a href="#cb37-19"></a></span>
<span id="cb37-20"><a href="#cb37-20"></a><span class="kw">struct</span> Super <span class="op">:</span> Special <span class="op">{</span></span>
<span id="cb37-21"><a href="#cb37-21"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self<span class="op">&gt;</span></span>
<span id="cb37-22"><a href="#cb37-22"></a>    Self<span class="op">&amp;</span> f<span class="op">(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self<span class="op">)</span> <span class="op">{</span> <span class="co">/* ... */</span>; <span class="cf">return</span> self; <span class="op">}</span></span>
<span id="cb37-23"><a href="#cb37-23"></a><span class="op">}</span>;</span>
<span id="cb37-24"><a href="#cb37-24"></a></span>
<span id="cb37-25"><a href="#cb37-25"></a>Builder<span class="op">().</span>a<span class="op">().</span>b<span class="op">().</span>a<span class="op">().</span>b<span class="op">().</span>c<span class="op">()</span>;</span>
<span id="cb37-26"><a href="#cb37-26"></a>Special<span class="op">().</span>a<span class="op">().</span>d<span class="op">().</span>e<span class="op">().</span>a<span class="op">()</span>;</span>
<span id="cb37-27"><a href="#cb37-27"></a>Super<span class="op">().</span>a<span class="op">().</span>d<span class="op">().</span>f<span class="op">().</span>e<span class="op">()</span>;</span></code></pre></div>
</td>
</tr>
</table>
<p>The code on the right is much easier in all contexts. There are so many situations where this idiom, if available, would give programmers a better solution for problems that they cannot easily solve today.</p>
<p>Note that the <code class="sourceCode cpp">Super</code> implementations with this proposal opt-in to further derivation, since it’s a no-brainer at this point.</p>
<h2 data-number="5.3" id="recursive-lambdas" data-number="5.3"><span class="header-section-number">5.3</span> Recursive Lambdas<a href="#recursive-lambdas" class="self-link"></a></h2>
<p>The explicit object parameter syntax offers an alternative solution to implementing a recursive lambda as compared to <span class="citation" data-cites="P0839R0">[<a href="#ref-P0839R0" role="doc-biblioref">P0839R0</a>]</span>, since now we’ve opened up the possibility of allowing a lambda to reference itself. To do this, we need a way to <em>name</em> the lambda.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a><span class="co">// as proposed in P0839</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="kw">auto</span> fib <span class="op">=</span> <span class="op">[]</span> self <span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb38-3"><a href="#cb38-3"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> n;</span>
<span id="cb38-4"><a href="#cb38-4"></a>    <span class="cf">return</span> self<span class="op">(</span>n<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">+</span> self<span class="op">(</span>n<span class="op">-</span><span class="dv">2</span><span class="op">)</span>;</span>
<span id="cb38-5"><a href="#cb38-5"></a><span class="op">}</span>;</span>
<span id="cb38-6"><a href="#cb38-6"></a></span>
<span id="cb38-7"><a href="#cb38-7"></a><span class="co">// this proposal</span></span>
<span id="cb38-8"><a href="#cb38-8"></a><span class="kw">auto</span> fib <span class="op">=</span> <span class="op">[](</span><span class="kw">this</span> <span class="kw">auto</span> <span class="kw">const</span><span class="op">&amp;</span> self, <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb38-9"><a href="#cb38-9"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> n;</span>
<span id="cb38-10"><a href="#cb38-10"></a>    <span class="cf">return</span> self<span class="op">(</span>n<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">+</span> self<span class="op">(</span>n<span class="op">-</span><span class="dv">2</span><span class="op">)</span>;</span>
<span id="cb38-11"><a href="#cb38-11"></a><span class="op">}</span>;</span></code></pre></div>
<p>This works by following the established rules. The call operator of the closure object can also have an explicit object parameter, so in this example, <code class="sourceCode cpp">self</code> is the closure object.</p>
<p>In San Diego, issues of implementability were raised. The proposal ends up being implementable. See <a href="#faq-rec-lambda-impl">the lambda FAQ entry</a> for details.</p>
<p>Combine this with the new style of mixins allowing us to automatically deduce the most derived object, and you get the following example — a simple recursive lambda that counts the number of leaves in a tree.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">struct</span> Node;</span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="kw">using</span> Tree <span class="op">=</span> variant<span class="op">&lt;</span>Leaf, Node<span class="op">*&gt;</span>;</span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb39-4"><a href="#cb39-4"></a>    Tree left;</span>
<span id="cb39-5"><a href="#cb39-5"></a>    Tree right;</span>
<span id="cb39-6"><a href="#cb39-6"></a><span class="op">}</span>;</span>
<span id="cb39-7"><a href="#cb39-7"></a></span>
<span id="cb39-8"><a href="#cb39-8"></a><span class="dt">int</span> num_leaves<span class="op">(</span>Tree <span class="kw">const</span><span class="op">&amp;</span> tree<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-9"><a href="#cb39-9"></a>    <span class="cf">return</span> visit<span class="op">(</span>overload<span class="op">(</span>        <span class="co">// &lt;-----------------------------------+</span></span>
<span id="cb39-10"><a href="#cb39-10"></a>        <span class="op">[](</span>Leaf <span class="kw">const</span><span class="op">&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span>; <span class="op">}</span>,                           <span class="co">//      |</span></span>
<span id="cb39-11"><a href="#cb39-11"></a>        <span class="op">[](</span><span class="kw">this</span> <span class="kw">auto</span> <span class="kw">const</span><span class="op">&amp;</span> self, Node<span class="op">*</span> n<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span>              <span class="co">//      |</span></span>
<span id="cb39-12"><a href="#cb39-12"></a>            <span class="cf">return</span> visit<span class="op">(</span>self, n<span class="op">-&gt;</span>left<span class="op">)</span> <span class="op">+</span> visit<span class="op">(</span>self, n<span class="op">-&gt;</span>right<span class="op">)</span>; <span class="co">// &lt;----+</span></span>
<span id="cb39-13"><a href="#cb39-13"></a>        <span class="op">}</span></span>
<span id="cb39-14"><a href="#cb39-14"></a>    <span class="op">)</span>, tree<span class="op">)</span>;</span>
<span id="cb39-15"><a href="#cb39-15"></a><span class="op">}</span></span></code></pre></div>
<p>In the calls to <code class="sourceCode cpp">visit</code>, <code class="sourceCode cpp">self</code> isn’t the lambda; <code class="sourceCode cpp">self</code> is the <code class="sourceCode cpp">overload</code> wrapper. This works straight out of the box.</p>
<h2 data-number="5.4" id="by-value-member-functions" data-number="5.4"><span class="header-section-number">5.4</span> By-value member functions<a href="#by-value-member-functions" class="self-link"></a></h2>
<p>This section presents some of the cases for by-value member functions.</p>
<h3 data-number="5.4.1" id="move-into-parameter" data-number="5.4.1"><span class="header-section-number">5.4.1</span> For move-into-parameter chaining<a href="#move-into-parameter" class="self-link"></a></h3>
<p>Say you wanted to provide a <code class="sourceCode cpp"><span class="op">.</span>sorted<span class="op">()</span></code> method on a data structure. Such a method naturally wants to operate on a copy. Taking the parameter by value will cleanly and correctly move into the parameter if the original object is an rvalue without requiring templates.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">struct</span> my_vector <span class="op">:</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>  <span class="kw">auto</span> sorted<span class="op">(</span><span class="kw">this</span> my_vector self<span class="op">)</span> <span class="op">-&gt;</span> my_vector <span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>    sort<span class="op">(</span>self<span class="op">.</span>begin<span class="op">()</span>, self<span class="op">.</span>end<span class="op">())</span>;</span>
<span id="cb40-4"><a href="#cb40-4"></a>    <span class="cf">return</span> self;</span>
<span id="cb40-5"><a href="#cb40-5"></a>  <span class="op">}</span></span>
<span id="cb40-6"><a href="#cb40-6"></a><span class="op">}</span>;</span></code></pre></div>
<h3 data-number="5.4.2" id="by-value-member-functions-for-performance" data-number="5.4.2"><span class="header-section-number">5.4.2</span> For performance<a href="#by-value-member-functions-for-performance" class="self-link"></a></h3>
<p>It’s been established that if you want the best performance, you should pass small types by value to avoid an indirection penalty. One such small type is <code class="sourceCode cpp">std<span class="op">::</span>string_view</code>. <a href="https://abseil.io/tips/1">Abseil Tip #1</a> for instance, states:</p>
<blockquote>
<p>Unlike other string types, you should pass <code class="sourceCode cpp">string_view</code> by value just like you would an <code class="sourceCode cpp"><span class="dt">int</span></code> or a <code class="sourceCode cpp"><span class="dt">double</span></code> because <code class="sourceCode cpp">string_view</code> is a small value.</p>
</blockquote>
<p>There is, however, one place today where you simply <em>cannot</em> pass types like <code class="sourceCode cpp">string_view</code> by value: to their own member functions. The implicit object parameter is always a reference, so any such member functions that do not get inlined incur a double indirection.</p>
<p>As an easy performance optimization, any member function of small types that does not perform any modifications can take the object parameter by value. Here is an example of some member functions of <code class="sourceCode cpp">basic_string_view</code> assuming that we are just using <code class="sourceCode cpp">charT <span class="kw">const</span><span class="op">*</span></code> as <code class="sourceCode cpp">iterator</code>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> charT, <span class="kw">class</span> traits <span class="op">=</span> char_traits<span class="op">&lt;</span>charT<span class="op">&gt;&gt;</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="kw">class</span> basic_string_view <span class="op">{</span></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb41-4"><a href="#cb41-4"></a>    const_pointer data_;</span>
<span id="cb41-5"><a href="#cb41-5"></a>    size_type size_;</span>
<span id="cb41-6"><a href="#cb41-6"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb41-7"><a href="#cb41-7"></a>    <span class="kw">constexpr</span> const_iterator begin<span class="op">(</span><span class="kw">this</span> basic_string_view self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-8"><a href="#cb41-8"></a>        <span class="cf">return</span> self<span class="op">.</span>data_;</span>
<span id="cb41-9"><a href="#cb41-9"></a>    <span class="op">}</span></span>
<span id="cb41-10"><a href="#cb41-10"></a></span>
<span id="cb41-11"><a href="#cb41-11"></a>    <span class="kw">constexpr</span> const_iterator end<span class="op">(</span><span class="kw">this</span> basic_string_view self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-12"><a href="#cb41-12"></a>        <span class="cf">return</span> self<span class="op">.</span>data_ <span class="op">+</span> self<span class="op">.</span>size_;</span>
<span id="cb41-13"><a href="#cb41-13"></a>    <span class="op">}</span></span>
<span id="cb41-14"><a href="#cb41-14"></a></span>
<span id="cb41-15"><a href="#cb41-15"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> size<span class="op">(</span><span class="kw">this</span> basic_string_view self<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-16"><a href="#cb41-16"></a>        <span class="cf">return</span> self<span class="op">.</span>size_;</span>
<span id="cb41-17"><a href="#cb41-17"></a>    <span class="op">}</span></span>
<span id="cb41-18"><a href="#cb41-18"></a></span>
<span id="cb41-19"><a href="#cb41-19"></a>    <span class="kw">constexpr</span> const_reference <span class="kw">operator</span><span class="op">[](</span><span class="kw">this</span> basic_string_view self, size_type pos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-20"><a href="#cb41-20"></a>        <span class="cf">return</span> self<span class="op">.</span>data_<span class="op">[</span>pos<span class="op">]</span>;</span>
<span id="cb41-21"><a href="#cb41-21"></a>    <span class="op">}</span></span>
<span id="cb41-22"><a href="#cb41-22"></a><span class="op">}</span>;</span></code></pre></div>
<p>Most of the member functions can be rewritten this way for a free performance boost.</p>
<p>The same can be said for types that aren’t only cheap to copy, but have no state at all. Compare these two implementations of <code class="sourceCode cpp">less_than</code>:</p>
<table style="width:100%">
<tr>
<th style="width:50%">
C++17
</th>
<th style="width:50%">
Proposed
</th>
</tr>
<tr>
<td>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">struct</span> less_than <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb42-3"><a href="#cb42-3"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">()(</span>T <span class="kw">const</span><span class="op">&amp;</span> lhs, U <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-4"><a href="#cb42-4"></a>    <span class="cf">return</span> lhs <span class="op">&lt;</span> rhs;</span>
<span id="cb42-5"><a href="#cb42-5"></a>  <span class="op">}</span></span>
<span id="cb42-6"><a href="#cb42-6"></a><span class="op">}</span>;</span></code></pre></div>
</td>
<td>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">struct</span> less_than <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T, <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb43-3"><a href="#cb43-3"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">this</span> less_than,</span>
<span id="cb43-4"><a href="#cb43-4"></a>          T <span class="kw">const</span><span class="op">&amp;</span> lhs, U <span class="kw">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-5"><a href="#cb43-5"></a>    <span class="cf">return</span> lhs <span class="op">&lt;</span> rhs;</span>
<span id="cb43-6"><a href="#cb43-6"></a>  <span class="op">}</span></span>
<span id="cb43-7"><a href="#cb43-7"></a><span class="op">}</span>;</span></code></pre></div>
</td>
</tr>
</table>
<p>In C++17, invoking <code class="sourceCode cpp">less_than<span class="op">()(</span>x, y<span class="op">)</span></code> still requires an implicit reference to the <code class="sourceCode cpp">less_than</code> object — completely unnecessary work when copying it is free. The compiler knows it doesn’t have to do anything. We <em>want</em> to pass <code class="sourceCode cpp">less_than</code> by value here. Indeed, this specific situation is the main motivation for <span class="citation" data-cites="P1169R0">[<a href="#ref-P1169R0" role="doc-biblioref">P1169R0</a>]</span>.</p>
<h2 data-number="5.5" id="sfinae-friendly-callables" data-number="5.5"><span class="header-section-number">5.5</span> SFINAE-friendly callables<a href="#sfinae-friendly-callables" class="self-link"></a></h2>
<p>A seemingly unrelated problem to the question of code quadruplication is that of writing numerous overloads for function wrappers, as demonstrated in <span class="citation" data-cites="P0826R0">[<a href="#ref-P0826R0" role="doc-biblioref">P0826R0</a>]</span>. Consider what happens if we implement <code class="sourceCode cpp">std<span class="op">::</span>not_fn<span class="op">()</span></code> as currently specified:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="kw">class</span> call_wrapper <span class="op">{</span></span>
<span id="cb44-3"><a href="#cb44-3"></a>    F f;</span>
<span id="cb44-4"><a href="#cb44-4"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb44-5"><a href="#cb44-5"></a>    <span class="co">// ...</span></span>
<span id="cb44-6"><a href="#cb44-6"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb44-7"><a href="#cb44-7"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>Args<span class="op">&amp;&amp;...</span> <span class="op">)</span> <span class="op">&amp;</span></span>
<span id="cb44-8"><a href="#cb44-8"></a>        <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(!</span>declval<span class="op">&lt;</span>invoke_result_t<span class="op">&lt;</span>F<span class="op">&amp;</span>, Args<span class="op">...&gt;&gt;())</span>;</span>
<span id="cb44-9"><a href="#cb44-9"></a></span>
<span id="cb44-10"><a href="#cb44-10"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb44-11"><a href="#cb44-11"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>Args<span class="op">&amp;&amp;...</span> <span class="op">)</span> <span class="kw">const</span><span class="op">&amp;</span></span>
<span id="cb44-12"><a href="#cb44-12"></a>        <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(!</span>declval<span class="op">&lt;</span>invoke_result_t<span class="op">&lt;</span>F <span class="kw">const</span><span class="op">&amp;</span>, Args<span class="op">...&gt;&gt;())</span>;</span>
<span id="cb44-13"><a href="#cb44-13"></a></span>
<span id="cb44-14"><a href="#cb44-14"></a>    <span class="co">// ... same for &amp;&amp; and const &amp;&amp; ...</span></span>
<span id="cb44-15"><a href="#cb44-15"></a><span class="op">}</span>;</span>
<span id="cb44-16"><a href="#cb44-16"></a></span>
<span id="cb44-17"><a href="#cb44-17"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb44-18"><a href="#cb44-18"></a><span class="kw">auto</span> not_fn<span class="op">(</span>F<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-19"><a href="#cb44-19"></a>    <span class="cf">return</span> call_wrapper<span class="op">&lt;</span>decay_t<span class="op">&lt;</span>F<span class="op">&gt;&gt;{</span>forward<span class="op">&lt;</span>F<span class="op">&gt;(</span>f<span class="op">)}</span>;</span>
<span id="cb44-20"><a href="#cb44-20"></a><span class="op">}</span></span></code></pre></div>
<p>As described in the paper, this implementation has two pathological cases: one in which the callable is SFINAE-unfriendly, causing the call to be ill-formed where it would otherwise work; and one in which overload is deleted, causing the call to fall back to a different overload when it should fail instead:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1"></a><span class="kw">struct</span> unfriendly <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb45-3"><a href="#cb45-3"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>T v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-4"><a href="#cb45-4"></a>        <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span>T, <span class="dt">int</span><span class="op">&gt;)</span>;</span>
<span id="cb45-5"><a href="#cb45-5"></a>        <span class="cf">return</span> v;</span>
<span id="cb45-6"><a href="#cb45-6"></a>    <span class="op">}</span></span>
<span id="cb45-7"><a href="#cb45-7"></a></span>
<span id="cb45-8"><a href="#cb45-8"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb45-9"><a href="#cb45-9"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>T v<span class="op">)</span> <span class="kw">const</span> <span class="op">{</span></span>
<span id="cb45-10"><a href="#cb45-10"></a>        <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span>T, <span class="dt">double</span><span class="op">&gt;)</span>;</span>
<span id="cb45-11"><a href="#cb45-11"></a>        <span class="cf">return</span> v;</span>
<span id="cb45-12"><a href="#cb45-12"></a>    <span class="op">}</span></span>
<span id="cb45-13"><a href="#cb45-13"></a><span class="op">}</span>;</span>
<span id="cb45-14"><a href="#cb45-14"></a></span>
<span id="cb45-15"><a href="#cb45-15"></a><span class="kw">struct</span> fun <span class="op">{</span></span>
<span id="cb45-16"><a href="#cb45-16"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb45-17"><a href="#cb45-17"></a>    <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>Args<span class="op">&amp;&amp;...)</span> <span class="op">=</span> <span class="kw">delete</span>;</span>
<span id="cb45-18"><a href="#cb45-18"></a></span>
<span id="cb45-19"><a href="#cb45-19"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb45-20"><a href="#cb45-20"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">()(</span>Args<span class="op">&amp;&amp;...)</span> <span class="kw">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">true</span>; <span class="op">}</span></span>
<span id="cb45-21"><a href="#cb45-21"></a><span class="op">}</span>;</span>
<span id="cb45-22"><a href="#cb45-22"></a></span>
<span id="cb45-23"><a href="#cb45-23"></a>std<span class="op">::</span>not_fn<span class="op">(</span>unfriendly<span class="op">{})(</span><span class="dv">1</span><span class="op">)</span>; <span class="co">// static assert!</span></span>
<span id="cb45-24"><a href="#cb45-24"></a>                              <span class="co">// even though the non-const overload is viable and would be the</span></span>
<span id="cb45-25"><a href="#cb45-25"></a>                              <span class="co">// best match, during overload resolution, both overloads of</span></span>
<span id="cb45-26"><a href="#cb45-26"></a>                              <span class="co">// unfriendly have to be instantiated - and the second one is a</span></span>
<span id="cb45-27"><a href="#cb45-27"></a>                              <span class="co">// hard compile error.</span></span>
<span id="cb45-28"><a href="#cb45-28"></a></span>
<span id="cb45-29"><a href="#cb45-29"></a>std<span class="op">::</span>not_fn<span class="op">(</span>fun<span class="op">{})()</span>;         <span class="co">// ok!? Returns false</span></span>
<span id="cb45-30"><a href="#cb45-30"></a>                              <span class="co">// even though we want the non-const overload to be deleted, the</span></span>
<span id="cb45-31"><a href="#cb45-31"></a>                              <span class="co">// const overload of the call_wrapper ends up being viable - and</span></span>
<span id="cb45-32"><a href="#cb45-32"></a>                              <span class="co">// the only viable candidate.</span></span></code></pre></div>
<p>Gracefully handling SFINAE-unfriendly callables is <strong>not solvable</strong> in C++ today. Preventing fallback can be solved by the addition of another four overloads, so that each of the four <em>cv</em>/ref-qualifiers leads to a pair of overloads: one enabled and one <code class="sourceCode cpp">deleted</code>.</p>
<p>This proposal solves both problems by allowing <code class="sourceCode cpp"><span class="kw">this</span></code> to be deduced. The following is a complete implementation of <code class="sourceCode cpp">std<span class="op">::</span>not_fn</code>. For simplicity, it makes use of <code class="sourceCode cpp">BOOST_HOF_RETURNS</code> from <a href="https://www.boost.org/doc/libs/1_68_0/libs/hof/doc/html/include/boost/hof/returns.html">Boost.HOF</a> to avoid duplicating expressions:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="kw">struct</span> call_wrapper <span class="op">{</span></span>
<span id="cb46-3"><a href="#cb46-3"></a>  F f;</span>
<span id="cb46-4"><a href="#cb46-4"></a></span>
<span id="cb46-5"><a href="#cb46-5"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Self, <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb46-6"><a href="#cb46-6"></a>  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">this</span> Self<span class="op">&amp;&amp;</span> self, Args<span class="op">&amp;&amp;...</span> args<span class="op">)</span></span>
<span id="cb46-7"><a href="#cb46-7"></a>    BOOST_HOF_RETURNS<span class="op">(</span></span>
<span id="cb46-8"><a href="#cb46-8"></a>      <span class="op">!</span>invoke<span class="op">(</span></span>
<span id="cb46-9"><a href="#cb46-9"></a>        forward<span class="op">&lt;</span>Self<span class="op">&gt;(</span>self<span class="op">).</span>f,</span>
<span id="cb46-10"><a href="#cb46-10"></a>        forward<span class="op">&lt;</span>Args<span class="op">&gt;(</span>args<span class="op">)...))</span></span>
<span id="cb46-11"><a href="#cb46-11"></a><span class="op">}</span>;</span>
<span id="cb46-12"><a href="#cb46-12"></a></span>
<span id="cb46-13"><a href="#cb46-13"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb46-14"><a href="#cb46-14"></a><span class="kw">auto</span> not_fn<span class="op">(</span>F<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-15"><a href="#cb46-15"></a>  <span class="cf">return</span> call_wrapper<span class="op">&lt;</span>decay_t<span class="op">&lt;</span>F<span class="op">&gt;&gt;{</span>forward<span class="op">&lt;</span>F<span class="op">&gt;(</span>f<span class="op">)}</span>;</span>
<span id="cb46-16"><a href="#cb46-16"></a><span class="op">}</span></span></code></pre></div>
<p>Which leads to:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1"></a>not_fn<span class="op">(</span>unfriendly<span class="op">{})(</span><span class="dv">1</span><span class="op">)</span>; <span class="co">// ok</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>not_fn<span class="op">(</span>fun<span class="op">{})()</span>;         <span class="co">// error</span></span></code></pre></div>
<p>Here, there is only one overload with everything deduced together. The first example now works correctly. <code class="sourceCode cpp">Self</code> gets deduced as <code class="sourceCode cpp">call_wrapper<span class="op">&lt;</span>unfriendly<span class="op">&gt;</span></code>, and the one <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">()</span></code> will only consider <code class="sourceCode cpp">unfriendly</code>’s non-<code class="sourceCode cpp"><span class="kw">const</span></code> call operator. The <code class="sourceCode cpp"><span class="kw">const</span></code> one is never even considered, so it does not have an opportunity to cause problems.</p>
<p>The second example now also fails correctly. Previously, we had four candidates. The two non-<code class="sourceCode cpp"><span class="kw">const</span></code> options were removed from the overload set due to <code class="sourceCode cpp">fun</code>’s non-<code class="sourceCode cpp"><span class="kw">const</span></code> call operator being <code class="sourceCode cpp"><span class="kw">delete</span></code>d, and the two <code class="sourceCode cpp"><span class="kw">const</span></code> ones which were viable. But now, we only have one candidate. <code class="sourceCode cpp">Self</code> is deduced as <code class="sourceCode cpp">call_wrapper<span class="op">&lt;</span>fun<span class="op">&gt;</span></code>, which requires <code class="sourceCode cpp">fun</code>’s non-<code class="sourceCode cpp"><span class="kw">const</span></code> call operator to be well-formed. Since it is not, the call results in an error. There is no opportunity for fallback since only one overload is ever considered.</p>
<p>This singular overload has precisely the desired behavior: working for <code class="sourceCode cpp">unfriendly</code>, and not working for <code class="sourceCode cpp">fun</code>.</p>
<p>This could also be implemented as a lambda completely within the body of <code class="sourceCode cpp">not_fn</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="kw">auto</span> not_fn<span class="op">(</span>F<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-3"><a href="#cb48-3"></a>    <span class="cf">return</span> <span class="op">[</span>f<span class="op">=</span>forward<span class="op">&lt;</span>F<span class="op">&gt;(</span>f<span class="op">)](</span><span class="kw">this</span> <span class="kw">auto</span><span class="op">&amp;&amp;</span> self, <span class="kw">auto</span><span class="op">&amp;&amp;..</span> args<span class="op">)</span></span>
<span id="cb48-4"><a href="#cb48-4"></a>        BOOST_HOF_RETURNS<span class="op">(</span></span>
<span id="cb48-5"><a href="#cb48-5"></a>            <span class="op">!</span>invoke<span class="op">(</span></span>
<span id="cb48-6"><a href="#cb48-6"></a>                forward_like<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>self<span class="op">)&gt;(</span>f<span class="op">)</span>,</span>
<span id="cb48-7"><a href="#cb48-7"></a>                forward<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>args<span class="op">)&gt;(</span>args<span class="op">)...))</span></span>
<span id="cb48-8"><a href="#cb48-8"></a>        ;</span>
<span id="cb48-9"><a href="#cb48-9"></a><span class="op">}</span></span></code></pre></div>
<h1 data-number="6" style="border-bottom:1px solid #cccccc" id="faq" data-number="6" style="border-bottom:1px solid #cccccc"><span class="header-section-number">6</span> Frequently Asked Questions<a href="#faq" class="self-link"></a></h1>
<h2 data-number="6.1" id="faq-rec-lambda-impl" data-number="6.1"><span class="header-section-number">6.1</span> On the implementability of recursive lambdas<a href="#faq-rec-lambda-impl" class="self-link"></a></h2>
<p>In San Diego, 2018, there was a question of whether recursive lambdas are implementable. They are, details follow.</p>
<p>The specific issue is the way lambdas are parsed. When parsing a <em>non-generic</em> lambda function body with a default capture, the type of <code class="sourceCode cpp">this_lambda</code> would not be dependent, because the body is <em>not a template</em>. This leads to <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">(</span>this_lambda<span class="op">)</span></code> not being dependent either, and must therefore have an answer - and yet, it cannot, as the lambda capture is not complete, and therefore, the type of <code class="sourceCode cpp">this_lambda</code> is not complete.</p>
<p>This is a huge issue for any proposal of recursive lambdas that includes non-generic lambdas.</p>
<p>Notice, however, that the syntax this paper proposes is the following:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1"></a><span class="kw">auto</span> fib <span class="op">=</span> <span class="op">[](</span><span class="kw">this</span> <span class="kw">auto</span><span class="op">&amp;&amp;</span> self, <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2"></a>  <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> n;</span>
<span id="cb49-3"><a href="#cb49-3"></a>  <span class="cf">return</span> self<span class="op">(</span>n<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">+</span> self<span class="op">(</span>n<span class="op">-</span><span class="dv">2</span><span class="op">)</span>;</span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="op">}</span></span></code></pre></div>
<p>There is, quite obviously, no way to spell a non-generic lambda, because the lambda type is unutterable. <code class="sourceCode cpp">self</code>’s type is always dependent.</p>
<p>This makes expressions depending on <code class="sourceCode cpp">self</code> to be parsed using the regular rules of the language. Expressions involving <code class="sourceCode cpp">self</code> become dependent, and the existing language rules apply, which means both nothing new to implement, and nothing new to teach.</p>
<p>This proposal is therefore implementable, unlike any other we’ve seen to date. We would really like to thank Daveed Vandevoorde for thinking through this one with us in Aspen 2019.</p>
<h2 data-number="6.2" id="faq-demand" data-number="6.2"><span class="header-section-number">6.2</span> Would library implementers use this<a href="#faq-demand" class="self-link"></a></h2>
<p>In Kona, EWGI asked us to see whether library implementors would use this. The answer seems to be a resounding yes.</p>
<p>We have heard from Casey Carter and Jonathan Wakely that they are interested in this feature. Also, on the ewg/lewg mailing lists, this paper comes up as a solution to a surprising number of questions, and gets referenced in many papers-in-flight. A sampling of papers:</p>
<ul>
<li><span class="citation" data-cites="P0798R3">[<a href="#ref-P0798R3" role="doc-biblioref">P0798R3</a>]</span></li>
<li><span class="citation" data-cites="P1221R1">[<a href="#ref-P1221R1" role="doc-biblioref">P1221R1</a>]</span></li>
</ul>
<p>In Herb Sutter’s “Name 5 most important papers for C++”, 10 out of 289 respondents chose it. Given that the cutoff was 5, and that modules, throwing values, contracts, reflection, coroutines, linear algebra, and pattern matching were all in that list, I find the result a strong indication that it is wanted.</p>
<p>We can also report that Gašper is dearly missing this feature in <a href="https://github.com/atomgalaxy/libciabatta">libciabatta</a>, a mixin support library, as well as his regular work writing libraries.</p>
<p>On the question of whether this would get used in the standard library interfaces, the answer was “not without the ability to constrain the deduced type”, which is a feature C++ needs even without this paper, and is an orthogonal feature. The same authors were generally very enthusiastic about using this feature in their implementations.</p>
<h2 data-number="6.3" id="faq-function-ptr-type" data-number="6.3"><span class="header-section-number">6.3</span> Function Pointer Types<a href="#faq-function-ptr-type" class="self-link"></a></h2>
<p>A valid question to ask is what should be the type of this-annotated functions that have a member function equivalent? There are only two options, each with a trade-off. Please assume the existence of these three functions:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1"></a><span class="kw">struct</span> Y <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2"></a>    <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span>, <span class="dt">int</span><span class="op">)</span> <span class="kw">const</span><span class="op">&amp;</span>;         <span class="co">// exists</span></span>
<span id="cb50-3"><a href="#cb50-3"></a>    <span class="dt">int</span> g<span class="op">(</span><span class="kw">this</span> Y <span class="kw">const</span><span class="op">&amp;</span>, <span class="dt">int</span>, <span class="dt">int</span><span class="op">)</span>; <span class="co">// this paper</span></span>
<span id="cb50-4"><a href="#cb50-4"></a>    <span class="dt">int</span> h<span class="op">(</span><span class="kw">this</span> Y, <span class="dt">int</span>, <span class="dt">int</span><span class="op">)</span>;        <span class="co">// this paper, by value</span></span>
<span id="cb50-5"><a href="#cb50-5"></a><span class="op">}</span>;</span></code></pre></div>
<p><code class="sourceCode cpp">g</code> has a current equivalent (<code class="sourceCode cpp">f</code>), while <code class="sourceCode cpp">h</code> does not. <code class="sourceCode cpp"><span class="op">&amp;</span>Y<span class="op">::</span>h</code>’s type <em>must</em> be a regular function pointer.</p>
<p>If we allow <code class="sourceCode cpp">g</code>’s type to be a pointer-to-member-function, we get non-uniformity between the types of <code class="sourceCode cpp">h</code> and <code class="sourceCode cpp">g</code>. We also get implementation issues because the types a template can result in are non-uniform (is this a template for a member function or a free function? Surprise, it’s both!).</p>
<p>We also get forward compatibility with any concievable proposal for extension methods - those will <em>also</em> have to be free functions by necessity, for roughly the same reasons.</p>
<p>The paper originally proposed it the other way, but this was changed to the current wording through EWG input in Cologne, 2018.</p>
<h2 data-number="6.4" id="faq-computed-deduction" data-number="6.4"><span class="header-section-number">6.4</span> Deducing to Base-Class Pointer<a href="#faq-computed-deduction" class="self-link"></a></h2>
<p>One of the pitfalls of having a deduced object parameter is when the intent is solely to deduce the <em>cv</em>-qualifiers and value category of the object parameter, but a derived type is deduced as well — any access through an object that might have a derived type could inadvertently refer to a shadowed member in the derived class. While this is desirable and very powerful in the case of mixins, it is not always desirable in other situations. Superfluous template instantiations are also unwelcome side effects.</p>
<p>One family of possible solutions could be summarized as <strong>make it easy to get the base class pointer</strong>. However, all of these solutions still require extra instantiations. For <code class="sourceCode cpp">optional<span class="op">::</span>value<span class="op">()</span></code>, we really only want four instantiations: <code class="sourceCode cpp"><span class="op">&amp;</span></code>, <code class="sourceCode cpp"><span class="kw">const</span><span class="op">&amp;</span></code>, <code class="sourceCode cpp"><span class="op">&amp;&amp;</span></code>, and <code class="sourceCode cpp"><span class="kw">const</span><span class="op">&amp;&amp;</span></code>. If something inherits from <code class="sourceCode cpp">optional</code>, we don’t want additional instantiations of those functions for the derived types, which won’t do anything new, anyway. This is code bloat.</p>
<p><em>This is already a problem for free-function templates</em>: The authors have heard many a complaint about it from library vendors, even before this paper was introduced, as it is desirable to only deduce the ref-qualifier in many contexts. Therefore, it might make sense to tackle this issue in a more general way. A complementary feature could be proposed to constrain <em>type deduction</em>.</p>
<p>The authors strongly believe this feature is orthogonal. However, hoping that mentioning that solutions are in the pipeline helps gain consensus for this paper, we mention one solution here. The proposal is in early stages, and is not in the pre-belfast mailing. It will be present in the post-belfast mailing: <a href="https://atomgalaxy.github.io/isocpp-1107/D1107.html">computed deduction</a></p>
<h1 data-number="7" style="border-bottom:1px solid #cccccc" id="wording" data-number="7" style="border-bottom:1px solid #cccccc"><span class="header-section-number">7</span> Proposed Wording<a href="#wording" class="self-link"></a></h1>
<p>The status quo here is that a member function has an <em>implicit object parameter</em>, always of reference type, which the <em>implied object argument</em> is bound to. The obvious name for what this paper is proposing is, then, the <em>explicit object parameter</em>. The problem with these names is: well, what is an object parameter? A parameter that takes an object? Isn’t that most parameters?</p>
<p>Instead, the wording introduces the term <em>this parameter</em>, renaming implicit object parameter to implicit this parameter, and introducing the notion of an explicit this parameter. Alternate terms considered were “selector parameter” or “instance parameter”.</p>
<p>Where previously, member functions were divided into static member functions and non-static member functions, this gets a little more complex because some static member functions still use the implied object parameter (those that have an explicit this parameter) and some do not. This wording introduces the term “object member function” for the union of non-static member functions and static member functions with an explicit this parameter. Many functions were previous restricted to be non-static member functions are now restricted to be object member functions.</p>
<p>Move <span>11.4.2 <a href="https://wg21.link/class.mfct.non-static">[class.mfct.non-static]</a></span>/3 in front of <span>7.5.4 <a href="https://wg21.link/expr.prim.id">[expr.prim.id]</a></span>/2 (the text remains unchanged):</p>
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized">2*</a></span> When an <em>id-expression</em> that is not part of a class member access syntax and not used to form a pointer to member (<span>7.6.2.1 <a href="https://wg21.link/expr.unary.op">[expr.unary.op]</a></span>) is used in a member of class X in a context where <code class="sourceCode cpp"><span class="kw">this</span></code> can be used, if name lookup resolves the name in the <em>id-expression</em> to a non-static non-type member of some class <code class="sourceCode cpp">C</code>, and if either the <em>id-expression</em> is potentially evaluated or <code class="sourceCode cpp">C</code> is <code class="sourceCode cpp">X</code> or a base class of <code class="sourceCode cpp">X</code>, the <em>id-expression</em> is transformed into a class member access expression using <code class="sourceCode cpp"><span class="op">(*</span><span class="kw">this</span><span class="op">)</span></code> as the <em>postfix-expression</em> to the left of the <code class="sourceCode cpp"><span class="op">.</span></code> operator. [ <em>Note</em>: If <code class="sourceCode cpp">C</code> is not <code class="sourceCode cpp">X</code> or a base class of <code class="sourceCode cpp">X</code>, the class member access expression is ill-formed. — <em>end note</em> ] This transformation does not apply in the template definition context ([temp.dep.type]). [ <em>Example</em>: […] - <em>end example</em> ]</p>
</div>
</blockquote>
<p>then change <span>7.5.4 <a href="https://wg21.link/expr.prim.id">[expr.prim.id]</a></span>/2, now 3, removing the footnote:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> An <em>id-expression</em> that denotes a non-static data member or <span class="rm" style="color: #bf0303"><del>non-static</del></span> <span class="addu">object</span> member function of a class can only be used:</p>
<ul>
<li><p><span class="marginalizedparent"><a class="marginalized">(3.1)</a></span> as part of a class member access in which the object expression refers to the member’s class <sup><span class="rm" style="color: #bf0303"><del>57</del></span></sup> or a class derived from that class, or</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(3.2)</a></span> to form a pointer to member ([expr.unary.op]), or</p></li>
<li><p><span class="marginalizedparent"><a class="marginalized">(3.3)</a></span> if that <em>id-expression</em> denotes a non-static data member and it appears in an unevaluated operand. [ <em>Example</em>:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb51-1"><a href="#cb51-1"></a>  struct S {</span>
<span id="cb51-2"><a href="#cb51-2"></a>    int m;</span>
<span id="cb51-3"><a href="#cb51-3"></a>  };</span>
<span id="cb51-4"><a href="#cb51-4"></a>  int i = sizeof(S::m);           // OK</span>
<span id="cb51-5"><a href="#cb51-5"></a>  int j = sizeof(S::m + 42);      // OK</span></code></pre></div>
<p>— <em>end example</em> ]</p></li>
</ul>
</blockquote>
<p>Change <span>7.5.5 <a href="https://wg21.link/expr.prim.lambda">[expr.prim.lambda]</a></span>/3:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> In the <em>decl-specifier-seq</em> of the <em>lambda-declarator</em>, each <em>decl-specifier</em> shall be one of <code class="sourceCode cpp"><span class="kw">mutable</span></code>, <code class="sourceCode cpp"><span class="kw">constexpr</span></code>, or <code class="sourceCode cpp"><span class="kw">consteval</span></code>. <span class="addu">If the <em>lambda-declarator</em> contains an explicit this parameter ([dcl.fct]), then no <em>decl-specifier</em> in the <em>decl-specifier-seq</em> shall be <code class="sourceCode cpp"><span class="kw">mutable</span></code>.</span> [ Note: The trailing requires-clause is described in [dcl.decl]. — end note ]</p>
</blockquote>
<p>Add a new paragraph after <span>7.5.5.1 <a href="https://wg21.link/expr.prim.lambda.closure">[expr.prim.lambda.closure]</a></span>/3:</p>
<blockquote>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized">3*</a></span> If a function call operator of a lambda with a <em>lambda-capture</em> and an explicit this parameter is odr-used, the type of the explicit this parameter shall be either:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3*.1)</a></span> the closure type,</li>
<li><span class="marginalizedparent"><a class="marginalized">(3*.2)</a></span> a class type derived from the closure type, or</li>
<li><span class="marginalizedparent"><a class="marginalized">(3*.3)</a></span> a reference to a possibly cv-qualified such type.</li>
</ul>
<p>[ <em>Example</em>:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb52-1"><a href="#cb52-1"></a>struct C {</span>
<span id="cb52-2"><a href="#cb52-2"></a>    template &lt;typename T&gt;</span>
<span id="cb52-3"><a href="#cb52-3"></a>    C(T);</span>
<span id="cb52-4"><a href="#cb52-4"></a>};</span>
<span id="cb52-5"><a href="#cb52-5"></a></span>
<span id="cb52-6"><a href="#cb52-6"></a>void func(int i) {</span>
<span id="cb52-7"><a href="#cb52-7"></a>    int x = [=](this auto&amp;&amp;) { return i; }(); // ok</span>
<span id="cb52-8"><a href="#cb52-8"></a>    int y = [=](this C) { return i; }();      // ill-formed</span>
<span id="cb52-9"><a href="#cb52-9"></a>    int z = [](this C) { return 42; }();      // ok</span>
<span id="cb52-10"><a href="#cb52-10"></a>}</span></code></pre></div>
<ul>
<li><em>end example</em> ]</li>
</ul>
</div>
</blockquote>
<p>Change <span>7.5.5.1 <a href="https://wg21.link/expr.prim.lambda.closure">[expr.prim.lambda.closure]</a></span>/4:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> The function call operator or operator template is declared <code class="sourceCode cpp"><span class="kw">const</span></code> ([class.mfct.non-static]) if and only if the <em>lambda-expression</em>’s <em>parameter-declaration-clause</em> is not followed by <code class="sourceCode cpp"><span class="kw">mutable</span></code> <span class="addu">and the <em>lambda-declarator</em> does not contain an explicit this parameter</span>.</p>
</blockquote>
<p>Change <span>7.6.1.2 <a href="https://wg21.link/expr.call">[expr.call]</a></span>/1-2:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> […] The postfix expression shall have function type or function pointer type. For a call to a non-member function or to a static member function <span class="addu">that is not an object member function ([dcl.fct])</span>, the postfix expression shall either be an lvalue that refers to a function (in which case the function-to-pointer standard conversion ([conv.func]) is suppressed on the postfix expression), or have function pointer type.</p>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> For a call to a non-static member function, the postfix expression shall be an implicit ([class.mfct.non-static], [class.static]) or explicit class member access whose <em>id-expression</em> is a function member name, or a pointer-to-member expression selecting a function member<span class="rm" style="color: #bf0303"><del>;</del></span> <span class="addu">.</span> <span class="addu">For a call to an object member function with an explicit this parameter, the postfix expression shall be an explicit class member access whose <em>id-expression</em> is a function member name, or a pointer-to-member expression selecting a function member.</span> <span class="rm" style="color: #bf0303"><del>the</del></span> <span class="addu">The</span> call is as a member of the class object referred to by the object expression. In the case of an implicit class member access, the implied object is the one pointed to by <code class="sourceCode cpp"><span class="kw">this</span></code>. [ Note: A member function call of the form f() is interpreted as <code class="sourceCode cpp"><span class="op">(*</span><span class="kw">this</span><span class="op">).</span>f<span class="op">()</span></code> (see [class.mfct.non-static]). — end note ]</p>
</blockquote>
<p>Change <span>7.6.1.2 <a href="https://wg21.link/expr.call">[expr.call]</a></span>/7:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> When a function is called, each parameter ([dcl.fct]) is initialized ([dcl.init], [class.copy.ctor]) with its corresponding argument. If there is no corresponding argument, the default argument for the parameter is used. […] If the function is a non-static member function, the <code class="sourceCode cpp"><span class="kw">this</span></code> parameter of the function is initialized with a pointer to the object of the call, converted as if by an explicit type conversion. [ <em>Note</em>: There is no access or ambiguity checking on this conversion; the access checking and disambiguation are done as part of the (possibly implicit) class member access operator. See [class.member.lookup], [class.access.base], and [expr.ref]. — end note ] <span class="addu">If the function is an object member function with an explicit this parameter, the explicit this parameter of the function is initialized with the object of the call.</span> When a function is called, the type of any parameter shall not be a class type that is either incomplete or abstract.</p>
</blockquote>
<p>Change <span>7.6.1.4 <a href="https://wg21.link/expr.ref">[expr.ref]</a></span>/6.3 - flipping the two bullets.</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">(6.3)</a></span> If <code class="sourceCode cpp">E2</code> is a (possibly overloaded) member function, function overload resolution ([over.match]) is used to select the function to which <code class="sourceCode cpp">E2</code> refers. The type of <code class="sourceCode cpp">E1<span class="op">.</span>E2</code> is the type of <code class="sourceCode cpp">E2</code> and <code class="sourceCode cpp">E1<span class="op">.</span>E2</code> refers to the function referred to by <code class="sourceCode cpp">E2</code>.</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(6.3.1)</a></span> <span class="rm" style="color: #bf0303"><del>Otherwise (when <span><code class="sourceCode default">E2</code></span> refers to a non-static member function)</del></span> <span class="addu">If <code class="sourceCode cpp">E2</code> refers to an object member function ([dcl.fct])</span>, <code class="sourceCode cpp">E1<span class="op">.</span>E2</code> is a prvalue. The expression can be used only as the left-hand operand of a member function call ([class.mfct]). [ <em>Note</em>: Any redundant set of parentheses surrounding the expression is ignored ([expr.prim.paren]). — <em>end note</em> ]</li>
<li><span class="marginalizedparent"><a class="marginalized">(6.3.2)</a></span> <span class="rm" style="color: #bf0303"><del>If <span><code class="sourceCode default">E2</code></span> refers to a static member function</del></span> <span class="addu">Otherwise</span>, <code class="sourceCode cpp">E1<span class="op">.</span>E2</code> is an lvalue.</li>
</ul>
</blockquote>
<p>In <span>9.3.3.5 <a href="https://wg21.link/dcl.fct">[dcl.fct]</a></span>/3, insert the <em>explicit-object-parameter-declaration</em> into the syntax for the <em>parameter-declaration-clause</em>:</p>
<blockquote>
<blockquote>
<div class="line-block"><em>parameter-declaration-list</em>:<br />
   <em>parameter-declaration</em><br />
   <span class="addu"><em>explicit-this-parameter-declaration</em></span><br />
   <em>parameter-declaration-list</em> <code class="sourceCode cpp">,</code> <em>parameter-declaration</em></div>
</blockquote>
<div class="add" style="color: #006e28">

<blockquote>
<div class="line-block"><em>explicit-this-parameter-declaration</em>:<br />
   <code class="sourceCode default">this</code> <em>parameter-declaration</em></div>
</blockquote>

</div>
</blockquote>
<p>After <span>9.3.3.5 <a href="https://wg21.link/dcl.fct">[dcl.fct]</a></span>/5, insert paragraph describing where a function declaration with an explicit this parameter may appear, and renumber section.</p>
<blockquote>
<div class="add" style="color: #006e28">
<p><span class="marginalizedparent"><a class="marginalized">5a</a></span> An <em>explicit-this-parameter-declaration</em> shall only appear in either a <em>member-declarator</em> that declares a member function ([class.mem]) or a <em>lambda-declarator</em> ([expr.prim.lambda]). Such a function shall not be explicitly declared <code class="sourceCode default">static</code> or <code class="sourceCode default">virtual</code>. [ <em>Note</em>: Such a function is implicitly static ([class.mem]) - <em>end note</em> ] Such a declarator shall not include a <em>ref-qualifier</em> or a <em>cv-qualifier-seq</em>.</p>
<p><span class="marginalizedparent"><a class="marginalized">5b</a></span> A function parameter declared with an <em>explicit-this-parameter-declaration</em> is an <em>explicit this parameter</em>. An explicit this parameter shall not be a function parameter pack ([temp.variadic]). An <em>object member function</em> is either a non-static member function or a static member function with an explicit this parameter.</p>
<p><span class="marginalizedparent"><a class="marginalized">5c</a></span> An <em>ordinary member parameter</em> is a function parameter that is not the explicit this parameter. The <em>ordinary-parameter-type-list</em> of a member function is the parameter-type-list of that function with the explicit this parameter, if any, omitted. [ <em>Note</em>: The ordinary-parameter-type-list consists of the adjusted types of all the ordinary member parameters. <em>-end note</em> ]</p>
</div>
</blockquote>
<p>Change <span>11.4 <a href="https://wg21.link/class.mem">[class.mem]</a></span>/4:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> A data member or member function may be declared <code class="sourceCode cpp"><span class="kw">static</span></code> in its <em>member-declaration</em>, in which case it is a <em>static member</em> (see [class.static]) (a <em>static data member</em> ([class.static.data]) or <em>static member function</em> ([class.static.mfct]), respectively) of the class. <span class="addu">A member function declared with an explicit this parameter ([dcl.fct]) is a static member function.</span> Any other data member or member function is a <em>non-static member</em> (a <em>non-static data member</em> or <em>non-static member function</em> ([class.mfct.non-static]), respectively). [ <em>Note</em>: A non-static data member of non-reference type is a member subobject of a class object. — <em>end note</em> ]</p>
</blockquote>
<p>Remove <span>11.4.2 <a href="https://wg21.link/class.mfct.non-static">[class.mfct.non-static]</a></span>/3 (was moved into [expr.prim.id] earlier).</p>
<p>Change <span>11.4.7.2 <a href="https://wg21.link/class.conv.fct">[class.conv.fct]</a></span>/1:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <span class="rm" style="color: #bf0303"><del>A</del></span> <span class="addu">An object</span> member function of a class <code class="sourceCode cpp">X</code> having no <span class="addu">ordinary member</span> parameters with a name of the form […] specifies a conversion from <code class="sourceCode cpp">X</code> to the type specified by the <em>conversion-type-id</em>. Such functions are called <em>conversion functions</em>. A <em>decl-specifier</em> in the <em>decl-specifier-seq</em> of a conversion function (if any) shall be neither a <em>defining-type-specifier</em> nor <code class="sourceCode cpp"><span class="kw">static</span></code>. The type of the conversion function ([dcl.fct]) is “function taking no parameter returning <em>conversion-type-id</em>”.</p>
</blockquote>
<p>Change <span>11.4.8.1 <a href="https://wg21.link/class.static.mfct">[class.static.mfct]</a></span>/2:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> [ <em>Note</em>: A static member function does not have a this pointer ([class.this]). — <em>end note</em> ] A static member function shall not be <code class="sourceCode cpp"><span class="kw">virtual</span></code>. There shall not be a static and a non-static member function with the same name and the same <span class="rm" style="color: #bf0303"><del>parameter types</del></span> <span class="addu">ordinary-parameter-type-list</span> (<span class="addu">[dcl.fct],</span> [over.load]). A static member function shall not be declared <code class="sourceCode cpp"><span class="kw">const</span></code>, <code class="sourceCode cpp"><span class="kw">volatile</span></code>, or <code class="sourceCode cpp"><span class="kw">const</span> <span class="kw">volatile</span></code>.</p>
</blockquote>
<p>Change <span>12.2 <a href="https://wg21.link/over.load">[over.load]</a></span>/2.2:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">(2.2)</a></span> Member function declarations with the same name, the same <span class="rm" style="color: #bf0303"><del>parameter-type-list</del></span> <span class="addu">ordinary-parameter-type-list</span> ([dcl.fct]), and the same trailing <em>requires-clause</em> (if any) cannot be overloaded if any of them is <span class="rm" style="color: #bf0303"><del>a <span><code class="sourceCode default">static</code></span></del></span> <span class="addu">not an object</span> member function declaration <span class="rm" style="color: #bf0303"><del>([class.static])</del></span> <span class="addu">([dcl.fct])</span>. Likewise, member function template declarations with the same name, the same <span class="rm" style="color: #bf0303"><del>parameter-type-list</del></span> <span class="addu">ordinary-parameter-type-list</span>, the same trailing requires-clause (if any), and the same template-head cannot be overloaded if any of them is <span class="rm" style="color: #bf0303"><del>a <span><code class="sourceCode default">static</code></span></del></span> <span class="addu">not an object</span> member function template declaration. The types of the implicit <span class="addu">or explicit</span> <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameters constructed for the member functions for the purpose of overload resolution ([over.match.funcs]) are not considered when comparing <span class="rm" style="color: #bf0303"><del>parameter-type-lists</del></span> <span class="addu">ordinary-parameter-type-lists</span> for enforcement of this rule. In contrast, if <span class="rm" style="color: #bf0303"><del>there is no <span><code class="sourceCode default">static</code></span></del></span> <span class="addu">every</span> member function declaration among a set of member function declarations with the same name, the same <span class="rm" style="color: #bf0303"><del>parameter-type-list</del></span> <span class="addu">ordinary-parameter-type-list</span>, and the same <em>trailing requires-clause</em> (if any) <span class="addu">is an object member function</span>, then these member function declarations can be overloaded if they differ in the type of their implicit <span class="addu">or explicit</span> <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter. [ <em>Example</em>: The following illustrates this distinction:</p>
<div>
<div class="sourceCode" id="cb53"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb53-1"><a href="#cb53-1"></a>class X {</span>
<span id="cb53-2"><a href="#cb53-2"></a>  static void f();</span>
<span id="cb53-3"><a href="#cb53-3"></a>  void f();                     // error</span>
<span id="cb53-4"><a href="#cb53-4"></a>  void f() const;               // error</span>
<span id="cb53-5"><a href="#cb53-5"></a>  void f() const volatile;      // error</span>
<span id="cb53-6"><a href="#cb53-6"></a>  void g();</span>
<span id="cb53-7"><a href="#cb53-7"></a>  void g() const;               // OK: no static g</span>
<span id="cb53-8"><a href="#cb53-8"></a>  void g() const volatile;      // OK: no static g</span>
<span id="cb53-9"><a href="#cb53-9"></a>  </span>
<span id="cb53-10"><a href="#cb53-10"></a><span class="va">+ void h(this X&amp;, int);</span></span>
<span id="cb53-11"><a href="#cb53-11"></a><span class="va">+ void h(int) &amp;&amp;;               // OK: different this parameter</span></span>
<span id="cb53-12"><a href="#cb53-12"></a><span class="va">+ void j(this const X&amp;);</span></span>
<span id="cb53-13"><a href="#cb53-13"></a><span class="va">+ void j() const&amp;;              // error: same this parameter type</span></span>
<span id="cb53-14"><a href="#cb53-14"></a><span class="va">+ void k(this X&amp;);              // OK</span></span>
<span id="cb53-15"><a href="#cb53-15"></a><span class="va">+ void k(this X&amp;&amp;);             // OK</span></span>
<span id="cb53-16"><a href="#cb53-16"></a>};</span></code></pre></div>
</div>
<p>— <em>end example</em> ]</p>
</blockquote>
<p>Change <span>12.4 <a href="https://wg21.link/over.match">[over.match]</a></span>/1:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> The selection criteria for the best function are the number of arguments, how well the arguments match the parameter-type-list of the candidate function, how well (for non-static member functions) the object matches the implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter, and certain other properties of the candidate function.</p>
</blockquote>
<p>Change <span>12.4.1 <a href="https://wg21.link/over.match.funcs">[over.match.funcs]</a></span>/2-5:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> So that argument and parameter lists are comparable within this heterogeneous set, a member function <span class="addu">that does not have an explicit this parameter</span> is considered to have an extra first parameter, called the <em>implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter</em>, which represents the object for which the member function has been called. For the purposes of overload resolution, both static and non-static member functions have an implicit <span class="addu">or explicit</span> <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter, but constructors do not.</p>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> Similarly, when appropriate, the context can construct an argument list that contains an <em>implied object argument</em> as the first argument in the list to denote the object to be operated on.</p>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> For non-static member functions, the type of the implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter is</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(4.1)</a></span> “lvalue reference to <em>cv</em> <code class="sourceCode cpp">X</code>” for functions declared without a <em>ref-qualifier</em> or with the <code class="sourceCode cpp"><span class="op">&amp;</span></code> <em>ref-qualifier</em></li>
<li><span class="marginalizedparent"><a class="marginalized">(4.2)</a></span> “rvalue reference to <em>cv</em> <code class="sourceCode cpp">X</code>” for functions declared with the <code class="sourceCode cpp"><span class="op">&amp;&amp;</span></code> <em>ref-qualifier</em></li>
</ul>
<p>where <code class="sourceCode cpp">X</code> is the class of which the function is a member and <em>cv</em> is the <em>cv</em>-qualification on the member function declaration. [ Example: For a <code class="sourceCode cpp"><span class="kw">const</span></code> member function of class <code class="sourceCode cpp">X</code>, the extra parameter is assumed to have type “<span class="addu">lvalue</span> reference to <code class="sourceCode cpp"><span class="kw">const</span> X</code>”. — <em>end example</em> ] For conversion functions, the function is considered to be a member of the class of the implied object argument for the purpose of defining the type of the implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter. For non-conversion functions introduced by a <em>using-declaration</em> into a derived class, the function is considered to be a member of the derived class for the purpose of defining the type of the implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter. For static member functions <span class="addu">that do not have an explicit this parameter</span>, the implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter is considered to match any object (since if the function is selected, the object is discarded). [ <em>Note</em>: No actual type is established for the implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter of <span class="addu">such</span> a static member function, and no attempt will be made to determine a conversion sequence for that parameter ([over.match.best]). — <em>end note</em> ]</p>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> During overload resolution, the implied object argument is indistinguishable from other arguments. The implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter, however, retains its identity since no user-defined conversions can be applied to achieve a type match with it. For non-static member functions declared without a <em>ref-qualifier</em>, even if the implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter is not const-qualified, an rvalue can be bound to the parameter as long as in all other respects the argument can be converted to the type of the implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter. [ <em>Note</em>: The fact that such an argument is an rvalue does not affect the ranking of implicit conversion sequences. — <em>end note</em> ]</p>
</blockquote>
<p>Change <span>12.4.1.1.1 <a href="https://wg21.link/over.call.func">[over.call.func]</a></span>/3 and the corresponding footnote, and add the example:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> Because of the rules for name lookup, the set of candidate functions consists (1) entirely of non-member functions or (2) entirely of member functions of some class T. In case (1), the argument list is the same as the expression-list in the call. In case (2), the argument list is the <em>expression-list</em> in the call augmented by the addition of an implied object argument as in a qualified function call <span class="rm" style="color: #bf0303"><del>.</del></span> <span class="addu">as follows:</span></p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3.1)</a></span> <span class="rm" style="color: #bf0303"><del>If</del></span> <span class="addu">if</span> the keyword <code class="sourceCode cpp"><span class="kw">this</span></code> is in scope and refers to class <code class="sourceCode cpp">T</code>, or a derived class of <code class="sourceCode cpp">T</code>, <span class="addu">and the candidate function has no explicit this parameter,</span> then the implied object argument is <code class="sourceCode cpp"><span class="op">(*</span><span class="kw">this</span><span class="op">)</span></code><span class="rm" style="color: #bf0303"><del>.</del></span> <span class="addu">;</span></li>
<li><span class="marginalizedparent"><a class="marginalized">(3.2)</a></span> <span class="rm" style="color: #bf0303"><del>If the keyword <span><code class="sourceCode default">this</code></span> is not in scope or refers to another class, then</del></span> <span class="addu">otherwise,</span> a contrived object of type <code class="sourceCode cpp">T</code> becomes the implied object argument. <sup>119</sup></li>
</ul>
<p>If the argument list is augmented by a contrived object and overload resolution selects one of the <span class="rm" style="color: #bf0303"><del>non-static</del></span> <span class="addu">object</span> member functions of <code class="sourceCode cpp">T</code>, the call is ill-formed.</p>
<div class="addu">
<p>[ <em>Example</em>:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb54-1"><a href="#cb54-1"></a>struct C {</span>
<span id="cb54-2"><a href="#cb54-2"></a>    void a();</span>
<span id="cb54-3"><a href="#cb54-3"></a>    void b() {</span>
<span id="cb54-4"><a href="#cb54-4"></a>        a(); // ok, (*this).a()</span>
<span id="cb54-5"><a href="#cb54-5"></a>    }</span>
<span id="cb54-6"><a href="#cb54-6"></a>    </span>
<span id="cb54-7"><a href="#cb54-7"></a>    void f(this const C&amp;);</span>
<span id="cb54-8"><a href="#cb54-8"></a>    void g() const {</span>
<span id="cb54-9"><a href="#cb54-9"></a>        f();       // error: implied object argument is contrived</span>
<span id="cb54-10"><a href="#cb54-10"></a>        f(*this);  // error: no viable candidate</span>
<span id="cb54-11"><a href="#cb54-11"></a>        this-&gt;f(); // ok</span>
<span id="cb54-12"><a href="#cb54-12"></a>    }</span>
<span id="cb54-13"><a href="#cb54-13"></a>    </span>
<span id="cb54-14"><a href="#cb54-14"></a>    static void h() {</span>
<span id="cb54-15"><a href="#cb54-15"></a>        f();       // error: implied object argument is contrived</span>
<span id="cb54-16"><a href="#cb54-16"></a>        f(C{});    // error: no viable candidate</span>
<span id="cb54-17"><a href="#cb54-17"></a>        C{}.f();   // ok</span>
<span id="cb54-18"><a href="#cb54-18"></a>    }</span>
<span id="cb54-19"><a href="#cb54-19"></a>};</span></code></pre></div>
<ul>
<li><em>end example</em> ]</li>
</ul>
</div>
<p><span class="marginalizedparent"><a class="marginalized">119</a></span> An implied object argument must be contrived to correspond to the implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter attributed to <span class="addu">non-static</span> member functions during overload resolution. It is not used in the call to the selected function. Since the <span class="rm" style="color: #bf0303"><del>member functions</del></span> <span class="addu">candidates</span> all have the same <span class="rm" style="color: #bf0303"><del>implicit object parameter</del></span> <span class="addu">implied object argument</span>, the contrived object will not be the cause to select or reject a function.</p>
</blockquote>
<p>Add to <span>12.4.1.1.2 <a href="https://wg21.link/over.call.object">[over.call.object]</a></span>/3:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> The argument list submitted to overload resolution consists of the argument expressions present in the function call syntax preceded by the implied object argument <code class="sourceCode cpp"><span class="op">(</span>E<span class="op">)</span></code>. [ <em>Note</em>: When comparing the call against the function call operators, the implied object argument is compared against <span class="addu">either</span> the implicit <span class="addu">or explicit</span> <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter of the function call operator. When comparing the call against a surrogate call function, the implied object argument is compared against the first parameter of the surrogate call function. The conversion function from which the surrogate call function was derived will be used in the conversion sequence for that parameter since it converts the implied object argument to the appropriate function pointer or reference required by that first parameter. — <em>end note</em> ]</p>
</blockquote>
<p>Change the note in <span>12.4.1.2 <a href="https://wg21.link/over.match.oper">[over.match.oper]</a></span>/3.4:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">(3.4.5)</a></span> [ <em>Note</em>: A candidate synthesized from a member candidate has its implicit <span class="addu">or explicit</span> <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter as the second parameter, thus implicit conversions are considered for the first, but not for the second, parameter. — <em>end note</em> ]</p>
</blockquote>
<p>Change the note in <span>12.4.1.4 <a href="https://wg21.link/over.match.copy">[over.match.copy]</a></span>/2:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> In both cases, the argument list has one argument, which is the initializer expression. [ <em>Note</em>: This argument will be compared against the first parameter of the constructors and against the implicit <span class="addu">or explicit</span> <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter of the conversion functions. — end note ]</p>
</blockquote>
<p>Change the note in <span>12.4.1.5 <a href="https://wg21.link/over.match.conv">[over.match.conv]</a></span>/2:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> The argument list has one argument, which is the initializer expression. [ <em>Note</em>: This argument will be compared against the implicit <span class="addu">or explicit</span> <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter of the conversion functions. — end note ]</p>
</blockquote>
<p>Change the note in <span>12.4.1.6 <a href="https://wg21.link/over.match.ref">[over.match.ref]</a></span>/2:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> The argument list has one argument, which is the initializer expression. [ <em>Note</em>: This argument will be compared against the implicit <span class="addu">or explicit</span> <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter of the conversion functions. — end note ]</p>
</blockquote>
<p>Change <span>12.4.3.1 <a href="https://wg21.link/over.best.ics">[over.best.ics]</a></span>/4:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> However, if the target is</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(4.1)</a></span> the first parameter of a constructor or</li>
<li><span class="marginalizedparent"><a class="marginalized">(4.2)</a></span> the implicit <span class="addu">or explicit</span> <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter of a user-defined conversion function</li>
</ul>
<p>and the constructor or user-defined conversion function is a candidate by […]</p>
</blockquote>
<p>Change <span>12.4.3.1 <a href="https://wg21.link/over.best.ics">[over.best.ics]</a></span>/7:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> In all contexts, when converting to the implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter or when converting to the left operand of an assignment operation only standard conversion sequences are allowed.</p>
</blockquote>
<p>Change <span>12.4.3.1.2 <a href="https://wg21.link/over.ics.user">[over.ics.user]</a></span>/1:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> If the user-defined conversion is specified by a conversion function, the initial standard conversion sequence converts the source type to the implicit <span class="addu">or explicit</span> <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter of the conversion function.</p>
</blockquote>
<p>Change <span>12.4.3.1.4 <a href="https://wg21.link/over.ics.ref">[over.ics.ref]</a></span>/3:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> Except for an implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter, for which see [over.match.funcs], an implicit conversion sequence cannot be formed if it requires binding an lvalue reference other than a reference to a non-volatile const type to an rvalue or binding an rvalue reference to an lvalue other than a function lvalue. [ <em>Note</em>: This means, for example, that a candidate function cannot be a viable function if it has a non-const lvalue reference parameter (other than the implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter) and the corresponding argument would require a temporary to be created to initialize the lvalue reference (see [dcl.init.ref]). — <em>end note</em> ]</p>
</blockquote>
<p>Change <span>12.4.3.2 <a href="https://wg21.link/over.ics.rank">[over.ics.rank]</a></span>/3.2.3:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">(3.2)</a></span> Standard conversion sequence <code class="sourceCode cpp">S1</code> is a better conversion sequence than standard conversion sequence <code class="sourceCode cpp">S2</code> if</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3.2.3)</a></span> <code class="sourceCode cpp">S1</code> and <code class="sourceCode cpp">S2</code> include reference bindings ([dcl.init.ref]) and neither refers to an implicit <span class="rm" style="color: #bf0303"><del>object</del></span> <span class="addu">this</span> parameter of a non-static member function declared without a <em>ref-qualifier</em>, and <code class="sourceCode cpp">S1</code> binds an rvalue reference to an rvalue and <code class="sourceCode cpp">S2</code> binds an lvalue reference</li>
</ul>
</blockquote>
<p>Change <span>12.6 <a href="https://wg21.link/over.oper">[over.oper]</a></span>/7:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> An operator function shall either be <span class="rm" style="color: #bf0303"><del>a non-static</del></span> <span class="addu">an object</span> member function or be a non-member function that has at least one parameter whose type is a class, a reference to a class, an enumeration, or a reference to an enumeration.</p>
</blockquote>
<p>Change <span>12.6.1 <a href="https://wg21.link/over.unary">[over.unary]</a></span>/1:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> A <em>prefix unary operator function</em> is a function named <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code> for a prefix <em>unary-operator</em> <code class="sourceCode cpp"><span class="op">@</span></code> ([expr.unary.op]) that is either <span class="rm" style="color: #bf0303"><del>a non-static</del></span> <span class="addu">an object</span> member function ([class.mfct]) with no <span class="addu">ordinary member</span> parameters or a non-member function with one parameter.</p>
</blockquote>
<p>Change <span>12.6.2 <a href="https://wg21.link/over.binary">[over.binary]</a></span>/1:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> A <em>binary operator function</em> is a function named <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code> for a binary operator <code class="sourceCode cpp"><span class="op">@</span></code> that is either <span class="rm" style="color: #bf0303"><del>a non-static</del></span> <span class="addu">an object</span> member function ([class.mfct]) with one <span class="addu">ordinary member</span> parameter or a non-member function with two parameters.</p>
</blockquote>
<p>Change <span>12.6.2.1 <a href="https://wg21.link/over.ass">[over.ass]</a></span>/1:</p>
<blockquote>
<p>A <em>simple assignment operator function</em> is a binary operator function named <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">=</span></code>. A simple assignment operator function shall be <span class="rm" style="color: #bf0303"><del>a non-static</del></span> <span class="addu">an object</span> member function.</p>
</blockquote>
<p>Change <span>12.6.3 <a href="https://wg21.link/over.call">[over.call]</a></span>/1:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> A <em>function call operator function</em> is a function named <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">()</span></code> that is <span class="rm" style="color: #bf0303"><del>a non-static</del></span> <span class="addu">an object</span> member function with an arbitrary number of parameters.</p>
</blockquote>
<p>Change <span>12.6.4 <a href="https://wg21.link/over.sub">[over.sub]</a></span>/1:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> A <em>subscripting operator function</em> is a function named <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">[]</span></code> that is <span class="rm" style="color: #bf0303"><del>a non-static</del></span> <span class="addu">an object</span> member function with exactly one <span class="addu">ordinary member</span> parameter.</p>
</blockquote>
<p>Change <span>12.6.5 <a href="https://wg21.link/over.ref">[over.ref]</a></span>/1:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> A <em>class member access operator function</em> is a function named <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">-&gt;</span></code> that is <span class="rm" style="color: #bf0303"><del>a non-static</del></span> <span class="addu">an object</span> member function taking no <span class="addu">ordinary member</span> parameters.</p>
</blockquote>
<p>Change <span>12.6.6 <a href="https://wg21.link/over.inc">[over.inc]</a></span>/1:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> An <em>increment operator function</em> is a function named <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">++</span></code>. If this function is <span class="rm" style="color: #bf0303"><del>a non-static</del></span> <span class="addu">an object</span> member function with no <span class="addu">ordinary member</span> parameters, or a non-member function with one parameter, it defines the prefix increment operator <code class="sourceCode cpp"><span class="op">++</span></code> for objects of that type. If the function is <span class="rm" style="color: #bf0303"><del>a non-static</del></span> <span class="addu">an object</span> member function with one <span class="addu">ordinary member</span> parameter (which shall be of type <code class="sourceCode cpp"><span class="dt">int</span></code>) or a non-member function with two parameters (the second of which shall be of type <code class="sourceCode cpp"><span class="dt">int</span></code>), it defines the postfix increment operator <code class="sourceCode cpp"><span class="op">++</span></code> for objects of that type.</p>
</blockquote>
<h2 data-number="7.1" id="feature-test-macro-tabcpp.predefined.ft" data-number="7.1"><span class="header-section-number">7.1</span> Feature-test macro [tab:cpp.predefined.ft]<a href="#feature-test-macro-tabcpp.predefined.ft" class="self-link"></a></h2>
<p>Add to <span>15.11 <a href="https://wg21.link/cpp.predefined">[cpp.predefined]</a></span>/table 17 ([tab:cpp.predefined.ft]):</p>
<p><span class="addu"><code class="sourceCode cpp">__cpp_explicit_this_parameter</code></span> with the appropriate value.</p>
<h1 data-number="8" style="border-bottom:1px solid #cccccc" id="acknowledgements" data-number="8" style="border-bottom:1px solid #cccccc"><span class="header-section-number">8</span> Acknowledgements<a href="#acknowledgements" class="self-link"></a></h1>
<p>The authors would like to thank:</p>
<ul>
<li>Jonathan Wakely, for bringing us all together by pointing out we were writing the same paper, twice</li>
<li>Chandler Carruth for a lot of feedback and guidance around many design issues, but especially for help with use cases and the pointer-types for by-value passing</li>
<li>Graham Heynes, Andrew Bennieston, Jeff Snyder for early feedback regarding the meaning of <code class="sourceCode cpp"><span class="kw">this</span></code> inside function bodies</li>
<li>Amy Worthington, Jackie Chen, Vittorio Romeo, Tristan Brindle, Agustín Bergé, Louis Dionne, and Michael Park for early feedback</li>
<li>Guilherme Hartmann for his guidance with the implementation</li>
<li>Jens Maurer, Richard Smith, Hubert Tong, Faisal Vali, and Daveed Vandevoorde for help with wording</li>
<li>Ville Voutilainen, Herb Sutter, Titus Winters and Bjarne Stroustrup for their guidance in design-space exploration</li>
<li>Eva Conti for furious copy editing, patience, and moral support</li>
<li>Daveed Vandevoorde for his extensive feedback on recursive lambdas and implementation help</li>
</ul>
<!--
 vim: ft=markdown wrap linebreak nolist textwidth=0 wrapmargin=0
-->
<h1 data-number="9" style="border-bottom:1px solid #cccccc" id="bibliography" data-number="9" style="border-bottom:1px solid #cccccc"><span class="header-section-number">9</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-Effective">
<p>[EffCpp] Scott Meyers. Effective C++, Third Edition. <br />
<a href="https://www.aristeia.com/books.html">https://www.aristeia.com/books.html</a></p>
</div>
<div id="ref-P0798R0">
<p>[P0798R0] Simon Brand. 2017. Monadic operations for std::optional. <br />
<a href="https://wg21.link/p0798r0">https://wg21.link/p0798r0</a></p>
</div>
<div id="ref-P0798R3">
<p>[P0798R3] Simon Brand. 2019. Monadic operations for std::optional. <br />
<a href="https://wg21.link/p0798r3">https://wg21.link/p0798r3</a></p>
</div>
<div id="ref-P0826R0">
<p>[P0826R0] Agustín Bergé. 2017. SFINAE-friendly std::bind. <br />
<a href="https://wg21.link/p0826r0">https://wg21.link/p0826r0</a></p>
</div>
<div id="ref-P0839R0">
<p>[P0839R0] Richard Smith. 2017. Recursive Lambdas. <br />
<a href="https://wg21.link/p0839r0">https://wg21.link/p0839r0</a></p>
</div>
<div id="ref-P0847R0">
<p>[P0847R0] Gašper Ažman, Simon Brand, Ben Deane, Barry Revzin. 2018. Deducing this. <br />
<a href="https://wg21.link/p0847r0">https://wg21.link/p0847r0</a></p>
</div>
<div id="ref-P0847R1">
<p>[P0847R1] Gašper Ažman, Simon Brand, Ben Deane, Barry Revzin. 2018. Deducing this. <br />
<a href="https://wg21.link/p0847r1">https://wg21.link/p0847r1</a></p>
</div>
<div id="ref-P0847R2">
<p>[P0847R2] Gašper Ažman, Simon Brand, Ben Deane, Barry Revzin. 2019. Deducing this. <br />
<a href="https://wg21.link/p0847r2">https://wg21.link/p0847r2</a></p>
</div>
<div id="ref-P0929R2">
<p>[P0929R2] Jens Maurer. 2018. Checking for abstract class types. <br />
<a href="https://wg21.link/p0929r2">https://wg21.link/p0929r2</a></p>
</div>
<div id="ref-P1169R0">
<p>[P1169R0] Barry Revzin, Casey Carter. 2018. static operator(). <br />
<a href="https://wg21.link/p1169r0">https://wg21.link/p1169r0</a></p>
</div>
<div id="ref-P1221R1">
<p>[P1221R1] Jason Rice. 2018. Parametric Expressions. <br />
<a href="https://wg21.link/p1221r1">https://wg21.link/p1221r1</a></p>
</div>
</div>
</div>
</div>
</body>
</html>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2020-08-02" />
  <title>`do not return or else`</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f6f8fa; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span. { } /* Normal */
      code span.al { color: #ff0000; } /* Alert */
      code span.an { } /* Annotation */
      code span.at { } /* Attribute */
      code span.bn { color: #9f6807; } /* BaseN */
      code span.bu { color: #9f6807; } /* BuiltIn */
      code span.cf { color: #00607c; } /* ControlFlow */
      code span.ch { color: #9f6807; } /* Char */
      code span.cn { } /* Constant */
      code span.co { color: #008000; font-style: italic; } /* Comment */
      code span.cv { color: #008000; font-style: italic; } /* CommentVar */
      code span.do { color: #008000; } /* Documentation */
      code span.dt { color: #00607c; } /* DataType */
      code span.dv { color: #9f6807; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #9f6807; } /* Float */
      code span.fu { } /* Function */
      code span.im { } /* Import */
      code span.in { color: #008000; } /* Information */
      code span.kw { color: #00607c; } /* Keyword */
      code span.op { color: #af1915; } /* Operator */
      code span.ot { } /* Other */
      code span.pp { color: #6f4e37; } /* Preprocessor */
      code span.re { } /* RegionMarker */
      code span.sc { color: #9f6807; } /* SpecialChar */
      code span.ss { color: #9f6807; } /* SpecialString */
      code span.st { color: #9f6807; } /* String */
      code span.va { } /* Variable */
      code span.vs { color: #9f6807; } /* VerbatimString */
      code span.wa { color: #008000; font-weight: bold; } /* Warning */
      code.diff {color: #898887}
      code.diff span.va {color: #006e28}
      code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
text-align: center;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
div.quote {
border-left: 7px solid #ccc;
background: #f9f9f9;
margin: 1.5em 10px;
padding-left: 20px;
}
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <link href="data:image/x-icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center"><code class="sourceCode cpp"><span class="cf">do</span> <span class="kw">not</span> <span class="cf">return</span> <span class="kw">or</span> <span class="cf">else</span></code></h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #:</td>
    <td>D2121R0</td>
  </tr>
  <tr>
    <td>Date:</td>
    <td>2020-08-02</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project:</td>
    <td>Programming Language C++</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Audience:</td>
    <td>
      EWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to:</td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<h1 data-number="1" style="border-bottom:1px solid #cccccc" id="introduction" data-number="1" style="border-bottom:1px solid #cccccc"><span class="header-section-number">1</span> Introduction<a href="#introduction" class="self-link"></a></h1>
<p>This is somewhat of a novel proposal in that it is not motivated by any problem which currently exists. Instead, it is motivated by the problems that arising out of the Pattern Matching <span class="citation" data-cites="P1371R2">[<a href="#ref-P1371R2" role="doc-biblioref">P1371R2</a>]</span> proposal and its excursion into more complex expressions.</p>
<p>The expression form of <code class="sourceCode cpp">inspect</code> needs its return type to be compatible with all of the cases. But not every case actually contributes to the type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> arg<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="cf">return</span> inspect <span class="op">(</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="dv">0</span><span class="op">:</span> <span class="dv">42</span>;</span>
<span id="cb1-4"><a href="#cb1-4"></a>    _<span class="op">:</span> <span class="cf">throw</span> bad_argument<span class="op">()</span>;</span>
<span id="cb1-5"><a href="#cb1-5"></a>  <span class="op">}</span>;</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="op">}</span></span></code></pre></div>
<p>Here, we have two cases: one has type <code class="sourceCode cpp"><span class="dt">int</span></code>, and the other technically has type <code class="sourceCode cpp"><span class="dt">void</span></code>. But because the <code class="sourceCode cpp"><span class="cf">throw</span></code> actually escapes the scope anyway, we don’t need to consider that case when resolving the type. As a result, the above can be a perfectly valid use of <code class="sourceCode cpp">inspect</code> - the type of the expression can be said to be <code class="sourceCode cpp"><span class="dt">int</span></code>.</p>
<p>This, in of itself, isn’t novel. We already carve out an exception for <code class="sourceCode cpp"><span class="cf">throw</span></code> in the conditional operator, and the following rewrite of the above example has been valid for a long time:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">int</span> g<span class="op">(</span><span class="dt">int</span> arg<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="cf">return</span> <span class="op">(</span>arg <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">?</span> <span class="dv">42</span> <span class="op">:</span> <span class="cf">throw</span> bad_argument<span class="op">()</span>;</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="op">}</span></span></code></pre></div>
<p>But while <code class="sourceCode cpp"><span class="cf">throw</span></code> is the only exception (not sorry) for the conditional operator, there are other statements in C++ which escape their scope and thus could potentially be excluded from consideration when it comes to types, and could be used as scope-escaping expressions. The full set of such keyword-driven statements is:</p>
<ul>
<li><code class="sourceCode cpp"><span class="cf">break</span></code></li>
<li><code class="sourceCode cpp"><span class="cf">continue</span></code></li>
<li><code class="sourceCode cpp"><span class="kw">co_return</span></code></li>
<li><code class="sourceCode cpp"><span class="cf">goto</span></code></li>
<li><code class="sourceCode cpp"><span class="cf">return</span></code></li>
<li><code class="sourceCode cpp"><span class="cf">throw</span></code></li>
</ul>
<p><code class="sourceCode cpp"><span class="cf">goto</span></code> is a little special, but the others behave a lot like <code class="sourceCode cpp"><span class="cf">throw</span></code>: they necessarily escape scope and have no possible value, so they can’t meaningfully affect the type of an expression. The following could be a perfectly reasonable function (though this paper is not proposing it):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="dt">int</span> h<span class="op">(</span><span class="dt">int</span> arg<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="dt">int</span> r <span class="op">=</span> <span class="op">(</span>arg <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">?</span> <span class="dv">42</span> <span class="op">:</span> <span class="cf">return</span> <span class="dv">17</span>;</span>
<span id="cb3-3"><a href="#cb3-3"></a>    std<span class="op">::</span>cout <span class="op">&lt;&lt;</span> r;</span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="cf">return</span> r;</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="op">}</span></span></code></pre></div>
<p>But in addition to those keywords, there’s one more thing in C++ that is guaranteed to escape scope: invoking a function marked <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code> (such as <code class="sourceCode cpp">std<span class="op">::</span>abort<span class="op">()</span></code> or <code class="sourceCode cpp">std<span class="op">::</span>terminate<span class="op">()</span></code>). And here, we run into a problem. While it’s straightforward to extend the rules to treat all escaping statements as valueless, we cannot do the same for <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code> functions:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="dt">int</span> maybe_terminate<span class="op">(</span><span class="dt">int</span> arg<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="cf">return</span> inspect <span class="op">(</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="dv">0</span><span class="op">:</span> <span class="dv">42</span>;</span>
<span id="cb4-4"><a href="#cb4-4"></a>    _<span class="op">:</span> std<span class="op">::</span>terminate<span class="op">()</span>;</span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="op">}</span>;</span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="op">}</span></span></code></pre></div>
<p>The guidance we adopted in Albuquerque <span class="citation" data-cites="Attributes">[<a href="#ref-Attributes" role="doc-biblioref">Attributes</a>]</span> during the discussion of <span class="citation" data-cites="P0840R0">[<a href="#ref-P0840R0" role="doc-biblioref">P0840R0</a>]</span> was:</p>
<div class="quote">
<p>Compiling a valid program with all instances of a particular attribute ignored must result in a correct implementation of the original program.</p>
</div>
<p>The above <code class="sourceCode cpp">inspect</code>, if we added semantic meaning to <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code>, could work - it would ignore the second pattern and simply deduce the type of the <code class="sourceCode cpp">inspect</code>-expression as <code class="sourceCode cpp"><span class="dt">int</span></code>. But if we ignored <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code>, then we have two patterns of differing type (<code class="sourceCode cpp"><span class="dt">int</span></code> and <code class="sourceCode cpp"><span class="dt">void</span></code>) and the type of the <code class="sourceCode cpp">inspect</code>-expression would have to be either <code class="sourceCode cpp"><span class="dt">void</span></code> or ill-formed, either way definitely not <code class="sourceCode cpp"><span class="dt">int</span></code>. This violates the attribute rule.</p>
<p>However, being able to <code class="sourceCode cpp">std<span class="op">::</span>terminate<span class="op">()</span></code> or <code class="sourceCode cpp">std<span class="op">::</span>abort<span class="op">()</span></code> or <code class="sourceCode cpp">std<span class="op">::</span>unreachable<span class="op">()</span></code> in a particular case is an important feature in an <code class="sourceCode cpp">inspect</code>-expression, and so the problem of how to make it work must be resolved… somehow.</p>
<h1 data-number="2" style="border-bottom:1px solid #cccccc" id="presentation-of-alternatives" data-number="2" style="border-bottom:1px solid #cccccc"><span class="header-section-number">2</span> Presentation of Alternatives<a href="#presentation-of-alternatives" class="self-link"></a></h1>
<p>This paper goes through four mechanisms for how we could get this behavior to work. It will first introduce the four mechanisms, and then compare and contrast them.</p>
<h2 data-number="2.1" id="annotate-escaping-blocks" data-number="2.1"><span class="header-section-number">2.1</span> Annotate escaping blocks<a href="#annotate-escaping-blocks" class="self-link"></a></h2>
<p>At a session in Prague, the paper authors proposed new syntax for introducing a block which marked the block as <code class="sourceCode cpp">noreturn</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="dt">int</span> maybe_terminate<span class="op">(</span><span class="dt">int</span> arg<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="cf">return</span> inspect <span class="op">(</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="dv">0</span><span class="op">:</span> <span class="dv">42</span>;</span>
<span id="cb5-4"><a href="#cb5-4"></a>    _<span class="op">:</span> <span class="op">!{</span> std<span class="op">::</span>terminate<span class="op">()</span>; <span class="op">}</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>  <span class="op">}</span>;</span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="op">}</span></span></code></pre></div>
<p>The above could then be allowed: the second case would be considered an escaping statement by virtue of the <code class="sourceCode cpp"><span class="op">!{</span> <span class="op">...</span> <span class="op">}</span></code> and would thus not participate in determining the type. This leaves a single case having type <code class="sourceCode cpp"><span class="dt">int</span></code>.</p>
<p>Such an annotation could be enforced by the language to not escape (e.g. by inserting a call to <code class="sourceCode cpp">std<span class="op">::</span>terminate</code> on exiting the scope), so there is no UB concern here or anything.</p>
<p>There may be other mechanisms to annotate escaping blocks besides <code class="sourceCode cpp"><span class="op">!{</span> <span class="op">...</span> <span class="op">}</span></code> but this paper considers any others to be just differences in spelling anyway, so only this one is considered (and the spelling isn’t really important anyway).</p>
<h2 data-number="2.2" id="annotate-escaping-functions" data-number="2.2"><span class="header-section-number">2.2</span> Annotate escaping functions<a href="#annotate-escaping-functions" class="self-link"></a></h2>
<p>The other three suggested mechanisms all are based on applying some kind of annotation to the <em>functions</em> that escape rather than to the blocks that invoke these functions. These are:</p>
<h3 data-number="2.2.1" id="a-new-type-indicating-escaping" data-number="2.2.1"><span class="header-section-number">2.2.1</span> A new type indicating escaping<a href="#a-new-type-indicating-escaping" class="self-link"></a></h3>
<p>C and C++ have the type <code class="sourceCode cpp"><span class="dt">void</span></code>, but despite the name, it’s not an entirely uninhabited type. You can’t have an object of type <code class="sourceCode cpp"><span class="dt">void</span></code> (yet?), but functions which return <code class="sourceCode cpp"><span class="dt">void</span></code> do, in fact, return. We could introduce a new type that actually has zero possible values, which would indicate that a function can never return. For the sake of discussion, let’s call this type <code class="sourceCode cpp"><span class="kw">true</span> <span class="dt">void</span></code>. Actually, that’s a bit much. Let’s call it <code class="sourceCode cpp">std<span class="op">::</span>never</code>.</p>
<p>We could then change the declaration of functions like <code class="sourceCode cpp">std<span class="op">::</span>abort<span class="op">()</span></code>:</p>
<div>
<div class="sourceCode" id="cb6"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb6-1"><a href="#cb6-1"></a><span class="st">- [[noreturn]] void abort() noexcept;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="va">+ never abort() noexcept;</span></span></code></pre></div>
</div>
<p>The advantage here is that once the noreturn functions return <code class="sourceCode cpp">std<span class="op">::</span>never</code>, the language can understand that a block ending with one of these functions can never return, so we don’t need the <code class="sourceCode cpp"><span class="op">!{</span> <span class="op">...</span> <span class="op">}</span></code> syntax. The motivating example just works:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="dt">int</span> maybe_terminate<span class="op">(</span><span class="dt">int</span> arg<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="cf">return</span> inspect <span class="op">(</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="dv">0</span><span class="op">:</span> <span class="dv">42</span>;</span>
<span id="cb7-4"><a href="#cb7-4"></a>    _<span class="op">:</span> std<span class="op">::</span>terminate<span class="op">()</span>; <span class="co">// ok, returns std::never, so never returns</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>  <span class="op">}</span>;</span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="2.2.2" id="a-keyword-indicating-escaping" data-number="2.2.2"><span class="header-section-number">2.2.2</span> A keyword indicating escaping<a href="#a-keyword-indicating-escaping" class="self-link"></a></h3>
<p>We could take the <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code> function attribute and elevate it into a first class language feature, so that future language evolution (e.g. pattern matching) may then take this into account in determining semantics.</p>
<p>The syntax this paper proposes is:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>  <span class="cf">do</span> <span class="kw">not</span> <span class="cf">return</span> <span class="kw">or</span> <span class="cf">else</span> <span class="dt">void</span> abort<span class="op">()</span>;</span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="cf">do</span> <span class="kw">not</span> <span class="cf">return</span> <span class="kw">or</span> <span class="cf">else</span> <span class="dt">void</span> terminate<span class="op">()</span>;</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="op">}</span></span></code></pre></div>
<p>Just kidding. The syntax this paper is actually proposing (for reasons that will become clearer shortly) is the keyword spelled <code class="sourceCode cpp"><span class="kw">_Noreturn</span></code> (this is already a keyword in C so seems straightforwardly available):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="kw">_Noreturn</span> <span class="dt">void</span> abort<span class="op">()</span>;</span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="kw">_Noreturn</span> <span class="dt">void</span> terminate<span class="op">()</span>;</span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="op">}</span></span></code></pre></div>
<p>This means that libraries straddling multiple language versions may end up having to write:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a>NORETURN_SPECIFIER <span class="dt">void</span> abort<span class="op">()</span>;</span></code></pre></div>
<p>but because there are a fairly small number of such functions, I don’t think it’s a huge problem.</p>
<h3 data-number="2.2.3" id="adding-semantics-to-the-noreturn-attribute" data-number="2.2.3"><span class="header-section-number">2.2.3</span> Adding semantics to the <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code> attribute<a href="#adding-semantics-to-the-noreturn-attribute" class="self-link"></a></h3>
<p>Instead of introducing a new language feature to mark a block as escaping (as proposed in Prague), or introducing a new language feature to mark a function as escaping (as in the previous two sections), let’s actually just take advantage of the fact that we already have a language feature to mark a function as escaping: the <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code> attribute.</p>
<p>That is: don’t introduce anything new at all. Just allow the <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code> attribute to have semantic meaning. Say that a function so annotated counts as an escaping function, as a language rule, and allow that to work.</p>
<h1 data-number="3" style="border-bottom:1px solid #cccccc" id="comparison-of-alternatives" data-number="3" style="border-bottom:1px solid #cccccc"><span class="header-section-number">3</span> Comparison of Alternatives<a href="#comparison-of-alternatives" class="self-link"></a></h1>
<p>The set of <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code>-annotated functions is very small (the standard library has 9: <code class="sourceCode cpp">std<span class="op">::</span>abort</code>, <code class="sourceCode cpp">std<span class="op">::</span>exit</code>, <code class="sourceCode cpp">std<span class="op">::</span>_Exit</code>, <code class="sourceCode cpp">std<span class="op">::</span>quick_exit</code>, <code class="sourceCode cpp">std<span class="op">::</span>terminate</code>, <code class="sourceCode cpp">std<span class="op">::</span>rethrow_exception</code>, <code class="sourceCode cpp">std<span class="op">::</span>throw_with_nested</code>, <code class="sourceCode cpp">std<span class="op">::</span>nested_exception<span class="op">::</span>rethrow_nested</code>, and <code class="sourceCode cpp">std<span class="op">::</span>longjmp</code> - with <code class="sourceCode cpp">std<span class="op">::</span>unreachable</code> on the way), and we already have to annotate these functions. It’s hard to count how many uses of this attribute exist in the wild since it so frequently shows up being a macro, but I think it’s safe to say that the number of invocations of escaping functions far exceeds the number of declared escaping functions. By many orders of magnitude.</p>
<p>Given that, and the fact that we need to make some kind of language change to make this work anyway, it seems like we should change the language to recognize the escaping functions themselves rather than recognize uses of them. The suggested path of <code class="sourceCode cpp"><span class="op">!{</span> std<span class="op">::</span>abort<span class="op">()</span>; <span class="op">}</span></code> isn’t exactly enormous syntactic overhead over <code class="sourceCode cpp">std<span class="op">::</span>abort<span class="op">()</span></code>, it’s probably about as minimal an annotation as you can really get, but it just seems like the wrong direction to take - and it seems better for the annotation to be localized to the functions rather than the invocations of them. We should instead elevate <code class="sourceCode cpp">noreturn</code> to be a first-class language feature so that we can treat <code class="sourceCode cpp">std<span class="op">::</span>terminate<span class="op">()</span></code> the same as a <code class="sourceCode cpp"><span class="cf">return</span></code> or a <code class="sourceCode cpp"><span class="cf">throw</span></code> without requiring further annotation on all uses of it.</p>
<p>Let’s go through the suggested options for annotating the function itself.</p>
<p>The problem with introducing a new type like <code class="sourceCode cpp">std<span class="op">::</span>never</code> is the enormous amount of work necessary to really work through what <code class="sourceCode cpp">std<span class="op">::</span>never</code> means in the type system. Can you have a…</p>
<ul>
<li><code class="sourceCode cpp">never<span class="op">&amp;</span></code>? Much like <code class="sourceCode cpp"><span class="dt">void</span><span class="op">&amp;</span></code>, there cannot be such an object, so forming a valid reference is impossible. Would that mean that the type itself is ill-formed or would that mean that a function returning a <code class="sourceCode cpp">never<span class="op">&amp;</span></code> never returns?</li>
<li><code class="sourceCode cpp">never<span class="op">*</span></code>? Since there can never be a <code class="sourceCode cpp">never</code> object to point to, this seems like the same case as <code class="sourceCode cpp">never<span class="op">&amp;</span></code> - but there is one exception. A <code class="sourceCode cpp">never<span class="op">*</span></code> could still have a null pointer value. That’s not pointing to an object right? Does this mean that a <code class="sourceCode cpp">never<span class="op">*</span> f<span class="op">()</span></code> necessarily returns a null pointer?</li>
<li><code class="sourceCode cpp">pair<span class="op">&lt;</span>never, <span class="dt">int</span><span class="op">&gt;</span></code>? As a proxy for having a class type with a <code class="sourceCode cpp">never</code> - this would also be a type that’s impossible to form. So this one, like <code class="sourceCode cpp">never<span class="op">&amp;</span></code>, would either also be an “escaping type” or ill-formed.</li>
<li><code class="sourceCode cpp">optional<span class="op">&lt;</span>never<span class="op">&gt;</span></code>? This is a lot like <code class="sourceCode cpp">never<span class="op">*</span></code> - it can never hold a value but it’s perfectly fine to empty? But how would you construct the language rules such that it’s implementable properly? If you could, then this would be a conditionally escaping type? What would that mean? Another isomorphic type would be <code class="sourceCode cpp">variant<span class="op">&lt;</span>T, never<span class="op">&gt;</span></code>, which would necessarily hold a <code class="sourceCode cpp">T</code>.</li>
</ul>
<p>All of these questions seem quite interesting to think about, but ultimately the benefit doesn’t seem to be there at all. It’s nice to only have to annotate the escaping functions - rather than all escaping uses of those functions - but this direction just has too many other questions.</p>
<p>That reduces us to the last two choices:</p>
<ol type="1">
<li>Introduce <code class="sourceCode cpp"><span class="kw">_Noreturn</span></code> as a <em>function-specifier</em>, or</li>
<li>Allow the language to impart semantics on <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code>.</li>
</ol>
<p>The advantage of the former is it allows us to preserve the adopted guidance on the meaning of attributes from Albuquerque.</p>
<p>The advantage of the latter is: we already have an existing solution to exactly this problem, and having to introduce a new language feature, to solve exactly the same problem, seems like artificial and pointless language churn. The issue is that we are not allowing ourselves to use the existing solution to this problem. Maybe we should?</p>
<p>Sure, such a direction would open the door to wanting to introduce other attributes that may want to have normative semantic impact, and we’d lose the ability to just reject all of those uniformly. But I think we should seriously consider this direction. It would mean that we would not have to make any changes to the standard library at all. Any user-defined <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code> functions that already exist would just seamlessly work without them having to make any changes.</p>
<p>Note that <code class="sourceCode cpp"><span class="op">[[</span><span class="at">no_unique_address</span><span class="op">]]</span></code>, the attribute during whose discussion we adopted this guidance, already is somewhat fuzzy with this rule. The correctness of a program may well depend annotated members taking no space (e.g. if a type so annotated needs to be constructed in a fixed-length buffer). We more or less say this doesn’t count, and there is certainly no such fuzziness with the other attributes like <code class="sourceCode cpp"><span class="op">[[</span><span class="at">likely</span><span class="op">]]</span></code>, <code class="sourceCode cpp"><span class="op">[[</span><span class="at">fallthrough</span><span class="op">]]</span></code>, or <code class="sourceCode cpp"><span class="op">[[</span><span class="at">deprecated</span><span class="op">]]</span></code>.</p>
<p>But there’s one other important thing to consider…</p>
<h1 data-number="4" style="border-bottom:1px solid #cccccc" id="c-compatibility" data-number="4" style="border-bottom:1px solid #cccccc"><span class="header-section-number">4</span> C Compatibility<a href="#c-compatibility" class="self-link"></a></h1>
<p>An important thing to consider is C compatibility. C <em>also</em> has functions that do not return, and we should figure out how to treat those as escaping functions as well. C has a <em>different</em> function annotation to indicate an escaping function, introduced in C11 by <span class="citation" data-cites="C.N1478">[<a href="#ref-C.N1478" role="doc-biblioref">C.N1478</a>]</span>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a>_Noreturn <span class="dt">void</span> fatal<span class="op">(</span><span class="dt">void</span><span class="op">)</span>; </span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="dt">void</span> fatal<span class="op">()</span> <span class="op">{</span> </span>
<span id="cb11-4"><a href="#cb11-4"></a>  <span class="co">/* ... */</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>  exit<span class="op">(</span><span class="dv">1</span><span class="op">)</span>; </span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="op">}</span></span></code></pre></div>
<p>Where the C functions <code class="sourceCode cpp">longjmp<span class="op">()</span></code>, <code class="sourceCode cpp">abort<span class="op">()</span></code>, <code class="sourceCode cpp">exit<span class="op">()</span></code>, <code class="sourceCode cpp">_Exit<span class="op">()</span></code>, and <code class="sourceCode cpp">quick_exit<span class="op">()</span></code> so annotated. C also provides a header which <code class="sourceCode cpp"><span class="pp">#define</span></code>s <code class="sourceCode cpp">noreturn</code> to <code class="sourceCode cpp">_Noreturn</code>.</p>
<p>On top of this, WG14 is pursuing the C++ <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code> attribute itself, via <span class="citation" data-cites="C.N2410">[<a href="#ref-C.N2410" role="doc-biblioref">C.N2410</a>]</span>.</p>
<p>This suggests that pursuing a different keyword (possibly a context-sensitive one) for <code class="sourceCode cpp">noreturn</code> would just introduce a <em>new</em> incompatibility with C, that C is currently working to remedy. Unless the keyword we picked was, specifically, <code class="sourceCode cpp"><span class="kw">_Noreturn</span></code>.</p>
<p>But the C compatibility issue is actually even stronger than this. While in C++, we just have <em>guidance</em> that attributes <em>should</em> be ignorable, this is actually normative in C. From the latest C working draft, 6.7.11.1p3 <span class="citation" data-cites="C.N2478">[<a href="#ref-C.N2478" role="doc-biblioref">C.N2478</a>]</span>:</p>
<div class="quote">
<p>A strictly conforming program using a standard attribute remains strictly conforming in the absence of that attribute.</p>
</div>
<p>with corresponding footnote:</p>
<div class="quote">
<p>Standard attributes specified by this document can be parsed but ignored by an implementation without changing thesemantics of a correct program; the same is not true for attributes not specified by this document.</p>
</div>
<p>That’s pretty clear. If C++ adopts semantics for <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code>, that kills any attempt at C compatibility going forward.</p>
<h1 data-number="5" style="border-bottom:1px solid #cccccc" id="proposal" data-number="5" style="border-bottom:1px solid #cccccc"><span class="header-section-number">5</span> Proposal<a href="#proposal" class="self-link"></a></h1>
<p>Given WG21’s guidance that attributes should be ignorable, and WG14’s normative rule of the same, it seems like the best course of action is to introduce a new, keyword to indicate that a function will not return.</p>
<p>For compatibility with C, which already has exactly this feature, we should just adopt the C feature.</p>
<p>This would be a novel direction in C++, since we typically don’t use these kinds of names, but as mentioned before, the number of noreturn functions is small so it seems far more important to get a consistent feature than it is to have that feature have nice spelling.</p>
<p>We would then go through the library and swap out the <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code> attribute for the <code class="sourceCode cpp"><span class="kw">_Noreturn</span></code> specifier:</p>
<div>
<div class="sourceCode" id="cb12"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb12-1"><a href="#cb12-1"></a><span class="st">- [[noreturn]] void terminate() noexcept;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="va">+ _Noreturn void terminate() noexcept;</span></span></code></pre></div>
</div>
<h2 data-number="5.1" id="interaction-with-the-type-system" data-number="5.1"><span class="header-section-number">5.1</span> Interaction with the type system<a href="#interaction-with-the-type-system" class="self-link"></a></h2>
<p>I want to be very clear that regardless of the direction taken for this paper, given:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">_Noreturn</span> <span class="dt">void</span> f<span class="op">()</span>;</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="dt">void</span> g<span class="op">()</span>;</span></code></pre></div>
<p>the type of <code class="sourceCode cpp">f</code> is still <code class="sourceCode cpp"><span class="dt">void</span><span class="op">()</span></code>, the same as the type of <code class="sourceCode cpp">g</code>. Though it turns out that clang <em>already</em> models <code class="sourceCode cpp">__attribute<span class="op">((</span>noreturn<span class="op">))</span></code> (but not <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code>) in the type system:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">constexpr</span> <span class="dt">bool</span> is_noreturn<span class="op">(</span>T <span class="op">())</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">false</span>; <span class="op">}</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> is_noreturn<span class="op">(</span>__attribute__<span class="op">((</span>noreturn<span class="op">))</span> T <span class="op">())</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">true</span>; <span class="op">}</span></span>
<span id="cb14-5"><a href="#cb14-5"></a></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="dt">int</span> x<span class="op">()</span>;</span>
<span id="cb14-7"><a href="#cb14-7"></a>__attribute__<span class="op">((</span>noreturn<span class="op">))</span> <span class="dt">float</span> y<span class="op">()</span>;</span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span> <span class="dt">double</span> z<span class="op">()</span>;</span>
<span id="cb14-9"><a href="#cb14-9"></a></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="kw">static_assert</span><span class="op">(</span><span class="kw">not</span> is_noreturn<span class="op">(</span>x<span class="op">))</span>;</span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="kw">static_assert</span><span class="op">(</span>is_noreturn<span class="op">(</span>y<span class="op">))</span>;</span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="kw">static_assert</span><span class="op">(</span><span class="kw">not</span> is_noreturn<span class="op">(</span>z<span class="op">))</span>;</span></code></pre></div>
<p>But, again, not something I’m interesting in.</p>
<h2 data-number="5.2" id="proposed-wording" data-number="5.2"><span class="header-section-number">5.2</span> Proposed Wording<a href="#proposed-wording" class="self-link"></a></h2>
<p>In <span>5.11 <a href="https://wg21.link/lex.key">[lex.key]</a></span>, add <code class="sourceCode cpp"><span class="kw">_Noreturn</span></code> as a keyword.</p>
<p>Change <span>7.5.5 <a href="https://wg21.link/expr.prim.lambda">[expr.prim.lambda]</a></span>/3:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> In the <em>decl-specifier-seq</em> of the <em>lambda-declarator</em>, each <em>decl-specifier</em> shall be one of <code class="sourceCode cpp"><span class="kw">mutable</span></code>, <code class="sourceCode cpp"><span class="kw">constexpr</span></code>, <span class="rm" style="color: #bf0303"><del>or</del></span> <code class="sourceCode cpp"><span class="kw">consteval</span></code> <span class="addu">, or <code class="sourceCode cpp">_Noreturn</code></span>. [<em>Note</em>: The trailing requires-clause is described in [dcl.decl]. — <em>end note</em>]</p>
</blockquote>
<p>Add somewhere in <span>7.5.5.1 <a href="https://wg21.link/expr.prim.lambda.closure">[expr.prim.lambda.closure]</a></span>:</p>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized">*</a></span> If the <em>lambda-expression</em>’s <em>decl-specifier-seq</em> contains <code class="sourceCode cpp">_Noreturn</code> and if the function call operator or any given operator template specification is called and eventually returns, the behavior is undefined.</p>
</div>
<p>In <span>9.2.2 <a href="https://wg21.link/dcl.fct.spec">[dcl.fct.spec]</a></span>, change the grammar to add <code class="sourceCode cpp"><span class="kw">_Noreturn</span></code> as a <em>function-specifier</em>:</p>
<div>
<div class="sourceCode" id="cb15"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb15-1"><a href="#cb15-1"></a><em>function-specifier</em>:</span>
<span id="cb15-2"><a href="#cb15-2"></a>    virtual</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="va">+   _Noreturn</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>    <em>explicit-specifier</em></span>
<span id="cb15-5"><a href="#cb15-5"></a>    </span>
<span id="cb15-6"><a href="#cb15-6"></a><em>explicit-specifier</em>:</span>
<span id="cb15-7"><a href="#cb15-7"></a>    explicit ( <em>constant-expression</em> )</span>
<span id="cb15-8"><a href="#cb15-8"></a>    explicit</span></code></pre></div>
</div>
<p>Add a new paragraph to the end of <span>9.2.2 <a href="https://wg21.link/dcl.fct.spec">[dcl.fct.spec]</a></span> (this is the same wording as in <span>9.12.9 <a href="https://wg21.link/dcl.attr.noreturn">[dcl.attr.noreturn]</a></span>):</p>
<div class="addu">
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> If a function <code class="sourceCode cpp">f</code> is called where <code class="sourceCode cpp">f</code> was previously declared with the <code class="sourceCode cpp">_Noreturn</code> specifier and <code class="sourceCode cpp">f</code> eventually returns, the behavior is undefined. [<em>Note</em>: The function may terminate by throwing an exception. — <em>end note</em>]</p>
</div>
<p>Change all uses of <code class="sourceCode cpp"><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></code> as an attribute in <span>17 <a href="https://wg21.link/support">[support]</a></span> to use the <code class="sourceCode cpp"><span class="kw">_Noreturn</span></code> specifier instead. Those uses are:</p>
<blockquote>
<ul>
<li><code class="sourceCode cpp">abort</code>, <code class="sourceCode cpp">exit</code>, <code class="sourceCode cpp">_Exit</code>, and <code class="sourceCode cpp">quick_exit</code> in <span>17.2.2 <a href="https://wg21.link/cstdlib.syn">[cstdlib.syn]</a></span></li>
<li><code class="sourceCode cpp">abort</code>, <code class="sourceCode cpp">exit</code>, <code class="sourceCode cpp">_Exit</code>, and <code class="sourceCode cpp">quick_exit</code> in <span>17.5 <a href="https://wg21.link/support.start.term">[support.start.term]</a></span></li>
<li><code class="sourceCode cpp">terminate</code>, <code class="sourceCode cpp">rethrow_exception</code>, and <code class="sourceCode cpp">throw_with_nested</code> in <span>17.9.1 <a href="https://wg21.link/exception.syn">[exception.syn]</a></span></li>
<li><code class="sourceCode cpp">terminate</code> in <span>17.9.4.4 <a href="https://wg21.link/terminate">[terminate]</a></span></li>
<li><code class="sourceCode cpp">rethrow_exception</code> in <span>17.9.6 <a href="https://wg21.link/propagation">[propagation]</a></span></li>
<li><code class="sourceCode cpp">nested_exception<span class="op">::</span>rethrow_nested</code> and <code class="sourceCode cpp">throw_with_nested</code> in <span>17.9.7 <a href="https://wg21.link/except.nested">[except.nested]</a></span> <code class="sourceCode cpp">longjmp</code> in <span>17.13.2 <a href="https://wg21.link/csetjmp.syn">[csetjmp.syn]</a></span></li>
</ul>
</blockquote>
<h2 data-number="5.3" id="feature-test-macro" data-number="5.3"><span class="header-section-number">5.3</span> Feature-test macro<a href="#feature-test-macro" class="self-link"></a></h2>
<p>Add the feature-test macro <code class="sourceCode cpp">__cpp_noreturn</code>. This will let users properly add non-returning semantics to their functions:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="pp">#if __cpp_noreturn</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="pp">#  define NORETURN </span>_Noreturn</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="pp">#elif __cpp_has_attribute(noreturn)</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="pp">#  define NORETURN </span><span class="op">[[</span><span class="at">noreturn</span><span class="op">]]</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="pp">#else</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="pp">#  define NORETURN</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="pp">#endif</span></span></code></pre></div>
<h1 data-number="6" style="border-bottom:1px solid #cccccc" id="acknowledgments" data-number="6" style="border-bottom:1px solid #cccccc"><span class="header-section-number">6</span> Acknowledgments<a href="#acknowledgments" class="self-link"></a></h1>
<p>Thanks to Aaron Ballman for pointing me to the relevant C rules and discussing the issues with me.</p>
<h1 data-number="7" style="border-bottom:1px solid #cccccc" id="bibliography" data-number="7" style="border-bottom:1px solid #cccccc"><span class="header-section-number">7</span> References<a href="#bibliography" class="self-link"></a></h1>
<div id="refs" class="references hanging-indent" role="doc-bibliography">
<div id="ref-Attributes">
<p>[Attributes] EWG. 2017. EWG discussion of P0840R0. <br />
<a href="http://wiki.edg.com/bin/view/Wg21albuquerque/P0840R0">http://wiki.edg.com/bin/view/Wg21albuquerque/P0840R0</a></p>
</div>
<div id="ref-C.N1478">
<p>[C.N1478] David Svoboda. 2010. Supporting the “noreturn” property in C1x. <br />
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1478.htm">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1478.htm</a></p>
</div>
<div id="ref-C.N2410">
<p>[C.N2410] Aaron Ballman. 2019. The noreturn attribute. <br />
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2410.pdf">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2410.pdf</a></p>
</div>
<div id="ref-C.N2478">
<p>[C.N2478] WG14. 2020. C Working Draft. <br />
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2478.pdf">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2478.pdf</a></p>
</div>
<div id="ref-P0840R0">
<p>[P0840R0] Richard Smith. 2017. Lamguage support for empty objects. <br />
<a href="https://wg21.link/p0840r0">https://wg21.link/p0840r0</a></p>
</div>
<div id="ref-P1371R2">
<p>[P1371R2] Sergei Murzin, Michael Park, David Sankel, Dan Sarginson. 2020. Pattern Matching. <br />
<a href="https://wg21.link/p1371r2">https://wg21.link/p1371r2</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
